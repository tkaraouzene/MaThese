---
output:
  word_document: default
  html_document: default
  pdf_document: default
  classoption: landscape
---
# Mise en place d’une stratégie pour l’analyse des données exomiques – application en recherche clinique  

```{r include.packages2, include=FALSE}
# This chunk ensures that the thesisdown package is
# installed and loaded. This thesisdown package includes
# the template files for the thesis.

if(!require(devtools))
  install.packages("devtools", repos = "http://cran.rstudio.com")

if(!require(bookdown))
  devtools::install_github('rstudio/bookdown')

if(!require(thesisdown))
  devtools::install_github("ismayc/thesisdown")
# 
if(!require(kableExtra))
  devtools::install_github("haozhu233/kableExtra", ref = "f451dbb62cf72e16050fe39ea5ae99b3fd53a617")

library(thesisdown)
library(pander)
library(knitr)
library(tidyr)
library(dplyr)
library(data.table)
library(ggplot2)
library(stringi)
library(scales)
library(cowplot)
library(stringr)
library(foreach) 
library(viridis)
library(kableExtra)

theme_set(theme_gray()) # otherwise use cowplot default theme

source("script/manage_variants.R")
source("script/variant_filtering.R")
source("script/resume_data.R")
source("script/plot_vep_results.R")
source("script/gene_expression.R")

opts_knit$set(eval.after = c("fig.cap","fig.scap"))

knitr::opts_chunk$set(fig.align='center',echo=FALSE)

```

```{r localfunction, cache=TRUE}

open_ctrl <- function(file=NULL, pheno = "none", df=NULL) {
  
  if(is.null(df)) df <- fread(file, sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE)
  
  df %>%
    gather(RUN, CALL, starts_with("Ghs")) %>% 
    gather(RUN, CALL, starts_with("1")) %>% 
    
    filter(CALL %in% c(3, "c")) %>%
    mutate(N_CTRL = n_distinct(RUN),
           PHENO = pheno,
           CHR = as.character(CHR))  %>%
    select(-CALL) %>% 
    distinct(CHR, POSITION, REF, ALT, N_CTRL, PHENO)
}

`%tin%` <- function(x, y) {
    mapply(assign, as.character(substitute(x)[-1]), y,
      MoreArgs = list(envir = parent.frame()))
    invisible()
}

tab_gene <- function(df, gene) {
  
  tab_gene <- df %>% 
    filter(SYMBOL == gene) %>% 
    mutate(VARIANT = paste(CHR,POSITION,REF,ALT, sep = "-"),
           Consequence = sapply(strsplit(Consequence, "_variant", fixed = TRUE),"[[",1),
           Consequence = gsub("_", " ", Consequence)) %>%
    distinct(RUN, VARIANT, CALL, Consequence, SYMBOL) %>% 
    arrange(desc(CALL), RUN)
  
  run_homo <- tab_gene %>% filter(CALL == "Homozygous") %>% ungroup() %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
  run_het <- tab_gene %>% filter(CALL == "Heterozygous") %>% ungroup() %>% distinct(RUN) %>% collect() %>% .[["RUN"]]

  n_run_homo <- run_homo %>% length
  n_run_het <- run_het %>% length
  list(tab_gene, run_homo, run_het, n_run_homo, n_run_het)
}

na.replace <- function (x, char = "") {
    x[is.na(x)] <- char
    return(x)
}

plot_resume_analysis <- function(df) {
  
  
  levels <- c("High","Moderate","Low")
  
  df <- df %>% 
    mutate(TRUST = factor(TRUST, levels = levels))
  
  n_distinct_gene <- df %>% ungroup() %>% distinct(SYMBOL) %>% nrow
  
  if (n_distinct_gene == 1) {
  
  break_max <- df$N_RUN %>% max
  
  p <- ggplot(df, aes(TRUST, N_RUN)) +
    facet_wrap(~SYMBOL) 
    
  } else {
    
    break_max <- df$TOT %>% max
  
    p <- ggplot(df, aes(reorder(SYMBOL, -TOT), N_RUN)) 
  
    }
  
  p + geom_col(aes(fill = TRUST)) + 
    scale_fill_manual(guide = "none", limits = c("High","Moderate","Low"), values = c("#4DAF4A","#FF7F00","#E41A1C")) + 
    scale_y_continuous(breaks = c(0:break_max)) +
    ylab("Nb of individuals") + 
    xlab("")
  
}

tab_high <- function(df, caption = "", evidence = TRUE, landscape = FALSE) {

  df <- df %>% 
    ungroup() %>% 
    filter(CANONICAL == "YES") %>%
    mutate(HGVSc = na.replace(HGVSc, "."),
           HGVSp = na.replace(HGVSp, "."),
           `HGVSc, HGVSp` = paste0(HGVSc," ; ", HGVSp)) %>%
    select(Patient = RUN, Gene = SYMBOL, Evidence = EVIDENCE, `HGVSc, HGVSp`, Consequence, ESP, `1KG`, ExAC = ExAC_AF) %>%
    arrange(Gene) %>% 
    mutate(ESP = na.replace(ESP, "."),
           `1KG` = na.replace(`1KG`, "."),
           ExAC = na.replace(ExAC, "."))
  
  if(evidence == FALSE) df <- df %>% select(-Evidence)
  
  kdf <- df %>% kable(format = "latex",
                      booktabs = TRUE,
                      longtable = TRUE,
                      caption = caption) %>%
    add_header_above(c(rep(" ", ncol(df) - 5), "Iimpact" = 2, "Frequency" = 3))

  
    if (landscape == TRUE) kdf <- kdf %>% landscape(margin = NULL)

  kdf
  
}

tab_modelow <- function(df, caption = "", landscape = FALSE) {
  
  kdf <- df %>% 
    ungroup() %>%
    filter(CANONICAL == "YES") %>%
    mutate(HGVSc = na.replace(HGVSc, "."),
           HGVSp = na.replace(HGVSp, "."),
           `HGVSc, HGVSp` = paste0(HGVSc," ; ", HGVSp)) %>%

    select(Patient = RUN, Gene = SYMBOL, `HGVSc, HGVSp`, Consequence, SIFT, PolyPhen, ESP, `1KG`, ExAC = ExAC_AF) %>%
    distinct() %>% 
    mutate(ESP = na.replace(ESP, "."),
           `1KG` = na.replace(`1KG`, "."),
           ExAC = na.replace(ExAC, "."),
           SIFT = na.replace(SIFT, "."),
           SIFT = gsub(" low confidence", "", SIFT),
           PolyPhen = na.replace(PolyPhen, "."),
           PolyPhen = gsub("probably", "proba", PolyPhen),
           PolyPhen = gsub("possibly", "possib", PolyPhen)) %>%
    kable(format = "latex",
          booktabs = TRUE,
          longtable = TRUE,
          caption = caption) %>%
    add_header_above(c(" ", " ", "Impact" = 4, "Frequency" = 3)) 
  
  if (landscape == TRUE) kdf <- kdf %>% landscape(margin = NULL)

  kdf

}

paste_vector <- function(v, style = "none", sep = ", ", last = " et ", sort = TRUE) {
  
  if (sort == TRUE) v <- v %>% sort
  
  if (style == "bold") v <- paste0("**",v,"**")
  if (style == "itallic") v <- paste0("*",v,"*")
  if (style == "both") v <- paste0("**_",v,"_**")

  v_head <- v %>% head(-1) %>% paste(collapse = sep)
  
  v_tail <- v %>% tail(1)
  
  paste(v_head, last , v_tail)
}

gene_to_run <- function(df, genes) {
  
  df %>% 
    ungroup() %>% 
    filter(SYMBOL %in% genes) %>% 
    distinct(RUN) %>% 
    collect() %>%
    .[["RUN"]]
  
}

```

```{r callfunction, cache=TRUE}


call_to_strand <- function(call) {
  
  in_ds <- c(1:9)
  in_ss <- letters
  in_ns <- c(0)
  
  out_ds <- rep("DS", length(in_ds))
  out_ss <- rep("SS", length(in_ss))
  out_ns <- rep("NS", length(in_ns))
  
  ca <- c(1,3,4,5,0,"a","b")
  
  plyr::mapvalues(call, from = c(in_ds,in_ss,in_ns), to = c(out_ds, out_ss, out_ns), warn_missing = FALSE)
  
}

call_to_geno <- function(call) {

  in_ref <- c(1, "a")
  in_homo <- c(3, "c")
  in_het <- c(2, "b")
  in_none <- c(0)
  in_ambi <- c(4:7,"d","e","f","g","h","i")
  in_disc <- c(8,9)
  
  out_ref <- rep("Reference", length(in_ref))
  out_homo <- rep("Homozygous", length(in_homo))
  out_het <- rep("Heterozygous", length(in_homo))
  out_none <- rep("None", length(in_none))
  out_ambi <- rep("Ambigous", length(in_ambi))
  out_disc <- rep("Discordant", length(in_disc))
  
  plyr::mapvalues(call, 
                  from = c(in_ref, in_homo, in_het, in_none, in_ambi, in_disc), 
                  to = c(out_ref, out_homo, out_het, out_none, out_ambi, out_disc), 
                  warn_missing = FALSE)

}

var_type <- function (ref, alt) {
  
  vapply(stri_length(ref) == stri_length(alt), function(x) if(isTRUE(x)) "SNV" else "Indel", character(1))
  
}

var_call <- function(file) {
  
  fread(paste("zcat ", file), sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, data.table = FALSE) %>% 
    gather(RUN, CALL, starts_with("Ghs")) %>% 
    filter(!(CALL %in% c("*", "a", 1))) %>%
    mutate(TYPE = var_type(REF, ALT),
           STRAND = call_to_strand(CALL),
           CALL = call_to_geno(CALL))
  
}


define_ctrl_var <- function(ctrls, removed_genotypes = "homo", file = "data/call_results/others_novogen_integragen_var_genotype.csv") {
  
  if (removed_genotypes == "homo") {
    
    removed_call <- c(3, "c")
    
  }
  
  fread(file, sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, data.table = FALSE) %>% 
  select(CHR, POSITION, REF, ALT, one_of(ctrls)) %>% 
  gather(RUN, CALL, -(CHR:ALT)) %>% 
  filter(CALL %in% removed_call,
         !is.na(REF)) %>%
    distinct(CHR, POSITION, REF, ALT)
}


```

\newpage

En 2011, les bases moléculaires d'environ 3700 pathologies à transmission mendélienne avaient été élucidées. Cependant, pour une quantité équivalente de pathologies Mendéliennes (ou suspectées de l'être) cette cause reste un mystère [@Amberger2011]. Avec plusieurs centaines de pathologies caractérisées depuis 2010 [@Ng], les séquençages WGS et WES ont, depuis leur émergence, révolutionné les méthodes de recherche dans le cadre d'étude phénotype-génotype en permettant de manière rapide et à moindre coût le séquençage de la quasi-totalité des gènes humains. Dès lors, le défi de ces analyses n'est plus le séquençage de l'ADN mais l'interprétation des données massives produites. En effet, l'un des plus grands challenges des analyses phénotype-génotype réalisées par WES réside dans l'analyse de l'importante quantité de variants portée par chaque individu s'élevant à plusieurs dizaines de milliers lorsque l'on  compare avec le génome de référence. Même après avoir retiré les variants retrouvés fréquemment dans la population générale, des méthodes additionnelles sont nécessaires pour prédire, parmi les variants restant, lesquels induisent des conséquences fonctionnelles sérieuses afin de les prioriser [@Pelak2010]. De nombreux logiciels tel que Variant Effect Predictor [@McLaren2016], SnpEff [@Cingolani2012] ou encore ANNOVAR [@Wang2010] permettent d'identifier quels sont les variants qui ont un effet tronquant sur la protéine. Cependant, avec en moyenne 165 variants homozygotes ayant un effet tronquant retrouvés dans chaque exome [@Pelak2010] ces méthodes, bien qu'efficaces sont souvent insuffisantes.   

D'autres logiciels tel que Exomiser [@Robinson2014] vont, à partir d'une liste de variants déjà appelés, effectuer les étapes d'annotation, de filtrage et de priorisation. Malgré l'efficacité de ces logiciels, aucun d'entre eux ne couvre l'ensemble des étapes allant de l'alignement des *reads* à la priorisation des variants, la plupart ayant pour point de départ une liste de variants appelés en amont. Ils ne contrôlent donc en aucune manière les étapes d'alignement et d'appel des variants. Or, comme il a été dit plus tôt, ces deux étapes constituent la base de l'analyse. 

Ce chapitre décrit à la fois la constitution d’un pipeline d’analyse des données de séquençage exomique recouvrant l'ensemble des étapes allant de l'alignement des séquences à la priorisation des variants ainsi que son utilisation dans le cadre de la recherche de mutations entrainant différents phénotypes d’infertilité d'une part au sein de cas familiaux et, d’autre part, au sein d'une large cohorte d'individus non apparentés présentant tous un phénotype MMAF.  

\newpage

## Méthode : Description du pipeline

### L'alignement des *reads*  

Comme expliqué plus tôt, l'étape d'alignement a pour objectif de repositionner l'ensemble des *reads* d'un individu le long d'un génome de référence. Cette étape peut ainsi être comparée à la reconstruction d'un puzzle dans lequel chaque *read* peut être assimilé à l'une des pièces tandis que le génome de référence serait ici le modèle (**Figure : **\@ref(fig:picdnamapping)).  

L'ensemble de nos exomes ayant été réalisé en *paired-end*, les deux extrémités de chaque fragment sont séquencées. Chaque *end* d'un même *read* peut donc être considérée comme un *read* à part entière qui est aligné **indépendamment** le long du génome de référence ; l'information fournie par le *paired-end* n'étant utilisée qu'*a posteriori* en tant que critère qualité. Au sein de notre pipeline, cette étape est effectuée par le logiciel MAGIC [@Su2014], qui, dans le cadre de nos études, s'est basé sur la version hg19 / GHRC37 du génome de référence. Suite à cet alignement, plusieurs critères sont observés afin de filtrer les *reads* présentant une faible qualité d'alignement.  

Ainsi, le premier de ces filtres consiste à tout d'abord filtrer l'ensemble des *reads* dupliqués, c'est à dire les *reads* ayant des séquences parfaitement identiques, ceux-ci étant souvent le résultat d'un excès d'amplification au moment des PCRs effectuées en amont. De la même manière, afin d'éviter toute ambiguïté  au moment de l'interprétation des résultats, l'ensemble des *reads* s'étant aligné sur plusieurs régions du génome est aussi filtré. Une fois cela fait, nous vérifions la "compatibilité" des deux *ends* composant chacun des *reads* restant. Un *read* est dit compatible lorsque les deux *ends* qui le composent s'alignent face à face (une sur le brin sens du génome de référence et l'autre sur le brin anti-sens) et couvrent une zone ne faisant pas plus de 3 fois la taille médiane de l'insert. Les *reads* dont les deux *ends* se sont alignées mais ne remplissant pas ces conditions seront dits "non compatibles", ceux dont une seule des deux *ends* s'est alignée seront appelés "orphelins" et enfin ceux pour lesquels aucune des deux *ends* ne se sont alignées sont appelés "non-alignés". L'ensemble des *reads* "non-compatibles", "orphelins" et "non-alignés" sont, en raison de leur faible qualité, filtrés et donc non considérés pour les analyses en aval. Les *reads* ayant passé l'ensemble des critères qualité mentionnés précédemment seront, eux, utilisés pour effectuer l'appel des variants.     

\newpage

### L'appel des variants  

Si l'alignement des séquences peut être comparé à la reconstruction d'un puzzle, l'appel des variants pourrait lui être vu comme un jeu des sept erreurs, au cours duquel, pour chaque position couverte, les différences entre la séquence de l'individu séquencé et le génome de référence seront listées et appelées variants.  

Comme nous l'avons vu plus [ci-dessus](#varcall), il est fortement conseillé d'effectuer l'appel des variants en tenant compte de l'aligneur choisi [@Nielsen2011; @DePristo2011; @Lunter2011]. C'est pourquoi, nous avons développé notre propre algorithme d'appel des variants spécialement conçu pour l'analyse des données de MAGIC. Ainsi, l'appel des variants sera directement basé sur quatre comptages (R$_+$, R$_-$, V$_+$ et V$_-$) fournis directement par MAGIC pour chaque position suffisamment couverte :  

1. **R**$_+$ **et R**$_-$ : Ces deux comptages correspondent au nombre de *reads* *forward* (+) et *reverse* (-) sur lesquels est observé l'allèle de **référence** (R) à une position donnée.  
2. **V**$_+$ **et V**$_-$ : À l'inverse de R$_+$ et R$_-$, ces comptages correspondent au nombre de *reads* *forward* et *reverse* sur lesquels est observé un allèle **variant** (V) à une position donnée.  

Ainsi, les sommes : $R_+ + V_+$ et $R_- + V_-$ indiqueront respectivement la couverture d'une position en ne tenant que des *reads forward* et *reverse*. En fonction de ces couvertures, nos appels seront classés en trois catégories :   

1. **Les appels *double strand* (DS)** :  ils qualifient les positions ayant une couverture $\ge$ 10 sur **les deux** *strands*. Ces appels sont ceux ayant la meilleure qualité. Le choix de la valeur 10 comme critère de couverture minimum est basée sur l'analyse de nos données et sera explicité plus tard dans le manuscrit.    

2. **Les appels *single strand* (SS)** :  ces appels définissent les positions pour lesquelles **un des deux** *strands* présente une couverture $\le$ 10. Dans ce cas, ce *strand* est ignoré et l'appel est effectué uniquement en utilisant le second *strand*.   

3. **Les appels *non strand* (NS)** : les positions NS sont celles pour lesquelles la couverture est $\le$ 10 sur **les deux** *strands*. Aucun appel n'est effectué à ces positions qui **ne sont pas conservées dans la suite des analyses**.    

Ensuite, pour chaque position couverte, des appels indépendants seront effectués pour chaque *strand* de telle sorte que, pour chacune de ces positions si : 

1. 0 à 20% des *reads* portent un variant, la position est appelée **homozygote référence**.  

2. 20 à 40% des *reads* portent un variant, l'appel sera considéré comme **ambigu bas**. Cette région est elle-même subdivisée en deux sous-région, 20 à 30% et 30 à 40%.  

3. 40 à 75% des *reads* portent un variant, la position est appelée **hétérozygote**.  

4. 75 à 85% des *reads* portent un variant, l'appel sera considéré comme **ambigu haut**. Cette région est elle-même subdivisée en deux sous-région, 75 à 80% et 80 à 85%.    

5. 85 à 100% des *reads* portent un variant, la position est appelée **homozygote variant**.  

Pour les positions DS, la concordance des appels fournis par chaque *end* est ensuite vérifiée. Cette vérification de la concordance des appels entre les *reads forward* et *reverse* a pour principal intérêt de filtrer les erreurs systématiques pouvant survenir lors du processus de séquençage. Par exemple, les séquenceurs Illumina vont avoir tendance à "se tromper" à la position T des motifs GGT [@Robinson2011]. De fait, cette erreur devrait *a priori* se produire uniquement lors du séquençage dans un seul des deux sens, celui contenant ce motif. Les *reads* alignés sur le brin complémentaire contiendront dès lors la séquence correcte. C'est pourquoi, afin de limiter les erreurs d'appels au maximum, nous effectuons, pour chaque position DS, des appels indépendants sur les deux sens. Ainsi, un variant sera considéré (**Figure : **\@ref(fig:picvarcall)) :

1. **Homozygote référence**, si les deux appels sont homozygotes références, ou, un des appels est homozygote référence et l'autre se situe dans la sous-région 20-30% de la région ambigu bas.  

2. **Hétérozygote**, si les deux appels sont hétérozygotes, ou, si l'un des appels est hétérozygote et l'autre se situe dans la sous-région 30-40% de la région ambigu bas ou bien dans la sous-région 75-80% de la région ambigu haut.  

3. **Homozygote variant**, si les deux appels sont homozygotes variants, ou, un des appels est homozygote variant et l'autre dans la sous-région 75-85% de la région ambigu haut

5. **Ambigu**, si les deux appels sont ambigus bas ou s'ils sont tous les deux ambigus haut.  

4. **Discordant**, pour toutes les combinaisons restantes.  

Pour les positions SS, l'appel final correspondra directement à l'appel effectué sur l'unique *strand* suffisamment couvert. Ces variants, bien que conservés seront, en raison des erreurs dont ils peuvent être la source, considérés comme de faible qualité. Les appels ambigus et discordants seront, eux, filtrés.  

\newpage

```{r picvarcall,fig.cap='(ref:picvarcall)', fig.scap=fig_name, out.extra="scale=0.5"}

fig_name <- "Détail de l'appel général effectué pour les appels DS"
fig_description <- "Illustration de l'appel des génotypes effectué en fonction du pourcentage de *reads* variants observés sur chacun des deux *strands* de séquençage (*forward* et *reverse*). Le génotype général est appelé si les génotypes des deux brins sont les mêmes ou si l'un des deux est dans la zone ambiguë adjacente au premier. Les zones vertes correspondent aux appels homozygotes références, les zones orange, hétérozygotes et rouges homozygotes variants. Les zones grises sont les appels ambigus tandis que les noires sont les appels discordants. Ces deux derniers appels ne sont pas conservés dans la suite des analyses."
fig_cap <- paste0("**_",fig_name,"_** : ", fig_description)

include_graphics(path = "figure/var_call.png")

```

(ref:picvarcall) `r fig_cap`

\newpage

### L'annotation  

Chaque variant retenu sera ensuite annoté par le logiciel *Variant Effect Predictor* (VEP) [@McLaren2016] qui nous indiquera pour chaque variant la conséquence que celui-ci aura sur la séquence codante de l'ensemble des transcrits Ensembl qu'il chevauche (**Figure : **\@ref(fig:pictvepcsq), **Table : **\@ref(tab:tabvepcsq)). Dans le cas d'une substitution faux-sens, c'est à dire entrainant le changement d'un seul acide-aminé de la séquence protéique, nous utilisons les prédictions fournies par SIFT et PolyPhen afin d'estimer leur pathogénicité. Ensuite, nous ajoutons, pour chaque gène, son expression tissulaire en nous basant sur les données Ensembl [@Aken2017] générées par le projet Illumina BodyMap qui recense les données RNAseq des gènes humains pour 16 tissus différents. Puis nous ajoutons, lorsque celle-ci est disponible, la fréquence du variant dans les bases de données ExAC [@Lek2016], ESP600 ([Exome Variant Server, NHLBI GO Exome Sequencing Project (ESP), Seattle, WA](http://evs.gs.washington.edu/EVS/)) et 1000Genomes [@1000GenomesProjectConsortium2015] donnant ainsi une estimation de sa fréquence dans la population générale. De même, la particularité de ce pipeline est que chaque variant qu'elle a identifié alimente une base de données interne pouvant par la suite servir de contrôle lors de l'analyse d'individus présentant un phénotype différent de ceux étudiés précédemment. L'intérêt d'une telle base, par rapport aux bases de données tel que ExAC, est qu'elle permet d'utiliser, comme contrôle, des individus ayant subi le même protocole de séquençage et la même analyse bio-informatique, permettant ainsi de mieux identifier, et donc filtrer, les erreurs systématiques pouvant arriver à chacune des étapes.   

```{r pictvepcsq, fig.cap='(ref:pictvepcsq)',fig.scap=fig_name, out.extra="scale=.9"}

fig_name <- "Listes des différentes conséquences prédites par VEP et leur positionnement sur le transcrit"
fig_from <- "[*Variant Effect Predictor web site*](http://www.ensembl.org/info/genome/variation/consequences.jpg)"
fig_cap <- paste0("**_",fig_name,"_ d'après : ", fig_from, "**")

include_graphics(path = "figure/vep_csq.jpg")

```

(ref:pictvepcsq) `r fig_cap`

\newpage
\blandscape

```{r tabvepcsq}

tab_name <- ""

df_vep_csq <-  fread("data/vep_csq_modif.csv", sep = "\t", header = TRUE, showProgress = FALSE, data.table = FALSE, verbose = FALSE) %>%
  select(`VEP consequence` = `Display term`,
         `VEP impact` = IMPACT,
         Description = `SO description`)

pander(df_vep_csq,
               justify = 'left',
               split.cells = c(.5,1,50),
               caption = "(\\#tab:tabvepcsq) Liste simplifiée des conséquences prédites par VEP avec leur description et impact associée")

```

\elandscape
\newpage

### Le filtrage des variants  

```{r mafcutoff}

maf_cutoff <- .01

```

L'étape de filtrage est primordiale si l'on souhaite analyser de manière efficace les données provenant de WES. C'est pourquoi, elle occupe une place importante dans notre pipeline. L'intégralité des paramètres de cette étape peut être modifiée par l'utilisateur pour faire correspondre les critères de filtres aux besoins de l'étude. Afin de rendre son utilisation la plus efficace possible, nous avons souhaité définir des paramètres par défauts pertinents dans la plupart des études de séquençage exomique de sorte que, sauf si le contraire est spécifié, les filtres suivants seront appliqués :   

1. **Filtre 1 : L'union des variants** : quand des individus présentent un lien de parenté et présentent le même phénotype, seuls les variants observés chez l'ensemble des individus sont conservés.          

2. **Filtre 2 : Génotype des variants** :  ce pipeline d'analyse a été développé, avant tout, pour la recherche de variants impliqués dans des pathologies à transmission récessive. C'est pourquoi, dans le cadre d'étude d'individus présentant un historique de consanguinité, l'ensemble des variants hétérozygotes sont filtrés. En revanche, dans le cas d'individus issus d'unions non consanguines nous procédons à la recherche de variants hétérozygotes composites, c'est à dire **au moins deux variants hétérozygotes différents situés sur chacun des deux allèles du même gène d'un patient**. Dès lors, bien que les variants soient différents, les deux allèles sont altérés rendant possible l'apparition de phénotype récessif. Malheureusement, dans le cadre des séquençages WES et WGS, il est impossible de connaître le "phasage" de ces variants, c'est à dire que l'on ne peut déterminer si deux variants hétérozygotes sont situés sur le même allèle ou sur deux allèles différents (**Figure : **\@ref(fig:piccompositehet)). Pour cela, une analyse familiale permettant  de suivre la ségrégation des variants est nécessaire. 

3. **Filtre 3 : Les transcrits "non pertinents"** : au cours de nos analyses, nous nous sommes concentrés uniquement sur les transcrits codants pour une protéine. Ainsi, l'ensemble des transcrits annotés comme étant non codants ont été filtrés tout comme ceux annotés comme étant NMD (*nonsense-mediated decay*). En effet, ce mécanisme a pour but de contrôler la qualité des ARNm cellulaires chez les eucaryotes [@Chang2007] en éliminant les ARNm qui comportent un codon stop prématuré [@Baker2004] pouvant être le résultat d'une erreur de transcription, d'une mutation ou encore d'une erreur d'épissage. Il est donc peu probable que les variants présents sur des transcrits annotés NMD soient responsables du phénotype. Dès lors, ces transcrits ont été également filtrés. Ainsi, l'ensemble des variants impactant **uniquement** des transcrits non codants et / ou annotés NMD sont filtrés. 

4. **Filtre 4 : Impact du variant** : afin de ne conserver que les variants ayant le plus de risque d'avoir un effet délétère sur la protéine, seuls sont conservés ceux impactant la séquence codante d'un transcrit. De plus, les variants synonymes ne sont pas conservés (excepté ceux se trouvant proches des régions d'épissage) car ceux-ci n'ont aucun effet sur la séquence protéique. Pour les variants faux-sens (changement d'un seul acide-aminé de la séquence protéique) il est plus difficile de trancher, dès lors, seuls ceux étant prédits comme *tolerated*  par SIFT [@Kumar2009] **et** comme *benign* par Polyphen [@Adzhubei2010] sont filtrés.  

5. **Filtre 5 : Fréquence des variants** :  la fréquence d'un variant dans la population générale est un moyen rapide d'avoir une prédiction fiable de l'effet délétère ou non de celui-ci. En effet, il est peu probable qu'un variant retrouvé fréquemment dans la population générale soit causal d'une pathologie sévère. C'est pourquoi, l'ensemble des variants ayant une fréquence $\ge$ `r maf_cutoff * 100`% dans l'une des trois bases de données que sont ExAC, ESP et 1KG est filtré.    

6. **Filtre 6 : Présence des variants dans la cohorte contrôle** : le filtre utilise les variants composant la base de données interne du pipeline et permet de filtrer l'intégralité des variants homozygotes retrouvés chez les patients séquencés ne présentant **pas** le même phénotype que le patient analysé. Comme dit plus tôt, ce filtre se révèle particulièrement intéressant lorsque plusieurs patients porteurs de phénotypes différents ont subi le même protocole de séquençage. Ainsi l'ensemble des variants faux-positifs résultant d'artéfacts liés aux différentes étapes en amont de l'analyse bio-informatique pourra alors être filtré. De même ce filtre permet de mettre en évidence les variants propres à une population lorsque des patients provenant de la même région géographique et ne présentant toujours pas le même phénotype sont comparés.    

```{r piccompositehet, fig.cap='(ref:piccompositehet)', fig.scap=fig_name, out.extra="scale=0.35"}

fig_name <- "Représentation schématique des phasages de deux variants avec les génotypes associés"
fig_description <- "Un variant est homozygote lorsque le **même** variant est présent sur les deux allèles d'un gène et hétérozygote lorsqu'il est présent sur **un seul** des deux allèles. On parle d'hétérozygotes *cis* lorsque deux variants hétérozygotes **différents** sont positionnés sur **le même allèle** et d'hétérozygote *trans* (ou composite) lorsque ces deux variants hétérozygotes sont positionnés sur **deux allèles différents**. En WES et en WGS il est impossible de différencier les hétérozygotes *cis* des hétérozygotes *trans*."
fig_cap <- paste0("**_",fig_name,"_** : ", fig_description)

include_graphics("figure/hetero_composites.png")

```

(ref:piccompositehet) `r fig_cap` 

\newpage

## Résultats 1 : Analyse de 3 phénotypes par des cas familiaux   

```{r dfrunfam, cache=TRUE}

run_fam_az <- c("Ghs44", "Ghs45")
run_fam_ff <- c("Ghs113", "Ghs117")

run_fam_mmaf1 <- c("Ghs56", "Ghs58")
run_fam_mmaf2 <- c("Ghs59", "Ghs60")
run_fam_mmaf3 <- c("Ghs62", "Ghs130")
run_fam_mmaf4 <- c("Ghs119", "Ghs63")
run_fam_mmaf5 <- c("Ghs131")

run_fam_mmaf_all <- c(run_fam_mmaf1, run_fam_mmaf2, run_fam_mmaf3,
                 run_fam_mmaf4, run_fam_mmaf5)

run_fam_all <- c(run_fam_az, run_fam_ff, run_fam_mmaf_all)

df_fam_run <- data_frame(FAM = c("AZ","AZ","FF","FF","MMAF1","MMAF1","MMAF2","MMAF2","MMAF3","MMAF3","MMAF4","MMAF4","MMAF5"),
                     RUN = c(run_fam_az, run_fam_ff, run_fam_mmaf_all),
                     PHENOTYPE = c(rep("Azoospermia", 2), rep("Fertilization failure", 2),  rep("MMAF", 9)),
                     YEAR = c(2012, 2012,rep(2014, 11)),
                     # PLATFORM = c("Illumina HiSeq2000", "Illumina HiSeq2000", "Illumina HiSeq2000"),
                     PLACE = c(rep("Mount Sinai Institut", 2), rep("Genoscope (Evry)", 11)))

df_fam <- df_fam_run %>% 
  group_by(FAM, PHENOTYPE, YEAR, PLACE) %>%
  summarise(RUN = paste(RUN, collapse = ", ")) %>% 
  select(FAM, RUN, PHENOTYPE, YEAR, PLACE)

df_runs_all <- fread("data/exome_runs.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, drop = c(2,4,10:16), data.table = FALSE) %>% 
    rename(RUN = `Magic ID`, PHENOTYPE = Pathologie, DATE = Date) %>%
  mutate(PHENOTYPE = if_else(PHENOTYPE == "Flag", "MMAF", PHENOTYPE)) %>% 
  filter(PHENOTYPE != "TVPC")

```

```{r varrunfam, cache=TRUE, dependson="dfrunfam"}

nb_min_indiv_per_fam <- df_fam_run %>% group_by(FAM) %>% summarise(NB_PER_FAM = n()) %>% collect() %>% .[["NB_PER_FAM"]] %>% min

nb_fam <- df_fam %>% nrow
nb_mmaf_fam <- df_fam %>% filter(grepl("MMAF", FAM)) %>% nrow

nb_pheno <- df_fam %>% ungroup() %>% summarise(N_PHENO = n_distinct(PHENOTYPE)) %>% collect() %>% .[["N_PHENO"]] 
min_year <- df_fam$YEAR %>% min
max_year <- df_fam$YEAR %>% max
nb_fam_run <- run_fam_all %>% length

nb_run_fam_mmaf <- run_fam_mmaf_all %>% length

nb_min_indiv_per_fam <- df_fam_run %>% group_by(FAM) %>% summarise(NB_PER_FAM = n()) %>% collect() %>% .[["NB_PER_FAM"]] %>% min
nb_max_indiv_per_fam <- df_fam_run %>% group_by(FAM) %>% summarise(NB_PER_FAM = n()) %>% collect() %>% .[["NB_PER_FAM"]] %>% max

nb_ctrl_ovo <- df_runs_all %>% filter(PHENOTYPE == "Ovo") %>% nrow

nb_run_fam_az <- run_fam_az %>% length

```

Cette partie se concentre sur l'analyse bio-informatique des résultats des séquençages exomiques de `r nb_fam_run` individus infertiles provenant de `r nb_fam` familles. Pour `r nb_fam - 1` familles, 2 frères atteints ont été analysés et pour la septième, un seul des frères atteint a été séquencé et l’ADN du deuxième frère a été disponible *a posteriori* \@ref(tab:tabfam).    

1. **Famille FAM** : cette famille est composée de `r nb_run_fam_az` frères azoospermes. Comme nous avons pu le voir, l'azoospermie est un phénotype d'infertilité masculine caractérisé par l'absence de spermatozoïdes dans l’éjaculat. Des `r nb_fam_run` patients de cette étude, les frères `r run_fam_az %>% paste_vector` sont les deux seuls à ne pas avoir été séquencés au Génopole d'Évry.       

2. **Famille FF** :  les spermatozoïdes des `r run_fam_ff %>% length` frères de cette famille sont caractérisés par leur incapacité à féconder l'ovocyte malgré leur morphologie et leur mobilité normales.  

3. **Famille MMAF1-5** :  ici nous avons `r nb_mmaf_fam` familles dont l'ensemble des membres séquencés présentent un phénotype MMAF (*multiple morphological abnormalities of the sperm flagella*). Ce syndrome se caractérise par la présence d'une majorité de spermatozoïdes présentant une mosaïque d'anomalies morphologiques du flagelle.   

```{r tabfam, cache=TRUE, dependson="dfrunfam"}

tab.name <- "Tableau récapitulatif des familles séquencées et de leur phénotype"

kable(df_fam,
      format = "latex",
      col.names = c("Family", "Individuals","Phenotype","Year", "Place"),
      caption = tab.name,
      longtable = TRUE,
      booktabs = TRUE) 

```

\newpage 

### Résultats des différentes étapes de l'analyse  

<!-- MAPPING -->

```{r dffammapping, dependson="dfrunfam", warning=FALSE, cache=TRUE}

df_read_fate_nb <- fread("data/magic_results/All_Exomes.read_fate.txt", sep = "\t", data.table = FALSE, header = TRUE, drop = c(1,3:5,7:23)) %>% 
    select(-contains("entropy"), -contains("but"), -contains("insert")) %>% 
  rename(RUN = `# Run`,
         `Map to 1 site` = `% reads, mapping uniquely to 1 genomic site and maximum 1 gene`,
         S2 = `% reads, mapping to 2 to 9 sites`,
         S10 = `% Rejected because they map to 10 or more`) %>% 
  filter(RUN != "All runs") %>%
  mutate(`Map to 2 or more sites`  = S2 + S10) %>% 
  select(-S2, -S10) %>% 
  filter(RUN %in% run_fam_all) %>% 
  gather(QUALITY, NB_OF_READS, `Raw reads`:`Map to 2 or more sites`)

pair_stat <- fread("data/magic_results/All_Exomes.pair_stats.txt", sep = "\t", data.table = FALSE, skip = 42, header = FALSE) %>% transpose() 
names(pair_stat) <- pair_stat[1,] 

pair_stat <- pair_stat %>%
  filter(Run %in% run_fam_all) %>% 
  select(RUN = Run, Compatible_pairs, Non_compatible_pairs, `Orphans Any`) %>% 
  rename(`Compatible` = Compatible_pairs,
         `Non compatible` = Non_compatible_pairs,
         Orphans = `Orphans Any`) %>%
  gather(QUALITY, NB_OF_READS, Compatible:Orphans) %>%
  mutate(NB_OF_READS = as.numeric(NB_OF_READS)) 

df_reads_summary <- rbind(df_read_fate_nb, pair_stat) %>% 
  mutate(IS_RETAINED = if_else((QUALITY == "Raw reads" |
                                   QUALITY == "% Well mapped" |
                                   QUALITY == "Compatible" |
                                   QUALITY == "Map to 1 site"), "Yes", "No" ),
         NB_OF_READS = if_else(QUALITY == "Raw reads", NB_OF_READS, NB_OF_READS / 100)) %>% 
  left_join(df_fam_run, by = "RUN") %>% 
  select(-(PHENOTYPE:PLACE))




```

```{r varfammapping, dependson="dffammapping", cache=TRUE}

raw_reads_median <- df_reads_summary %>% filter(QUALITY == "Raw reads") %>% collect() %>% .[["NB_OF_READS"]] %>% median %>% as.integer

unmap_reads_median <- df_reads_summary %>% filter(QUALITY == "% Well mapped") %>% collect() %>% .[["NB_OF_READS"]] %>% median %>% round(3) * 100

unmap_reads_min <- df_reads_summary %>% filter(QUALITY == "% Unmapped") %>% collect() %>% .[["NB_OF_READS"]] %>% min %>% round(3) * 100
unmap_reads_max <- df_reads_summary %>% filter(QUALITY == "% Unmapped") %>% collect() %>% .[["NB_OF_READS"]] %>% max %>% round(3) * 100

max_site_1 <- df_reads_summary %>% filter(QUALITY == "Map to 1 site") %>% collect() %>% .[["NB_OF_READS"]] %>% max %>% round(3) * 100
min_site_1 <- df_reads_summary %>% filter(QUALITY == "Map to 1 site") %>% collect() %>% .[["NB_OF_READS"]] %>% min %>% round(3) * 100
median_site_1 <- df_reads_summary %>% filter(QUALITY == "Map to 1 site") %>% collect() %>% .[["NB_OF_READS"]] %>% median %>% round(3) * 100

comp_reads_median <- df_reads_summary %>% filter(QUALITY == "Compatible") %>% collect() %>% .[["NB_OF_READS"]] %>% median %>% round(3) * 100
noncomp_reads_median <- df_reads_summary %>% filter(QUALITY == "Non compatible") %>% collect() %>% .[["NB_OF_READS"]] %>% median %>% round(3) * 100
orph_reads_median <- df_reads_summary %>% filter(QUALITY == "Orphans") %>% collect() %>% .[["NB_OF_READS"]] %>% median %>% round(3) * 100

p_retained_reads_median <- ((unmap_reads_median * median_site_1 * comp_reads_median) / 10000) %>% round(1)
nb_retained_reads_median <- ((raw_reads_median * p_retained_reads_median) / 100) %>% as.integer

```

<!-- CALL -->

```{r dfvarcall, dependson="callfunction", cache=TRUE} 

# IF I want to view the methode for all sample 
# (not only fam), replace file by a cat of all
# Genotype file 
df_fam_call <- var_call("data/call_results/call_fam.csv.gz")

df_strand_all <- df_fam_call %>%
  select(RUN, STRAND) %>% 
  group_by(RUN, STRAND) %>%
  summarise(N = n()) %>%
  group_by(RUN) %>%
  mutate(P = N / sum(N),
         IS_RETAINED = if_else(STRAND == "NS","No",
                               if_else(STRAND == "DS", "Yes", "Yes but low quality")))
     
df_concordance_all <- df_fam_call %>%
  select(RUN, CALL, STRAND) %>%
  filter(STRAND == "DS") %>% 
  mutate(CALL = if_else(grepl("zygous", CALL), "Concordant", CALL)) %>%
  group_by(RUN, CALL) %>%
  summarise(N = n()) %>%
  group_by(RUN) %>%
  mutate(P = N / sum(N),
         IS_RETAINED = if_else(CALL == "Concordant","Yes","No"))

df_geno_all <- df_fam_call %>%
  select(RUN, CALL, TYPE) %>%
  filter(grepl("zygous", CALL)) %>% 
  group_by(RUN, CALL, TYPE) %>%
  summarise(N = n()) %>% 
  group_by(RUN) %>%
  mutate(P = N / sum(N),
         IS_RETAINED = if_else(grepl("zygous", CALL),"Yes","No")) %>%
  bind_rows(data_frame(RUN = "Ghs113", CALL = "Heterozygous", TYPE = "Indel", N = 0, P = 0, IS_RETAINED = "No")) %>% # it permits to have the "no" field in the legend of the barplot
  bind_rows(data_frame(RUN = "Ghs113", CALL = "Heterozygous", TYPE = "Indel", N = 0, P = 0, IS_RETAINED = "Yes but low quality")) 

df_count_geno <- fread("~/count_geno_all_chr.csv", data.table = FALSE, header = TRUE) %>% 
  filter(CALL != "*") %>% filter(CALL == "0") %>%
  mutate(STRAND = call_to_strand(CALL),
         GENO = call_to_geno(CALL)) %>% 
  group_by(MIN_COV, GENO, PATIENT) %>% 
  summarise(COUNT = sum(COUNT)) %>% 
  group_by(MIN_COV, GENO) %>% 
  summarise(COUNT = median(COUNT))

df_count_concordant <- fread("~/count_geno_all_chr.csv", data.table = FALSE, header = TRUE) %>% 
  mutate(GENO = call_to_geno(CALL),
         GENO = if_else(GENO == "Discordant","Discordant",
                        if_else(GENO == "Ambigous", "Ambigous", "Concordant")),
         CALL = call_to_strand(CALL)) %>% 
  filter(CALL == "DS") %>% 
  group_by(MIN_COV, GENO, PATIENT) %>% 
  summarise(COUNT = sum(COUNT)) %>%  
  group_by(MIN_COV, GENO) %>% 
  summarise(COUNT = median(COUNT)) %>%  
  group_by(MIN_COV) %>% 
  mutate(SUM = sum(COUNT)) %>%
  group_by(MIN_COV, GENO) %>% 
  summarise(PERCENT = COUNT / SUM)

df_count_strand <- fread("~/count_geno_all_chr.csv", data.table = FALSE, header = TRUE) %>% 
  filter(CALL  != "*") %>% 
  mutate(STRAND = call_to_strand(CALL),
         GENO = call_to_geno(CALL)) %>% 
  group_by(PATIENT, MIN_COV, STRAND) %>% 
  summarise(COUNT = sum(COUNT)) %>% 
  group_by(MIN_COV, STRAND) %>% 
  summarise(COUNT = median(COUNT)) %>% 
  group_by(MIN_COV) %>%
  mutate(PERCENT = COUNT / sum(COUNT)) 
  
# df_count_geno <- fread("~/count_geno_all_chr.csv", data.table = FALSE, header = TRUE) %>% 
#   mutate(STRAND = call_to_strand(CALL),
#          GENO = call_to_geno(CALL)) %>% 
#   group_by(PATIENT, MIN_COV, GENO) %>% 
#   summarise(COUNT = sum(COUNT)) %>% 
#   group_by(MIN_COV, GENO) %>% 
#   summarise(COUNT = median(COUNT)) %>% 
#   group_by(MIN_COV) %>% 
#   mutate(PERCENT = COUNT / sum(COUNT))

# df_estimate_error_rate <- df_count_geno %>% 
#   filter(CALL == "SS")

# df_count_concordant <- fread("~/count_geno_all_chr.csv", data.table = FALSE, header = TRUE) %>% 
#   filter(CALL != "*") %>% 
#   mutate(GENO = call_to_geno(CALL), 
#          GENO = if_else(GENO == "Discordant","Discordant",
#                         if_else(GENO == "Ambigous", "Ambigous", "Concordant")),
#          STRAND = call_to_strand(CALL)) %>% 
#   filter(STRAND == "DS") %>% 
#   group_by(MIN_COV, GENO, PATIENT) %>% 
#   summarise(COUNT = sum(COUNT)) %>%  
#   group_by(MIN_COV, GENO) %>% 
#   summarise(COUNT = median(COUNT)) %>% 
#   group_by(MIN_COV) %>% 
#   mutate(SUM = sum(COUNT)) %>%
#   group_by(MIN_COV, GENO) %>% 
#   summarise(PERCENT = COUNT / SUM) %>% filter(MIN_COV == 10) %>% View

# 
# df_estimate_error_rate <- df_count_geno %>% 
#   filter(CALL == "SS") %>%
#   left_join(df_count_concordant, by = "MIN_COV") %>% 
#   filter(GENO == "Discordant") %>% 
#   group_by(MIN_COV) %>%
#   summarise(ERROR_RATE = PERCENT.x * PERCENT.y *.5)


```

```{r varvarcall, cache=TRUE, dependson="dfvarcall"}

median_percent_ss <- df_strand_all %>% filter(STRAND == "SS") %>% collect() %>% .[["P"]] %>% median %>% round(3) * 100 
median_percent_ds <- df_strand_all %>% filter(STRAND == "DS") %>% collect() %>% .[["P"]] %>% median %>% round(3) * 100 

min_percent_ns <- df_strand_all %>% filter(STRAND == "NS") %>% collect() %>% .[["P"]] %>% min %>% round(3) * 100
max_percent_ns <- df_strand_all %>% filter(STRAND == "NS") %>% collect() %>% .[["P"]] %>% max %>% round(3) * 100


concordant_median <- df_concordance_all %>% ungroup() %>% filter(CALL == "Concordant") %>% collect() %>% .[["P"]] %>% median %>% round(3) * 100
discordant_median <- df_concordance_all %>% ungroup() %>% filter(CALL == "Discordant") %>% collect() %>% .[["P"]] %>% median %>% round(3) * 100

wrong_ds_median <- 100 - concordant_median

median_het_snv <- df_geno_all %>% filter(TYPE == "SNV" & CALL == "Heterozygous") %>% collect() %>% .[["N"]] %>% median %>% as.integer
median_het_indel <- df_geno_all %>% filter(TYPE == "Indel" & CALL == "Heterozygous") %>% collect() %>% .[["N"]] %>% median %>% as.integer

median_homo_snv <- df_geno_all %>% filter(TYPE == "SNV" & CALL == "Homozygous") %>% collect() %>% .[["N"]] %>% median %>% as.integer
median_homo_indel <- df_geno_all %>% filter(TYPE == "Indel" & CALL == "Homozygous") %>% collect() %>% .[["N"]] %>% median %>% as.integer

p_concordant_1 <- df_count_concordant %>% filter(MIN_COV == 1, GENO == "Concordant") %>% collect() %>% .[["PERCENT"]] %>% round(3) *100  
p_concordant_100 <- df_count_concordant %>% filter(MIN_COV == 100, GENO == "Concordant") %>% collect() %>% .[["PERCENT"]] %>% round(3) *100  
                                                                                       


```

<!-- CALL COMPARAISON -->

```{r dfcallcomp, dependson="callfunction", cache=TRUE}

our_call_df <- fread("data/comparaison/all_call_our_pipeline.csv", data.table = FALSE, header = TRUE) %>% 
  gather(RUN, OUR_GENO, starts_with("Ghs"))  %>%
  mutate(OUR_GENO = call_to_geno(OUR_GENO)) %>% 
  filter(!(OUR_GENO %in% c("Reference", "None")))

evry_call_files <- list.files("data/comparaison/", pattern = "Ghs", full.names = TRUE)

compare_df <- foreach(evry_file = evry_call_files, .combine='rbind') %do% {

    tmp <- sub(".*//", "", evry_file) 
    run <- sub("_.*", "", tmp)

    fread(evry_file, data.table = FALSE, header = TRUE) %>% filter(CHR %in% c(1:22)) %>% mutate(REF = as.character(REF),
                                                                                                ALT = as.character(ALT),
                                                                                                CHR = as.integer(CHR)) %>% 
      rename(EVRY_GENO = GENOTYPE) %>%
      full_join(our_call_df %>% 
                  filter(RUN == run), 
                by = c("CHR", "POSITION", "REF", "ALT")) %>% 
      replace_na(list(OUR_GENO = "Not called", 
                      EVRY_GENO = "Not called")) %>%
      group_by(OUR_GENO, EVRY_GENO) %>%
      summarise(Run = run,
                Count = n())
} %>% group_by(OUR_GENO, EVRY_GENO) %>% 
  summarise(Count = median(Count)) %>%
  ungroup() %>% 
  filter(EVRY_GENO != "Het comp.") %>%
  mutate(Percent = Count / sum(Count),
         OUR_GENO = if_else(OUR_GENO == "*", "NS", OUR_GENO))

compare_count_df <- compare_df %>% 
  rename(`Magic + in-house algo` = OUR_GENO, `BWA + GATK-HC` = EVRY_GENO) %>% 
  gather(Who, Genotype, `Magic + in-house algo`:`BWA + GATK-HC`) %>% 
  filter(grepl("zygous", Genotype)) %>% 
  group_by(Who) %>%
  summarise(Count = sum(Count))

disc_amb_df <- compare_df %>% 
  filter(OUR_GENO %in% c("Discordant", "Ambigous", "NS"), 
         EVRY_GENO != "Not called")

not_called_comp_df <- compare_df %>%
  filter(OUR_GENO == "Not called" | EVRY_GENO == "Not called",
         grepl("zygous|called", OUR_GENO)) %>% 
  rename(`Magic + in-house algo` = OUR_GENO, `BWA + GATK-HC` = EVRY_GENO) %>% 
  gather(Who, Genotype, `Magic + in-house algo`:`BWA + GATK-HC`) %>% 
  filter(Genotype != "Not called") 

called_comp <- compare_df %>% 
  filter(grepl("zygous", OUR_GENO), EVRY_GENO != "Not called") %>% 
  mutate(Percent = (Count / sum(Count) * 100) %>% round(2)) %>% arrange(desc(Count)) %>% 
  rename(`Magic + in-house algo` = OUR_GENO, `BWA + GATK-HC` = EVRY_GENO)

```

```{r varcallcomp, dependson="dfcallcomp", cache=TRUE}

percent_concordance <- called_comp %>% mutate(Concordant = `Magic + in-house algo` == `BWA + GATK-HC`) %>% 
  group_by(Concordant) %>%
  mutate(Percent_concordancy = sum(Percent)) %>% distinct(Percent_concordancy) %>%
  filter(Concordant == TRUE) %>% collect() %>% .[["Percent_concordancy"]]

nb_evry <- compare_count_df %>% 
  filter(Who == "BWA + GATK-HC") %>%
  collect() %>% .[["Count"]]

nb_us <- compare_count_df %>% 
  filter(Who == "Magic + in-house algo") %>%
  collect() %>% .[["Count"]]

nb_disc_evry <- disc_amb_df %>% 
  group_by(OUR_GENO) %>% 
  summarise(Count = sum(Count)) %>% 
  filter(OUR_GENO == "Discordant") %>% 
  collect() %>% .[["Count"]]

nb_ambigous_evry <- disc_amb_df %>% 
  group_by(OUR_GENO) %>% 
  summarise(Count = sum(Count)) %>% 
  filter(OUR_GENO == "Ambigous") %>% 
  collect() %>% .[["Count"]]

nb_ns_evry <- disc_amb_df %>% 
  group_by(OUR_GENO) %>% 
  summarise(Count = sum(Count)) %>% 
  filter(OUR_GENO == "NS") %>% 
  collect() %>% .[["Count"]]


p_disc_amb_evry <- (((nb_disc_evry + nb_ambigous_evry + nb_ns_evry) / (nb_evry - nb_us)) * 100) %>% round(1)


```

<!-- ANNOTATION -->

```{r dfannotation, cache=TRUE} 

annotate_file <- "results/annotate_variants.rds"
nb_feature_file <- "results/annotation_nb_feature.rds"
nb_impact_geno_file <- "results/annotation_impact_geno.rds"

if (!file.exists(annotate_file)) {
  
  df_annotate2 <- fread("~/all_chr_var.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE) %>%
    mutate(PolyPhen = gsub("_", " ", str_extract(PolyPhen, "\\w+")),
           SIFT = gsub("_", " ", str_extract(SIFT, "\\w+")),
           Consequence = sapply(strsplit(Consequence, "_variant", fixed = TRUE),"[[",1),
           Consequence = gsub("_", " ", Consequence),
           HGVSc = sapply(strsplit(HGVSc, split=':', fixed=TRUE), function(x) (x[2])),
           HGVSp = sapply(strsplit(HGVSp, split=':', fixed=TRUE), function(x) (x[2])))
  
  df_annotate <- df_fam_call %>%
    left_join(df_fam_run %>% select(RUN, FAM), by = "RUN") %>% 
    mutate(CHR = as.character(CHR)) %>%
    filter(grepl("zygous", CALL)) %>% 
    select(-STRAND) %>%
    left_join(df_annotate2, by = c("CHR", "POSITION", "REF", "ALT")) %>% 
    mutate(PHENO = if_else(FAM == "AZ","Azoo",
                           if_else(FAM == "FF", "Fert_fail", "MMAF"))) %>% 
    group_by(RUN) %>% 
    mutate(N_VAR_PER_RUN = n_distinct(CHR,POSITION,REF,ALT)) 
  
  saveRDS(df_annotate, annotate_file)
  
} else {
  
  df_annotate <- readRDS(annotate_file)
  
}

if (!file.exists(nb_feature_file)) {

df_nb_feature <- df_annotate %>%
  group_by(RUN) %>%
  summarise(TRANSCRIPT = n_distinct(Feature),
            GENE = n_distinct(SYMBOL)) %>%
  gather(FEATURE, NB, TRANSCRIPT:GENE) 

  saveRDS(df_nb_feature, nb_feature_file)


} else {
  
    df_nb_feature <- readRDS(nb_feature_file)

}

if (!file.exists(nb_impact_geno_file)) {


df_impact <- df_annotate %>% 
  filter(CANONICAL == "YES") %>% 
  group_by(RUN,CALL, IMPACT) %>%
  summarise(N = n()) %>%
  group_by(RUN) %>%
  mutate(P = N / sum(N))

  saveRDS(df_impact, nb_impact_geno_file)
  
} else {
  
      df_impact <- readRDS(nb_impact_geno_file)
}

```

```{r cleancall, include=FALSE, message=FALSE, warning=FALSE}

rm(df_fam_call)
gc()

```

```{r varannotation, cache=TRUE, dependson="dfannotation"}

p_modifier_median <- df_impact %>% group_by(RUN,IMPACT) %>% summarise(N_IMPACT = sum(N)) %>% group_by(RUN) %>% mutate(P_IMPACT = (N_IMPACT / sum(N_IMPACT) * 100)) %>% filter(IMPACT == "MODIFIER") %>% collect() %>% .[["P_IMPACT"]] %>% median %>% as.integer


mean_transcript <- df_nb_feature %>% ungroup() %>% filter(FEATURE == "TRANSCRIPT") %>% summarise(MEAN = mean(NB)) %>% collect() %>% .[["MEAN"]] %>% round(0)
mean_gene <- df_nb_feature  %>% filter(FEATURE == "GENE") %>% collect() %>% .[["NB"]] %>% mean %>% round(0) %>% as.integer
mean_transcript <- df_nb_feature  %>% filter(FEATURE == "TRANSCRIPT") %>% collect() %>% .[["NB"]] %>% mean %>% round(0) %>% as.integer
rate_tr_gene = (mean_transcript / mean_gene) %>% round(0)

mean_percent_high <- df_impact %>% filter(IMPACT == "HIGH") %>% group_by(RUN) %>% summarise(SP = sum(P)) %>% collect() %>% .[["SP"]] %>% mean %>% round(4) * 100
mean_nb_het_high <- df_impact %>% filter(IMPACT == "HIGH" & CALL == "Heterozygous") %>% group_by(RUN) %>% summarise(SN = sum(N)) %>% collect() %>% .[["SN"]] %>% mean %>% round(0) 
mean_nb_homo_high <- df_impact %>% filter(IMPACT == "HIGH" & CALL == "Homozygous") %>% group_by(RUN) %>% summarise(SN = sum(N)) %>% collect() %>% .[["SN"]] %>% mean %>% round(0) 

```

```{r dffreqvar, cache=TRUE, dependson="dfannotation"}

df_freq <- df_annotate %>%
  group_by(RUN, ExAC_AF, `1KG`, ESP) %>% 
  distinct(CHR,POSITION,REF,ALT, N_VAR_PER_RUN) %>% 
  group_by(RUN) %>%
  rename(ExAC = ExAC_AF) %>%
  gather(DB,FREQ,ExAC:ESP)

df_freq2 <- df_freq %>%
  filter(!is.na(FREQ)) %>%
  group_by(DB) %>% 
  distinct(CHR,POSITION,REF,ALT,FREQ) %>% 
  select(-(CHR:ALT)) 

df_freq_stat <- df_freq %>%
  select(-(CHR:ALT)) %>% 
  group_by(RUN, DB) %>% 
  summarise(N_VAR_PER_RUN = mean(N_VAR_PER_RUN),
            N_PER_RUN_PER_DB = N_VAR_PER_RUN - sum(is.na(FREQ)),
            P_PER_RUN_PER_DB = N_PER_RUN_PER_DB / N_VAR_PER_RUN)

```

```{r varfreqvar, cache=TRUE, dependson="dffreqvar"}

min_percent_exac <- df_freq_stat %>% filter(DB == "ExAC") %>% collect() %>% .[["P_PER_RUN_PER_DB"]] %>% min %>% median %>% round(3) * 100
max_percent_exac <- df_freq_stat %>% filter(DB == "ExAC") %>% collect() %>% .[["P_PER_RUN_PER_DB"]] %>% max %>% median %>% round(3) * 100
min_percent_esp <- df_freq_stat %>% filter(DB == "ESP") %>% collect() %>% .[["P_PER_RUN_PER_DB"]] %>% min %>% median %>% round(3) * 100
max_percent_esp <- df_freq_stat %>% filter(DB == "ESP") %>% collect() %>% .[["P_PER_RUN_PER_DB"]] %>% max %>% median %>% round(3) * 100
median_percent_1kg <- df_freq_stat %>% filter(DB == "1KG") %>% collect() %>% .[["P_PER_RUN_PER_DB"]] %>% median %>% round(3) * 100

```

<!-- FILTER -->

```{r ctrldata, include=FALSE, cache=TRUE}

ctrl_file <- "results/all_ctrl.rds"
sample_ctrl_file <- "results/sample_ctrl.rds" 

if(!file.exists(ctrl_file)) {

  df_ctrl_az <- open_ctrl("data/genotype_not_azoo.csv", pheno = "Azoo")
  df_ctrl_ff <- open_ctrl("data/genotype_not_fert_fail.csv", pheno = "Fert_fail")
  df_ctrl_mmaf <- open_ctrl("data/genotype_not_MMAF.csv", pheno = "MMAF")
  
  nb_ctrl_az <-df_ctrl_az %>% collect() %>% .[["N_CTRL"]] %>% mean 
  nb_ctrl_ff <-df_ctrl_ff %>% collect() %>% .[["N_CTRL"]] %>% mean 
  nb_ctrl_mmaf <-df_ctrl_mmaf %>% collect() %>% .[["N_CTRL"]] %>% mean 
  
  fam_lab <- c("Az", "FF", "MMAF1", "MMAF2", "MMAF3", "MMAF4")
  
  nb_ctrl <- c(nb_ctrl_az,
               nb_ctrl_ff,
               nb_ctrl_mmaf,
               nb_ctrl_mmaf,
               nb_ctrl_mmaf,
               nb_ctrl_mmaf)
  
  df_sample_ctrl <- data_frame(FAM = fam_lab,
                               NB = nb_ctrl)
  
  df_ctrl_all <- rbind(df_ctrl_az,
                       df_ctrl_ff,
                       df_ctrl_mmaf)
  
  saveRDS(df_ctrl_all,ctrl_file)
  saveRDS(df_sample_ctrl,sample_ctrl_file)
  
  rm(df_ctrl_az, df_ctrl_ff, df_ctrl_mmaf)
  gc()
  
} else {
  
  df_ctrl_all <- readRDS(ctrl_file)
  df_sample_ctrl <- readRDS(sample_ctrl_file)
}


df_nb_ctrl <- bind_rows(df_runs_all %>% 
                          filter(!(PHENOTYPE %in% c("Azoo", "Ovo"))) %>% 
                          mutate(N = n_distinct(RUN)) %>% 
                          group_by(PHENOTYPE) %>% 
                          summarise(N_PHENO = n_distinct(RUN)) %>% 
                          mutate(SUB = "AZ"),
                        df_runs_all %>% 
                          filter(PHENOTYPE != "Fert_fail") %>% 
                          mutate(N = n_distinct(RUN)) %>% 
                          group_by(PHENOTYPE) %>% 
                          summarise(N_PHENO = n_distinct(RUN)) %>% 
                          mutate(SUB = "FF"),
                        df_runs_all %>% 
                          filter(PHENOTYPE != "MMAF") %>% 
                          mutate(N = n_distinct(RUN)) %>% 
                          group_by(PHENOTYPE) %>% 
                          summarise(N_PHENO = n_distinct(RUN)) %>% 
                          mutate(SUB = "MMAF1-5"))

```

```{r dffilterfam, dependson="dfannotation", cache=TRUE}

maf_cutoff <- .01

df_filter_fam <- ungroup(df_annotate) %>% 
  filter_genotype(het = FALSE) %>% 
  filter_frequence(cutoff = maf_cutoff) %>%
  variant_join(df_ctrl_all %>% mutate(CHR = as.character(CHR)), add_by = "PHENO", mode = "anti") %>% 
  filter(Consequence != "synonymous",
         IMPACT != "MODIFIER",
         !(grepl("tolerated", SIFT) & grepl("benign", PolyPhen)),
         !grepl("NMD transcript variant",Consequence),
         !grepl("non coding transcript", Consequence)) %>%
  group_by(FAM) %>%
  mutate(NB_FAM = n_distinct(RUN)) %>% 
  group_by(CHR, POSITION, REF, ALT, FAM, Feature) %>% 
  filter(n() == mean(NB_FAM),
         SYMBOL != "JMJD7-PLA2G4B") # pseudogene pourri de MMAF1

```

```{r dffilterfamnmd, dependson="dfannotation", include=FALSE, warning=FALSE, cache=TRUE}

df_tmp <- ungroup(df_annotate) %>%
  select(CHR, POSITION, REF, ALT, RUN, Feature, Consequence) %>%
  mutate(IS_FILTERED = grepl("NMD transcript", Consequence) | grepl("non coding transcript", Consequence)) %>%
  select(-Consequence) %>%
  group_by(RUN, IS_FILTERED) %>%
  mutate(N_TRANSCRIT_PER_ISNMD = n_distinct(Feature))

df_filtered_tr <- df_tmp %>%
  summarise(N = n_distinct(Feature),
            TYPE = "Transcript")  

df_filtered_tr_vr <- df_tmp %>%
  group_by(CHR, POSITION, REF, ALT, RUN) %>% 
  mutate(IS_FILTERED = if_else(n_distinct(IS_FILTERED) == 1 & IS_FILTERED == TRUE, TRUE, FALSE)) %>%
  group_by(RUN, IS_FILTERED) %>%
  summarise(N = n_distinct(CHR,POSITION,REF,ALT),
            TYPE = "Variants") %>% 
  bind_rows(df_filtered_tr)


rm(df_tmp)
gc()

```

```{r varfilterfamnmd, cache=TRUE, dependson="dffilterfamnmd"}

max_tr <- ungroup(df_filtered_tr_vr) %>% filter(TYPE == "Transcript" & IS_FILTERED == TRUE) %>% collect() %>% .[["N"]] %>% max
min_tr <- ungroup(df_filtered_tr_vr) %>% filter(TYPE == "Transcript" & IS_FILTERED == TRUE) %>% collect() %>% .[["N"]] %>% min
mean_variant <- ungroup(df_filtered_tr_vr) %>% filter(TYPE == "Variants" & IS_FILTERED == TRUE) %>% collect() %>% .[["N"]] %>% mean %>% round(0)

```

```{r dfcomparefilters, include=FALSE, cache=TRUE}

filter_file <- "results/filter.rds"
filter_spe_file <- "results/filter_spe.rds"

if (!file.exists(filter_file) | 
    !file.exists(filter_spe_file)) {

df_filtered_by_geno <- df_annotate %>% 
  filter_genotype(homo = FALSE) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN) %>%
  mutate(FILTER = "Genotype", 
         N_FILTERED = n_distinct(CHR,POSITION,REF,ALT),
         P_FILTERED = N_FILTERED / N_VAR_PER_RUN)

df_filtered_by_freq <- df_annotate %>%
  filter(!is.na(ExAC_AF) & ExAC_AF >= maf_cutoff,
         !is.na(ESP) & ESP >= maf_cutoff,
         !is.na(`1KG`) & `1KG` >= maf_cutoff) %>%
  mutate(FILTER = "Frequence", 
         N_FILTERED = n_distinct(CHR,POSITION,REF,ALT),
         P_FILTERED = N_FILTERED / N_VAR_PER_RUN)
  
df_fitered_by_impact <- df_annotate %>% 
  group_by(RUN) %>% 
  mutate(IS_FILTERED = if_else(Consequence != "synonymous_variant" &
                               IMPACT != "MODIFIER" &
                               (!(grepl("tolerated", SIFT) & grepl("benign", PolyPhen))), FALSE, TRUE)) %>%
  distinct(CHR, POSITION, REF, ALT, IS_FILTERED, N_VAR_PER_RUN) %>%
  group_by(CHR, POSITION, REF, ALT, RUN) %>% 
  mutate(N = n()) %>%
  filter(N == 1,
         IS_FILTERED == TRUE) %>%
  group_by(RUN) %>% 
  mutate(FILTER = "Variant impact", 
         N_FILTERED = n(),
         P_FILTERED = N_FILTERED / N_VAR_PER_RUN)

df_filtered_by_union <- df_annotate %>% 
  distinct(CHR, POSITION, REF, ALT, FAM, N_VAR_PER_RUN) %>% 
  group_by(FAM) %>%
  mutate(NB_FAM = n_distinct(RUN)) %>%
  group_by(CHR, POSITION, REF, ALT, FAM) %>% 
  filter(n() < NB_FAM) %>% 
  group_by(RUN) %>%
  mutate(FILTER = "Union", 
         N_FILTERED = n_distinct(CHR,POSITION,REF,ALT),
         P_FILTERED = N_FILTERED / N_VAR_PER_RUN)

df_fitered_by_transcript <- df_annotate %>%
  mutate(IS_FILTERED = if_else(grepl("NMD_transcript_variant", Consequence) | grepl("non_coding_transcript_variant", Consequence), TRUE, FALSE)) %>% 
    distinct(CHR, POSITION, REF, ALT, IS_FILTERED, N_VAR_PER_RUN) %>%
  group_by(CHR, POSITION, REF, ALT, RUN) %>% 
  mutate(N = n()) %>%
  filter(N == 1,
         IS_FILTERED == TRUE) %>%
  group_by(RUN) %>% 
  mutate(FILTER = "Transcript relevance", 
         N_FILTERED = n(),
         P_FILTERED = N_FILTERED / N_VAR_PER_RUN)
  
df_filter_ctrl <- df_annotate %>% 
  variant_join(df_ctrl_all, add_by = "PHENO", mode = "inner") %>%
  mutate(FILTER = "Ctrl", 
            N_FILTERED = n_distinct(CHR,POSITION,REF,ALT),
            P_FILTERED = N_FILTERED / N_VAR_PER_RUN)


resume_filter <- function(df) {
  
  df %>% group_by(RUN, FILTER) %>% select(RUN, FILTER, N_FILTERED, P_FILTERED) %>% summarise(N = mean(N_FILTERED), P = mean(P_FILTERED))
  
}

filter_stat <- rbind(resume_filter(df_filtered_by_geno),
                     resume_filter(df_filtered_by_freq),
                     resume_filter(df_fitered_by_impact),
                     resume_filter(df_filtered_by_union),
                     resume_filter(df_filter_ctrl),
                     resume_filter(df_fitered_by_transcript))

saveRDS(filter_stat, filter_file)

} else {
  filter_stat <- readRDS(filter_file)
}


```

```{r varcomparefilters, cache=TRUE, dependson="dfcomparefilters"}

nb_filter_union_min <- filter_stat %>% filter(FILTER == "Union") %>% collect() %>% .[["N"]] %>% min %>% as.integer
nb_filter_union_max <- filter_stat %>% filter(FILTER == "Union") %>% collect() %>% .[["N"]] %>% max %>% as.integer

nb_filter_genotype_mean <- filter_stat %>% filter(FILTER == "Genotype") %>% collect() %>% .[["N"]] %>% mean %>% round(0) %>% as.integer
p_filter_genotype_mean <- filter_stat %>% filter(FILTER == "Genotype") %>% collect() %>% .[["P"]] %>% mean %>% round(3) * 100

p_filter_impact_median <- filter_stat %>% filter(FILTER == "Variant impact") %>% collect() %>% .[["P"]] %>% median %>% round(3) * 100

nb_filter_freq_max <- filter_stat %>% filter(FILTER == "Frequence") %>% collect() %>% .[["N"]] %>% max %>% as.integer
nb_filter_freq_min <- filter_stat %>% filter(FILTER == "Frequence") %>% collect() %>% .[["N"]] %>% min %>% as.integer

```

```{r filterspe, cache=TRUE}


if (!file.exists(filter_spe_file)) {

spe_geno <- df_filtered_by_geno %>% 
  group_by(RUN) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN, FILTER, N_FILTERED, P_FILTERED) %>% 
  variant_join(df_filtered_by_freq, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_fitered_by_impact, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_filtered_by_union, add_by = "RUN", mode = "anti") %>%
  variant_join(df_filter_ctrl, add_by = "RUN", mode = "anti") %>%
  variant_join(df_fitered_by_transcript, add_by = "RUN", mode = "anti") 

spe_freq <- df_filtered_by_freq %>% 
  group_by(RUN) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN, FILTER, N_FILTERED, P_FILTERED) %>% 
  variant_join(df_filtered_by_geno, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_fitered_by_impact, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_filtered_by_union, add_by = "RUN", mode = "anti") %>%
  variant_join(df_filter_ctrl, add_by = "RUN", mode = "anti") %>%
  variant_join(df_fitered_by_transcript, add_by = "RUN", mode = "anti") 

spe_impact <- df_fitered_by_impact %>% 
  group_by(RUN) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN, FILTER, N_FILTERED, P_FILTERED) %>% 
  variant_join(df_filtered_by_freq, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_filtered_by_geno, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_filtered_by_union, add_by = "RUN", mode = "anti") %>%
  variant_join(df_filter_ctrl, add_by = "RUN", mode = "anti") %>%
  variant_join(df_fitered_by_transcript, add_by = "RUN", mode = "anti") 

spe_union <- df_filtered_by_union %>% 
  group_by(RUN) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN, FILTER, N_FILTERED, P_FILTERED) %>% 
  variant_join(df_filtered_by_freq, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_fitered_by_impact, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_filtered_by_geno, add_by = "RUN", mode = "anti") %>%
  variant_join(df_filter_ctrl, add_by = "RUN", mode = "anti") %>%
  variant_join(df_fitered_by_transcript, add_by = "RUN", mode = "anti") 

spe_ctrl <- df_filter_ctrl %>% 
  group_by(RUN) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN, FILTER, N_FILTERED, P_FILTERED) %>% 
  variant_join(df_filtered_by_freq, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_fitered_by_impact, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_filtered_by_union, add_by = "RUN", mode = "anti") %>%
  variant_join(df_filtered_by_geno, add_by = "RUN", mode = "anti") %>%
  variant_join(df_fitered_by_transcript, add_by = "RUN", mode = "anti") 

spe_tr <- df_fitered_by_transcript %>% 
  group_by(RUN) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN, FILTER, N_FILTERED, P_FILTERED) %>% 
  variant_join(df_filtered_by_freq, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_fitered_by_impact, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_filtered_by_union, add_by = "RUN", mode = "anti") %>%
  variant_join(df_filter_ctrl, add_by = "RUN", mode = "anti") %>%
  variant_join(df_filtered_by_geno, add_by = "RUN", mode = "anti") 

spe_all <- rbind(spe_geno,
                 spe_freq,
                 spe_impact,
                 spe_union,
                 spe_ctrl,
                 spe_tr) %>% 
  group_by(RUN, FILTER) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN, N_FILTERED, P_FILTERED) %>% 
  summarise(N_FILTERED_SPE = n_distinct(CHR, POSITION, REF, ALT),
            P_FILTERED_SPE = N_FILTERED_SPE / mean(N_VAR_PER_RUN))

saveRDS(spe_all, spe_filter_file)

} else {
  spe_all <- readRDS(filter_spe_file)
}


```

```{r dependson=c("dfcomparefilters", "filterspe"), cache=TRUE}

mean_filter_tr <- filter_stat %>% filter(FILTER == "Transcript relevance") %>% collect() %>% .[["P"]] %>% mean %>% round(3) * 100
max_filter_impact <- filter_stat %>% filter(FILTER == "Variant impact") %>% collect() %>% .[["P"]] %>% max %>% round(3) * 100
min_filter_ctrl <- filter_stat %>% filter(FILTER == "Ctrl") %>% collect() %>% .[["P"]] %>% min %>% round(3) * 100
max_filter_ctrl <- filter_stat %>% filter(FILTER == "Ctrl") %>% collect() %>% .[["P"]] %>% max %>% round(3) * 100

mean_filter_spe_impact <- spe_all %>% filter(FILTER == "Variant impact") %>% collect() %>% .[["N_FILTERED_SPE"]] %>% mean %>% round(0) 
mean_filter_spe_geno <- spe_all %>% filter(FILTER == "Genotype") %>% collect() %>% .[["N_FILTERED_SPE"]] %>% mean %>% round(0) 
mean_filter_spe_ctrl <- spe_all %>% filter(FILTER == "Ctrl") %>% collect() %>% .[["N_FILTERED_SPE"]] %>% mean %>% round(0) 
max_filter_spe_ctrl <- spe_all %>% filter(FILTER == "Ctrl") %>% collect() %>% .[["N_FILTERED_SPE"]] %>% max
min_filter_spe_ctrl <- spe_all %>% filter(FILTER == "Ctrl") %>% collect() %>% .[["N_FILTERED_SPE"]] %>% min

max_filter_spe_other <- spe_all %>% filter(FILTER == "Transcript relevance" | FILTER == "Union" | FILTER ==  "Frequence") %>% collect() %>% .[["N_FILTERED_SPE"]] %>% max

```

```{r remaininggense, cache=TRUE, dependson="dffilterfam"}

df_remaining_gene <- df_filter_fam %>% 
  group_by(FAM) %>%
  mutate(SIFT = gsub("_", " ", str_extract(SIFT, "\\w+")),
         SIFT = if_else(grepl("low confidence", SIFT), 
                        str_split(SIFT, "low confidence")[[1]],
                        SIFT)) %>% 
  filter(CANONICAL == "YES") %>%
  mutate(CAUSAL = if_else(FAM == "AZ", "SPINK2", 
                          if_else(FAM == "FF","PLCZ1",
                                  if_else(FAM == "MMAF3","DNAH1", 
                                          if_else(FAM == "MMAF5", "SPEF2?", "???")))),
         FIND_CAUSAL = if_else(CAUSAL == "???","No",
                               if_else(grepl("[?]", perl = TRUE, CAUSAL),"Maybe","Yes"))) %>%
  rename(Family = FAM) %>% 
  
  mutate(HGVSc = if_else(CHR == "3" & POSITION == 52420175 & REF == "G" & ALT == "A", "c.8626-1G > A", HGVSc)) %>% # DNAH1 HGVSc mutation
  
  
  filter(!(SYMBOL %in% c("NBPF13P","HLA-DRB6","JMJD7-PLA2G4B"))) 


df_causal <- group_by(df_remaining_gene, Family, FIND_CAUSAL, CAUSAL) %>%
  summarise(N = n())

n_gene_az <- df_remaining_gene %>% filter(Family == "AZ") %>% distinct(SYMBOL) %>% nrow
n_gene_ff <- df_remaining_gene %>% filter(Family == "FF") %>% distinct(SYMBOL) %>% nrow
n_gene_mmaf3 <- df_remaining_gene %>% filter(Family == "MMAF3") %>% distinct(SYMBOL) %>% nrow

```

#### Résultat de l'alignement  

Pour rappel, l'[alignement](#lalignement) consiste à repositionner l'ensemble des *reads* générés au cours de l'étape de séquençage le long d'un génome de référence. 

La quantité de *reads* composant les exomes de chaque individu peut varier en fonction de plusieurs paramètres et n'est donc pas égale pour chaque patient bien que l'ordre de grandeur reste le même avec une médiane de `r raw_reads_median` *reads*. Seuls les deux frères `r run_fam_az %>% paste_vector("itallic")` de la famille AZ se distinguent avec près de 3 fois plus de *reads* que les autres patients. Cette différence peut être expliquée car ces deux patients sont les deux seuls à voir été séquencés au Mount Sinaï Institut. Or leur protocole d'amplification précédant le séquençage contient un nombre de cycles de PCR supérieur à ceux appliqués au Génopole d'Évry où ont été séquencés les autres patients. Il faut noter que ce nombre plus important de *reads* n'est en rien le reflet d'une meilleure qualité. En effet, celui-ci est causé par une grande quantité de *reads* dupliqués qui seront pour la plupart filtrés au cours des analyses ultérieures (**Table :**  \@ref(tab:tabfam), **Figure : **\@ref(fig:plotfammapping) - **A**).  

La première étape du contrôle qualité des *reads* consiste à filtrer ceux ne s'étant pas alignés sur le génome. Ces *reads* sont extrêmement minoritaires puisqu'ils ne représentent qu'entre `r unmap_reads_min` et `r unmap_reads_max` % des *reads* de nos individus (**Figure : **\@ref(fig:plotfammapping) - **B**).  

Parmi les *reads* s'étant correctement alignés sur le génome, seuls les *reads* présentant des *ends* compatibles sont conservés Pour rappel, ces *reads* représentent ceux pour lesquels une des deux *ends* s'est alignée sur le *strand forward* tandis que l'autre s'est alignée sur le *strand reverse* et que la distance qui les sépare n'est pas supérieure à trois fois celle de l'insert. Dans nos données, les *reads* remplissant ces conditions sont majoritaires puisqu'ils représentent environ `r comp_reads_median` % des *reads* s'étant correctement alignés tandis que les *reads* non-compatibles et orphelins représentent respectivement `r noncomp_reads_median` et `r orph_reads_median` % de ces même *reads* (**Figure : **\@ref(fig:plotfammapping) - **C**).  

La dernière étape de ce contrôle-qualité consiste à analyser le nombre de sites sur lesquels se sont alignés les *reads*. En effet, certaines zones du génome étant dupliquées, l'une des problématiques des *short-reads* est qu'il est possible que ceux-ci s'alignent à plusieurs régions différentes du génome. Afin d'éviter toute ambiguïté, seuls ceux s'étant alignés sur un site unique sont conservés pour la suite des analyses. Ces *reads* représentent entre `r min_site_1` et `r max_site_1` % des *reads* ayant passé les précédents filtres (**Figure : **\@ref(fig:plotfammapping) - **D**).  

Ainsi, à la fin de ces trois étapes de contrôle qualité des *reads*, environ `r p_retained_reads_median` % d'entre eux sont conservés soit un total d'environ `r nb_retained_reads_median` *reads* par patients.  

\newpage 

```{r plotfammapping, dependson="varfammapping", fig.cap='(ref:plotfammapping)', fig.scap='(ref:plotfammappingtitle)',fig.width=6.3, fig.height=6.9, cache=TRUE}

fig_name <- "Processus simplifié du contrôle qualité des *reads*"
fig_description_all <- "Pour chacun des graphiques, les *reads* représentés en vert sont conservés tandis que ceux en rouge sont filtrés"
fig_description_A <- "**A** : Quantité de *reads* bruts générés pour chaque patient au cours de l'étape de séquençage. La médiane des *reads* est représentée en bleue"
fig_description_B <- "**B** : Pourcentage, pour chaque individu, de *reads* s'étant alignés correctement et ne s'étant pas alignés sur le génome de référence"
fig_description_C <- "**C** : Distribution pour chaque patient des *reads* compatibles (Comp), non compatibles (Non comp) et orphelins (Orphans)"
fig_description_D <- "**D** : Présentation pour chaque *reads* du nombre de sites auxquels ils s'alignent"
fig_description <- paste(fig_description_all, fig_description_A,fig_description_B,fig_description_C, fig_description_D, sep = ". ")

fig_cap <- paste0("**_",fig_name,"_** : ", fig_description)

pA <- ggplot(df_reads_summary %>% filter(QUALITY == "Raw reads"), aes(RUN, NB_OF_READS)) + 
  geom_bar(stat = "identity", aes(fill = IS_RETAINED)) +
  scale_x_discrete(limits = run_fam_all) + 
  # facet_wrap(~FAM, scales = "free_x") +
  xlab("") + 
  ylab("Nb of raw reads") + 
  scale_fill_manual(values = c("chartreuse3", "#E41A1C"), guide = "none") +
  geom_hline(col = "blue", aes(yintercept = raw_reads_median)) + 
  geom_text(data=data.frame(x=0,y=median(df_reads_summary$NB_OF_READS)), col = "blue", x = 12.5, y = 110000000, label = raw_reads_median) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))

pB <- ggplot(df_reads_summary %>% 
               filter(QUALITY == "% Well mapped" | 
                        QUALITY == "% Unmapped"), aes(QUALITY, NB_OF_READS)) + 
  geom_boxplot(outlier.size = -1, aes(fill = IS_RETAINED)) + 
  geom_jitter(position=position_jitter(0.3)) +
  facet_wrap(~factor(QUALITY, levels = c("% Well mapped", "% Unmapped")), scales = "free", nrow = 1) + 
  ylab("% of reads") +
  scale_y_continuous(labels = percent) + 
  xlab("") + 
  scale_fill_manual(values = c("#E41A1C", "chartreuse3"), guide = "none") + 
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

pC <- ggplot(df_reads_summary %>% 
         filter(QUALITY == "Compatible" | 
                  QUALITY == "Non compatible" |
                  QUALITY == "Orphans") %>%
           mutate(QUALITY = if_else(QUALITY == "Compatible", "Comp",
                                    if_else(QUALITY == "Non compatible", "Non comp", QUALITY))), aes(QUALITY, NB_OF_READS)) + 
         geom_boxplot(outlier.size = -1, aes(fill = IS_RETAINED)) + 
         geom_jitter(position=position_jitter(0.3)) +
  facet_wrap(~QUALITY, scales = "free", nrow = 1) + 
  ylab("% of reads") +
  scale_y_continuous(labels = percent) + 
  xlab("") + 
  scale_fill_manual(values = c("#E41A1C", "chartreuse3"), guide = "none") + 
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y = element_blank())

pD <- ggplot(df_reads_summary %>% 
               filter(QUALITY == "Map to 1 site" | 
                        QUALITY == "Map to 2 or more sites"), aes(QUALITY, NB_OF_READS)) + 
  geom_boxplot(outlier.size = -1, aes(fill = IS_RETAINED)) + 
  geom_jitter(position=position_jitter(0.3)) +
  facet_wrap(~QUALITY, scales = "free", nrow = 1) + 
  scale_fill_manual(name = "Retained read ?", values = c("#E41A1C", "chartreuse3")) +
  ylab("% of reads") +
  xlab("") + 
  scale_y_continuous(labels = percent) + 
  theme(axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        legend.position="bottom") +
  coord_flip()


row1 <- plot_grid(pA, labels = c("A"))
row2 <- plot_grid(pB,pC, ncol = 2,labels = c("B","C"))

plot_grid(row1,row2, pD, ncol = 1, labels = c("","","D"), rel_heights = c(1,.7,.7, .7))

```

(ref:plotfammappingtitle) `r fig_name`  
(ref:plotfammapping) `r fig_cap` 

\newpage

#### L'appel des variants  

Une fois l'alignement effectué, il faut identifier les positions présentant des différences avec le génome de référence et leur assigner un génotype. Tout d'abord, afin de conserver uniquement les positions auxquels il sera possible d'effectuer un appels de qualité, il est nécessaire de filtrer les positions ne présentant pas une couverture suffisante. Pour cela, nous avons fait varié notre critère de filtre de couverture minimum de 1 à 100 afin. Ainsi, nous avons pu quatifié, pour chacune des valeurs de filtre, la quantité d'appels DS, SS et NS  d'observerla quantité de position.  

On peut ainsi constater qu'à partir de 10, la quantité d'appel NS augmente considérablement, tandis que le nombre d'appel DS et SS chute. Ainsi, au-delà ce cette valeur, un nombre important de positions ne respectent plus les critère qualité et sont ainsi filtrées (**Figure : **\@ref(fig:plotcountgeno)).  
<!-- De même, on peut constater que parmis les appels DS, cette valeur n'influe que très peu sur le pourcentage d'appel concordant, ambigus et discordant. En effet, les appels concordant passent de `r p_concordant_1` avec une couverture minimum de 1 à `r p_concordant_100` avec une couverture minimum de 100 par *strand* (**Figure : **\@ref(fig:plotcountgeno) - **B**).   -->

Ensuite, le génotype étant dépendant du pourcentage de *reads* variants à une position donnée, il est nécessaire, afin de calibrer les bornes de notre algorithme d'appel, de connaître la répartition globale de ces proportions. Comme attendu, nous observons des pics à 0, 50 et 100% de *reads* variants pour une position donnée, ces trois pourcentages correspondant respectivement aux appels "homozygote référence", "hétérozygote" et "homozygote variant". La démarcation séparant les appels hétérozygote et homozygote variant est relativement claire. La distinction de ces deux génotypes ne pose donc pas de problème, la région d'ambiguïté allant de 75 à 85% de *reads* variants ne concernant qu'une minorité de positions. Ce n'est cependant pas le cas pour celle séparant les appels homozygote référence et hétérozygote. En effet, on peut constater que la zone d'ambiguïté allant de 20 à 40% de *reads* variants concerne une part non négligeable des positions couvertes. Les positions SS situées dans cette région seront systématiquement filtrées. Pour les positions DS, celles pour lesquelles **un seul** des *strand* se situe dans cette région alors que l'autre se trouve dans une des régions adjacentes (homozygote référence ou hétérozygote) seront conservées. Les autres seront filtrées elles aussi (**Figure : **\@ref(fig:plotdensityvar)). 
  
Dans nos données, les appels SS sont majoritaires et représentent environ `r median_percent_ss` % de nos appels (contre `r median_percent_ds` % d'appels DS). Au vu de l'importance de ces appels, nous avons fait le choix de les conserver afin de ne pas filtrer une quantité trop importante de données. Ces appels seront cependant considérés comme étant de faible qualité, de fait, leurs analyses et interprétation seront plus précautionneuses. En revanche, au vu de la trop grande incertitude de l'appel des variants NS, ceux-ci sont systématiquement filtrés éliminant ainsi entre `r min_percent_ns` et `r max_percent_ns` % des positions appelées pour chaque patient (**Figure : **\@ref(fig:plotvarcall) - **A**).  

De même, les appels discordant et ambigus sont filtrés, soit environ `r wrong_ds_median` % des variants DS. Il est intéressant de noter que bien que les variants *single strand* (SS) soient conservés, on peut s'attendre à ce qu'environ `r discordant_median`%, soit le pourcentage de DS discordants, soient aberrants, ceux-ci n'ayant pu subir le même contrôle que les SS (**Figure : **\@ref(fig:plotvarcall) - **B**).

Pour l'ensemble des variants ayant passé les filtres énoncés ci-dessus, c'est à dire les variants SS et les variants DS avec appels concordants, le génotype est déterminé en fonction du pourcentage de *reads* portant le variant à cette position. Ainsi, pour chaque individu nous avons pu établir une liste de SNVs et d'indels avec leur génotype associé. Pour chacun de nos `r nb_fam_run` patients, les ordres de grandeur du nombre de variants appelés sont identiques. Ainsi pour chaque patient nous avons appelé environ `r median_het_snv + median_het_indel` variants hétérozygotes (`r median_het_snv` SNVs et `r median_het_indel` indels) et `r median_homo_snv + median_homo_indel` variants homozygotes (`r median_homo_snv` SNVs et `r median_homo_indel` indels) (**Figure : **\@ref(fig:plotvarcall) - **C**).    
```{r plotcountgeno,dependson="dfvarcall", fig.cap='(ref:plotcountgeno)',fig.scap='(ref:plotcountgenotitle)', fig.height=5.5, warning=FALSE}

fig_name <- "Détermination de la valeur de couverture minimale"

fig_description <- "Quantification du nombre médian d'appels DS, SS et NS pour chaque valeur de couverture minimum testée. On note une augmentation du nombre d'appel NS à partir de 10 tandis qu'à partir de cette même valeur les appels DS et SS diminuent"

# fig_description_B <- "**B** : Quantification, parmi les appels DS, du pourcentage médian d'appel discordant et ambigu. Pour chaque valeur de couverture minimum, le pourcentage d'appel concordant (non représenté) peux être déterminé ainsi : 100 - (%Ambigu + %Discordant). Pour les deux graphique, la ligne verticale noire pointe la valeur de couverture minimale 10 séléctionnée pour la suite des analyses."
# fig_description <- paste(fig_description_A,fig_description_B, sep = ". ")
fig_cap <- paste0("**_",fig_name,"_** : ", fig_description)

pA <- ggplot(df_count_strand , aes(MIN_COV, COUNT, col = STRAND)) + 
  geom_point() +
  geom_line() +
  geom_vline(xintercept = 10) +
  scale_color_manual(name = "Call stranding", limits = c("DS", "SS","NS"), values = c("chartreuse3", "#FF7F00", "#E41A1C")) +
  scale_x_continuous(breaks = seq(0,100,10)) +
  xlab("Minimum coverage filter") +
  ylab("Nb of position")

pA

# pB <- ggplot(df_count_concordant %>% filter(GENO != "Concordant"), aes(MIN_COV, PERCENT, col = GENO)) +
#   geom_point() +
#   geom_line() +
#   geom_vline(xintercept = 10) +
#   # scale_color_manual(name = "Call match", values = c("Darkgrey", "#E41A1C")) +
#   scale_x_continuous(breaks = seq(0,100,10)) +
#   scale_y_continuous(labels = scales::percent) +
#   ylab("Percent of call") +
#   xlab("Minimum coverage filter")


# plot_grid(pA, pB,labels = c("A", "B"), ncol = 1)

# ggplot(df_estimate_error_rate) + geom_line(aes(MIN_COV, ERROR_RATE)) 


```

(ref:plotcountgenotitle) `r fig_name`   
(ref:plotcountgeno) `r fig_cap` 

\newpage

```{r plotdensityvar,fig.cap='(ref:plotdensityvar)',fig.scap='(ref:plotdensityvartitle)', out.extra="scale=0.95"}

xmin <- .07
ymax <- 7.2

fig_name <- "Densité de répartition du pourcentage de *reads* variants pour chaque position couverte"
fig_description_B <- paste0("Les homozygotes références évidents ne nous intéressant pas, les positions représentées sont restreintes à celles contenant un minimum de ", xmin *100, "\\% de *reads* variants. L'arrière-plan montre les bornes utilisées par notre algorithme pour chaque appel. Les lignes pointillées séparent en deux les régions d'ambiguïté basse et haute.")

fig_cap <- paste0("**_",fig_name,"_** : ", fig_description)

density_plot_file <- "figure/density_plot.png"


if (!file.exists(density_plot_file)) {
  
  
my_geno <- c("Homozygous ref", "Ambigous", "Heterozygous", "Ambigous", "Homozygous var")


df_geno <- data_frame(GENO = factor(my_geno, levels = c("Homozygous ref", "Ambigous", "Heterozygous", "Homozygous var")),
                      XMIN = c(0,.2,.4,.75, .85),
                      XMAX = c(.2, .4, .75, .85, 1))

fread("zcat ~/countsForHisto_PR_all.csv.gz", sep = ",", header = TRUE, showProgress = FALSE, data.table = FALSE, verbose = FALSE) %>%
  filter(coverage >= 10) %>%
  mutate(P_var = variant_reads/coverage) %>%
  filter(P_var > 0) %>%
  select(P_var) %>% 
  ggplot() +
  geom_density(adjust = 1.8, aes(P_var)) +
  coord_cartesian(xlim = c(xmin,1), ylim = c(0, ymax)) +
  geom_rect(data = df_geno, mapping = aes(xmin = XMIN, xmax = XMAX, fill = GENO), ymin = 0, ymax = ymax, alpha=0.6) +
  scale_x_continuous(labels = percent, breaks = c(xmin, .2, .4, .5, .75, .85, 1)) +
  scale_fill_manual(name = "Genotype", values = c("chartreuse3", "grey", "#FF7F00","#E41A1C")) +
  geom_vline(xintercept = c(.3,.8), linetype = "dashed") +
  xlab("% of variant reads")

  ggsave(density_plot_file, dpi = 1000)

}

include_graphics(path = density_plot_file)

```

(ref:plotdensityvartitle) `r fig_name`   
(ref:plotdensityvar) `r fig_cap` 

\newpage

```{r plotvarcall, dependson="dfvarcall", fig.cap='(ref:plotvarcall)',fig.scap=fig_name, fig.height=7.5, cache=TRUE}

fig_name <- "Contrôle qualité des variants appelés"
fig_description_all <- "Pour chacun des graphiques, les variants représentés en vert et en orange sont conservés tandis que ceux en rouge sont filtrés"
fig_description_A <- "**A** : Distribution du *stranding* des appels pour chaque patient"
fig_description_B <- "**B** : Comparaison des appels entre les deux *ends* des variants appelés DS"
fig_description_C <- "**C** : Distribution des SNVs et indels en fonction de leur génotype pour chaque patient (représentés par une barre)."
fig_description <- paste(fig_description_all, fig_description_A,fig_description_B,fig_description_C, sep = ". ")
fig_cap <- paste0("**_",fig_name,"_** : ", fig_description)

pA <- ggplot(df_strand_all, aes(STRAND, P)) +
  geom_boxplot(outlier.size = -1, aes(fill = IS_RETAINED)) + 
  geom_jitter(size = 2, position=position_jitter(0.3)) +
  ylab("% of called variant") +
  xlab("") +
    facet_wrap(~factor(STRAND, levels = c("DS", "SS", "NS")), scales = "free") +
  scale_fill_manual(guide = "none", values = c("#E41A1C", "chartreuse3", "#FF7F00")) +
  scale_y_continuous(labels = percent) + 
  theme(axis.title.x = element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

pB <- ggplot(df_concordance_all, aes(CALL, P)) +
  geom_boxplot(aes(fill = IS_RETAINED), outlier.size = -1) + 
  geom_jitter(size = 2, position=position_jitter(0.3)) +
  ylab("% of called variant") +
  xlab("") +
  facet_wrap(~factor(CALL, levels = c("Concordant", "Ambigous", "Discordant")), scales = "free") +
  scale_fill_manual(guide = "none", values = c("#E41A1C", "chartreuse3")) + 
  scale_y_continuous(labels = percent) + 
  theme(axis.title.x = element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

pC <- ggplot(df_geno_all,aes(RUN, N)) + 
  geom_bar(stat = "identity", aes(fill = IS_RETAINED)) +
  facet_grid(TYPE~CALL, scales = "free") +
  ylab("Nb of variant") + 
  scale_fill_manual(name = "Is the variant retained?", values = c("#E41A1C", "chartreuse3", "#FF7F00"), breaks = c("Yes","Yes but low quality", "No")) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1),
          axis.title.x = element_blank(),
          legend.position = "bottom")

row1 <- plot_grid(pA,pB, labels = c("A","B"), ncol = 1)
plot_grid(row1, pC,labels = c("", "C"), rel_heights = c(.52,.48), ncol = 1)

```

(ref:plotvarcall) `r fig_cap` 

\newpage

Nous avons ensuite cherché à comparer les résultats obtenus par notre pipeline avec ceux obtenus par des legiciels déjà existant. Pour cela nous avons aligné les données de nos `r nb_fam_run` patients avec le logiciel BWA [@Li2009a] et effectué l'appel à l'aide de GATK-HC [@McKenna2010]. Ainsi, nous avons pu constater que `r nb_us` variants étaient appelés par notre pipeline avec un génotype hétérozygote ou homozygote tandis que `r nb_evry` était appelés par BWA + GATK-HC parmis soit `r nb_evry - nb_us` de plus que par notre pipeline (**Figure : **\@ref(fig:plotcompar) - **A**).  

Cette différence n'est pas surprenante puisque, afin de ne séléctionner que les variants de confiance nous avons appliqué des critères de filtre stringent. On peut ainsi noté que parmis ces `r nb_evry - nb_us` variants, `r nb_disc_evry` d'entre-eux sont retrouvés comme discordant par notre pipeline, `r nb_ambigous_evry` sont retrouvés comme ambigus et `r nb_ns_evry` comme NS. Ainsi, on peut estimer que `r p_disc_amb_evry`% des variants que nous n'avons pas appelés sont appelés par BWA + GATK-HC avec un génotype soit erroné soit de faible confiance (**Figure : **\@ref(fig:plotcompar) - **B**).  

Néanmoins, en ce qui concèrne les variants retrouvés à la fois par le duo BWA + GATK-HC et notre pipeline, `r percent_concordance`% des appels sont identiques aux deux procédures. (**Table : **\@ref(tab:tabcallcomp)).  

```{r tabcallcomp, cache=TRUE, dependson="dfcallcomp"}

caption <- "Comparaison des génotypes des variants appelés par les deux procédures"

kable(called_comp,
      format = "latex",
        booktabs = TRUE,
        longtable = TRUE,
        caption = caption)

```

\newpage

```{r plotcompar, cache=TRUE, dependson="dfcallcomp", fig.cap='(ref:plotcompar)',fig.scap=fig_name, fig.width= 6.3, fig.height=7.5}

fig_name <- "Comparaison des variants obtenus par MAGIC + notre algorithme d'appel et BWA + GATK-HC"
fig_description_A <- "**A** : Nombre de variants hétérozygotes ou homozygotes observé par les deux méthodes"
fig_description_B <- "**B** : Quantification du nombre de variant appelés discordants, ambigous ou NS par notre méthode retrouvés par BWA + GATK-HC"
# fig_description_C <- "**C** : "
fig_description <- paste(fig_description_A,fig_description_B, sep = ". ")
fig_cap <- paste0("**_",fig_name,"_** : ", fig_description)

pA <- ggplot(compare_count_df, aes(Who, Count)) + 
  geom_col() +
  ylab("Nb of variant") + 
  xlab("")

pB <- ggplot(disc_amb_df, aes(EVRY_GENO, Count, fill = EVRY_GENO)) +
  geom_col() +
  facet_wrap(~OUR_GENO) +
  scale_fill_brewer(palette = "Set1", guide = "none") +
  ylab("Nb of variant") + 
  xlab("")

# pC <- ggplot(not_called_comp_df, aes(Genotype, Count, fill = Genotype)) +
#   geom_col() +
#   facet_wrap(~Who) + 
#   ylab("Nb of not called") +
#   scale_fill_brewer(palette = "Set1", guide = "none")
# 
# 
# pC
plot_grid(pA, pB, ncol = 1, labels = c("A","B"))

```

(ref:plotcompar) `r fig_cap` 

\newpage

#### L'annotation des variants

Après avoir annoté nos variants, nous avons pu constater que pour chaque patient `r mean_gene` gènes sont en moyenne affectés par au moins un variant homozygote pour en moyenne `r mean_transcript` transcrits (soit environ `r rate_tr_gene` transcrits par gène) (**Figure : **\@ref(fig:plotannotation) - **A**). Il faut noter que parmi ces gènes se trouvent à la fois des gènes codants pour des protéines **et** d'autres non codants.     

Chaque variant affectera l'ensemble des transcrits qu'il chevauche, ainsi un même variant pourra impacter plusieurs transcrits. Ces impacts sont ensuite classés par VEP en quatre catégories qui sont, de la plus délétère à la moins délétère : *HIGH*, *MODERATE*, *LOW*, *MODIFIER* (**Table : **\@ref(tab:tabvepcsq)).  

Comme attendu, les variants ayant un impact tronquant se retrouvent être les moins fréquents chez chacun de nos patients. Ceci est d'autant plus flagrant pour l'impact *HIGH* qui regroupe, entre autres, les variants créant un codon stop ou causant un décalage du cadre de lecture (**Table : **\@ref(tab:tabvepcsq)). Ceux-ci se retrouvent, par rapport aux autres impacts, en quantité extrêmement faible puisqu'ils ne représentent en moyenne que `r mean_percent_high` % des variants. Cependant, bien que ce pourcentage soit faible, cela représente tout de même une moyenne de `r mean_nb_het_high` variants *HIGH* hétérozygotes par patients et `r mean_nb_homo_high` variants *HIGH* homozygotes par patient (**Figure : **\@ref(fig:plotannotation) - **B**).  

<!-- Parmi ces variants, certains étaient déjà recensés dans une des trois base donnée (ExAC, ESP et 1KG). Ainsi, on peut observer qu'entre `r min_percent_exac` et `r max_percent_exac` % de nos variant étaient listés dans ExAC et entre `r min_percent_esp` et `r max_percent_esp` % dans ESP. En revanche environ `r median_percent_1kg` % d'entre eux sont recensés dans 1KG (**Figure : **\@ref(fig:plotvarannotation) - **C**) (À discuter !!!!!).   -->

<!-- (À discuter !!!!!) (**Figure : **\@ref(fig:plotvarannotation) - **D**) -->

<!-- LES FIGURES SUR LA FRÉQUENCE SONT À DISCUTER CAR LEUR INTERPRÉTATION ME LAISSE PERPLEX (SURTOUT LA PROPORTION DE NOS VARIANTS PRÉSENTS DANS 1KG) -->

\newpage

```{r plotannotation, dependson=c("dfvarannotation","dffreqvar"), fig.cap='(ref:plotannotation)',fig.scap=fig_name,fig.width=6.5, fig.height=7, cache=TRUE}

fig_name <- "Annotation des variants"
fig_description_A <- "**A** : Quantification du nombre de gènes (en bleu) / transcrits (en rose) impactés par au moins un variant pour chaque patient chacun représenté par une barre"
fig_description_B <- "**B** : Distribution des impacts *HIGH MODERATE LOW* et *MODIFIER* en fonction des patients et du statut du variant."
fig_description_C <- "**C** : Pourcentage des variants retrouvés au sein des trois bases de données : ExAC, ESP et 1KG"
fig_description_D <- "**D** : Distribution des fréquences de nos variants au sein des trois bases de données : ExAC, ESP et 1KG"

fig_description <- paste(fig_description_A,fig_description_B, sep = ". ")
fig_cap <- paste0("**_",fig_name,"_** : ", fig_description)

pA <- ggplot(df_nb_feature, aes(RUN, NB)) + 
  geom_bar(stat = "identity", position = position_nudge(),  aes(fill = FEATURE)) + 
  xlab("") + 
  ylab("Nb of feature impacted") + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_fill_brewer(palette = "Set1", name = "Feature", labels = c("Gene", "Transcript")) 

pB <- ggplot(df_impact, aes("", P)) +
  geom_boxplot(aes(fill = CALL), alpha = .3, outlier.size = -1) + 
  geom_jitter(aes(col = CALL), size = 1, position = position_jitterdodge(0.2)) +
  facet_wrap(~factor(IMPACT, levels = c("HIGH", "MODERATE", "LOW", "MODIFIER")), scales = "free", nrow = 1) +
  scale_y_continuous(labels = percent_format()) + 
  scale_color_brewer(palette = "Set1", name = "Call") +
  scale_fill_brewer(palette = "Set1", name = "Call") + 
  theme(axis.title = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

# pC <- ggplot(df_freq_stat, aes("", P_PER_RUN_PER_DB)) + 
#   geom_boxplot(outlier.size = -1, aes(fill = DB)) + 
#   geom_jitter(size = 1, position = position_jitter(0.2)) +
#   facet_wrap(~DB, scales = "free") + 
#   ylab("% of variant found within a DB") + 
#   xlab("") +
#   scale_x_discrete(labels = c("1KG","ESP6500","ExAC")) +
#   scale_y_continuous(labels = percent) +
#    scale_fill_brewer(palette = "Set1", guide = "none") +
#   theme(axis.text.x = element_blank(),
#         axis.ticks.x = element_blank())
#         
# pD <- ggplot(df_freq2, aes(FREQ)) + 
#   geom_line(aes(col = DB), stat = "bin", bins = 150) +
#    scale_color_brewer(palette = "Set1", name = "Data base", labels = c("1KG","ESP6500","ExAC")) + 
#   xlab("Variant frequency") +
#   ylab("Nb of variants") + 
#   scale_x_continuous(labels = percent)

# row1 <- plot_grid(pA, pB, labels = c("A","B"), ncol = 1)
# row2 <- plot_grid(pC, pD, labels = c("C","D"), ncol = 2)
# 
# plot_grid(row1,row2, ncol = 1, labels = c("","",""), rel_heights = c(1,.5))
plot_grid(pA, pB, labels = c("A","B"), ncol = 1)

```

(ref:plotannotation) `r fig_cap` 

```{r cleanfreq, include=FALSE, warning=FALSE}

rm(df_freq, df_freq2, df_freq_stat)
gc()

```

#### Le filtrage des variants  

Les étapes précédentes nous ont permis de mettre en évidence pour chaque patient une liste de variants passant l'ensemble de nos critères qualité. Ces variants ont dès lors pu être annotés nous permettant notamment d'avoir connaissance de leurs impacts sur les différents transcrits qu'ils chevauchent ou encore leur fréquence dans la population générale. Désormais, afin de ne conserver que les variants ayant la plus forte probabilité d'être responsable du phénotype de ces patients, nous avons appliqué successivement les six filtres précédemment décrits.

1. **Filtre 1 : L'union des variants** : dans cette étude nous analysons les données génétiques de `r nb_fam` familles composées de `r nb_min_indiv_per_fam` à `r nb_max_indiv_per_fam` frères. Nous avons donc émis l'hypothèse que **le phénotype de chacun des frères d'une même famille était dû à une cause génétique commune**. C'est pourquoi, seul les variants observés chez l'ensemble des membres d'une même famille furent conservés. Ainsi ce filtre a permis de filtrer entre `r nb_filter_union_min` et `r nb_filter_union_max` variants pour chacun des patients (**Figure : **\@ref(fig:plotcomparefilter) - **A**).     

2. **Filtre 2 : Génotype des variants** :  ici, nous avons émis l'hypothèse d'une transmission récessive du phénotype. Ainsi, seuls les variants homozygotes ont été conservés, filtrant en moyenne `r nb_filter_genotype_mean` variant par individu soit une moyenne de `r p_filter_genotype_mean`% de leurs variants (**Figures : **\@ref(fig:plotvarcall) - **C**, \@ref(fig:plotcomparefilter) - **A**).     

3. **Filtre 3 : Impact du variant** : ce filtre se basant à la fois sur les prédictions VEP mais aussi, dans le cas de variants faux-sens, sur les prédictions SIFT et PolyPhen permet de ne conserver que les variants ayant les effets les plus délétères. Ce filtre est, de prime abord, le plus efficace puisqu'il permet de filtrer à lui seul environs `r p_filter_impact_median`% des variants de chaque individu.  

4. **Filtre 4 : Les transcrits "non pertinents"** : cette étape de filtre permet de filtrer systématiquement entre `r min_tr` et `r max_tr` transcrits différents par patients. Sont considérés comme non-pertinents les transcrits ne codant pas pour une protéine et ceux annotés étant dégradés (*nonsense mediated decay* (NMD)). Cependant, un même variant pouvant impacter à la fois des transcrits "non pertinents" **et** des transcrits "pertinents", seuls ceux impactant **uniquement** des transcrits "non pertinents" sont filtrés, soit une moyenne de `r mean_variant` variants par individu (**Figure : **\@ref(fig:plotfilternonpertinanttr)).    

\newpage 

```{r plotfilternonpertinanttr, fig.cap='(ref:plotfilternonpertinanttr)',fig.scap=fig_name,fig.width=6.3, fig.height=3.2, cache=TRUE}

fig_name <- "Filtrage des transcrits jugés \"non pertinents\" et des variants les chevauchant"
fig_description <- "Pour chaque patient nous avons filtré les transcrits jugés \"non pertinents\" pour l'analyse, c'est à dire ceux ne codant pas pour une protéine et ceux annoté NMD (boite rouge). Dès lors, l'intégralité des variants chevauchant **uniquement** des transcrits non pertinents sont systématiquement filtrés (boites bleue). Les autres sont conservés."
fig_cap <- paste0("**_",fig_name,"_** : ", fig_description)

ggplot(df_filtered_tr_vr %>% filter(IS_FILTERED == TRUE), aes(TYPE, N)) +
  geom_boxplot(aes(fill = TYPE), alpha = .3, outlier.size = -1) +
  geom_jitter(aes(col = TYPE), size = 2, position=position_jitter(0.3)) +
  scale_color_brewer(guide = "none", palette = "Set1") +
  scale_fill_brewer(guide = "none", palette = "Set1") + 
  facet_wrap(~TYPE, scales = "free") +
  ylab("Nb of transcripts / variants") +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

```

(ref:plotfilternonpertinanttr) `r fig_cap` 

5. **Filtre 5 : Fréquence des variants :**  filtrer systématiquement les variants retrouvés avec une fréquence $\ge$ `r maf_cutoff` dans l'une des trois bases de données que sont ExAC, 1KG et ESP6500 permet de filtrer entre `r nb_filter_freq_min` et `r nb_filter_freq_max` variants par patient.    

6. **Filtre 6 : Présence des variants dans la cohorte contrôle :** L'ensemble des variants répertoriés au sein de ces `r nb_pheno` phénotypes a été confronté à des listes de variants identifiés chez d'autres patients analysés par notre pipeline et présentant des phénotypes différents. Dès lors, l'ensemble des variants retrouvés à l'état homozygote chez au moins un des individus de la cohorte contrôle sera filtré de notre liste de variants. On peut cependant noter que les variants retrouvés chez les patients `r run_fam_az %>% paste_vector("itallic")` de la famille AZ n'ont pas été confrontés à ceux observés dans notre cohorte de `r nb_ctrl_ovo` femmes présentant des anomalies de développement ovocytaire. En effet, ces deux phénotypes peuvent être causés par un même gène impliqué dans la division méiotique (**Figure :** \@ref(fig:plotsamplectrl)).  
\newpage

```{r plotsamplectrl, fig.cap='(ref:plotsamplectrl)',fig.scap=fig_name, fig.height=4, cache=TRUE}
     
fig_name <- "Nombre d'individus et leur phénotypes composant la cohorte contrôle de chaque famille"
fig_description <- "Ici, chaque barre représente une famille et sa hauteur est déterminée par le nombre d'individus composant la cohorte contrôle à laquelle elle a été confrontée. Le nombre total de contrôles utilisés par famille est inscrit au-dessus de chaque barre. Les couleurs déterminent les phénotypes des individus de la cohorte contrôle. Chaque individu de cette cohorte a été séquencé en WES par notre équipe. Afin d'être considéré comme \"contrôle\" et intégrer cette cohorte, un individu doit être sain ou présenter un phénotype d'infertilité suffisamment différent de la famille étudiée. Par exemple, un individus MMAF pourra servir de contrôle aux familles AZ et FF mais pas aux familles MMAF1-5."
fig_cap <- paste0("**_",fig_name,"_** : ", fig_description)
                         
ggplot(df_nb_ctrl, aes(SUB, N_PHENO)) + 
  geom_col(aes(fill = PHENOTYPE)) + 
  scale_fill_brewer(palette = "Set1", 
                    name = "Phenotypes",
                    labels = c("Azoospermia", "Healthy", "Fertilization failure", 
                               "Globozoospermia", "Macrozoocspermia", "MMAF", 
                               "Oocyte defect")) + 
  scale_y_continuous(breaks = seq(0,140,10)) + 
  ylab("Nb of control individuals") + 
  xlab("") + 
  geom_text(data = df_nb_ctrl %>% group_by(SUB) %>% summarise(NTOT = sum(N_PHENO)),
            aes(x = SUB, y = NTOT, label = NTOT), vjust = -.25)

```

(ref:plotsamplectrl) `r fig_cap`

\newpage

Comme on pouvait s'y attendre, ces six filtres ont un pouvoir discriminant extrêmement différent. En effet, tandis que le filtre "*Transcript relevance*" (filtre n°4) élimine en moyenne `r mean_filter_tr`% des variants de chaque individu, le filtre "Variant impact" (filtre n° 3) élimine, lui, jusqu'à `r max_filter_impact`% de ces mêmes variants. Cette différence n'est pas surprenante. En effet, comme nous l'avions vu plus tôt, les variants considérés comme *MODIFIER* par VEP qui regroupent entre autres les variants chevauchant les séquences UTRs et introniques (**Table :** \@ref(tab:tabvepcsq)) représentent en moyenne `r p_modifier_median`% des variants de nos patients, or, ceux-ci sont tous filtrés. On peut également constater l'importance de la cohorte contrôle puisqu'elle permet retirer entre `r min_filter_ctrl` et `r max_filter_ctrl`% des variants de chaque individu (**Figure :** \@ref(fig:plotcomparefilter) - **A**).      

Cependant, regarder uniquement le pourcentage de variants filtrés par chaque filtre révèle une information partielle. En effet, dans ce cas de figure, on observe la quantité de variant éliminée par chaque filtre indépendamment les uns des autres. Ainsi, un même variant peut donc être filtré par plusieurs filtres. Dès lors, il faut également analyser la quantité de variants filtrée **spécifiquement** par chaque filtre. Ainsi, on peut constater que le classement des filtres en fonctions de leur stringence reste quasiment identique. Il est tout de même intéressant de noter que désormais le filtre "Variant impact" apparait moins efficace que les filtres "Ctrl" et "Genotype" en filtrant spécifiquement une moyenne de `r mean_filter_spe_impact` variants par individu contre `r mean_filter_spe_geno` pour le filtre génotype et `r mean_filter_spe_ctrl` pour le filtre "Ctrl". Ainsi, ce dernier devient celui filtrant spécifiquement le plus de variants avec entre `r min_filter_spe_ctrl` et `r max_filter_spe_ctrl` variants spécifiquement filtrés par patients confirmant ainsi l'importance de ce filtre dans nos analyses. Aussi, les filtres "Transcript relevance", "Union" et "Frequency" apparaissent désormais comme étant anecdotiques en comparaison des trois autres filtres puisqu'ils filtrent au maximum `r max_filter_spe_other` variants spécifiques (**Figure :** \@ref(fig:plotcomparefilter) - **B**).  

Après avoir appliqué l'ensemble de ces filtres, seuls quelques variants subsistent, nous permettant d'obtenir une liste de restreinte gènes pour chaque famille et ainsi de tirer des conclusions quant au(x) variant(s) responsable(s) du phénotype de chacune d'entre elles. Ces travaux ont ainsi pu mener à l'écriture de trois articles dont je suis co-auteur.    

\newpage

```{r plotcomparefilter, fig.cap='(ref:plotcomparefilter)',fig.scap=fig_name, fig.height=7, cache=TRUE}

fig_name <- "Comparaison de l'efficacité de chacun des six filtres utilisés"
fig_description_A <- "**A** : Comparaison du pourcentage de variants filtrés par chacun des six filtres indépendamment les uns des autres pour chaque patient (représenté par les points). Dès lors, un même variant peut-être filtré par plusieurs filtres"
fig_description_B <- "**B** : Comparaison du nombre de variants filtrés spécifiquement par chacun des filtres. Ici, un variant ne peut-être filtré que par un seul filtre."
fig_description <- paste(fig_description_A, fig_description_B, sep = ". ")
fig_cap <- paste0("**_",fig_name,"_** : ", fig_description)

filter_orders <- c("Transcript relevance","Union","Frequence","Genotype","Ctrl","Variant impact")

pA <- ggplot(filter_stat, aes(FILTER, P)) + 
  geom_boxplot(aes(fill = FILTER), alpha = .3, outlier.size = -1) + 
  geom_jitter(aes(col = FILTER), position=position_jitter(0.3)) +
  scale_fill_brewer(palette = "Set1", guide = "none") +
  scale_color_brewer(palette = "Set1", guide = "none") +
  scale_x_discrete(limits = filter_orders) +
  ylab("% of filtered variants") + 
  xlab("") +
  scale_y_continuous(labels = percent) 

pB <- ggplot(spe_all, aes(FILTER, N_FILTERED_SPE)) + 
  geom_boxplot(aes(fill = FILTER), alpha = .3, outlier.size = -1) + 
  geom_jitter(aes(col = FILTER), position=position_jitter(0.3)) +
  scale_fill_brewer(palette = "Set1", guide = "none") +
  scale_color_brewer(palette = "Set1", guide = "none") +
  scale_x_discrete(limits = filter_orders) +
  ylab("Nb of filtered variants") + 
  xlab("") +
  theme(legend.position = "bottom")
# facet_wrap(~factor(FILTER, levels = c("Transcript relevance","Union","Frequence","Genotype","Ctrl","Variant impact")), scales = "free")

plot_grid(pA,pB, labels = c("A","B"), ncol = 1)

```

(ref:plotcomparefilter) `r fig_cap`

\newpage

```{r tablegene, dependson="remaininggense", cache=TRUE}

df_recap <- df_remaining_gene %>% 
  mutate(SIFT = na.replace(SIFT, "."),
         PolyPhen = na.replace(PolyPhen, "."),
         ExAC_AF = na.replace(ExAC_AF, "."),
         ESP = na.replace(ESP, "."),
         `1KG` = na.replace(`1KG`, "."),
         PolyPhen = gsub("probably", "proba", PolyPhen),
         PolyPhen = gsub("possibly", "possib", PolyPhen),
         HGVSc = na.replace(HGVSc, "."),
         HGVSp = na.replace(HGVSp, "."),
         `HGVSc, HGVSp` = paste0(HGVSc," ; ", HGVSp)) %>%
  select(Family, Gene = SYMBOL, HGVSc, HGVSp, `HGVSc, HGVSp`, CANONICAL, Consequence, SIFT, PolyPhen, ExAC = ExAC_AF, ESP, `1KG`) %>% 
  distinct() %>% 
  arrange(Family)

```

\newpage  

### Article n°1

**SPINK2 deficiency causes infertility by inducing sperm defects in heterozygotes and azoospermia in homozygotes** 

Kherraf ZE^\*^, Christou-Kent M^\*^, **Karaouzène T**, Amiri-Yekta A, Martinez G, Vargas AS, Lambert E, Borel C, Dorphin B, Aknin-Seifer I, Mitchell MJ, Metzler-Guillemain C, Escoffier J, Nef S, Grepillat M, Thierry-Mieg N, Satre V, Bailly M, Boitrelle F, Pernet-Gallay K, Hennebicq S, Fauré J, Bottari SP, Coutton C, Ray PF, Arnoult C  

^\*^ Co-premiers auteurs  

EMBO Molecular Medicine, Mai 2017

\newpage

#### Contexte et objectifs   

L'oligospermie, comme l'azoospermie sont des phénotypes d'infertilité masculine liées à la quantité de spermatozoïdes présents dans l'éjaculat. Les différentes études publiées ces dernières années montrent que les microdélétions du chromosome Y sont retrouvées chez 10% des hommes avec une azoospermie non-obstructive et chez 5% des patients avec une oligozoospermie sévère [@Hotaling2014]. Ces taux bien qu'élevés ne représentent qu'une infime partie des cas d'azoospermie et d'oligospermie, suggérant l'implication de nombreux autres gènes dans ce phénotype.  

Entre 2005 et 2014 deux frères issus d'une union consanguine ont demandé des conseils médicaux auprès de différentes cliniques d'infertilité après deux ans d’échec reproductif. Ces deux frères étant mariés à des femmes non-apparentées, une cause féminine fût exclue et les recherches ont été concentrées sur l'analyse des deux frères. Tous deux présentaient de sévères défauts de production de spermatozoïdes, l’un des frères présentant une azoospermie non-obstructive et l’autre une oligozoospermie extrême (<1 Million de spermatozoïde/ ml). Au vu de la similarité du phénotype et de leur lien de parenté, l'hypothèse d'une cause génétique commune fut émise. L'analyse de leur caryotype et du locus AZF du chromosome Y ne révélant aucune anomalie, la procédure d'un séquençage WES fut décidée.  

Dans ce contexte, l'objectif de mon travail a été d'effectuer l'ensemble des analyses des données WES obtenues après leur séquençage afin de mettre en évidence une mutation homozygote commune pouvant expliquer le déficit spermatique des deux frères. Dans un second temps, j'ai mis en place le protocole de génotypage des souris au locus du gène *Spink2* permettant d'identifier les souris sauvages *Spink2*^+/+^ des souris KO *Spink2*^-/-^. Pour finir, afin d'estimer l'importance des variants du gène *SPINK2* comme cause d'infertilité masculine chez l'humain, j'ai également contribué au séquençage Sanger de la séquence codante de *SPINK2* d'une partie des 611 patients séquencés dans cette étude.  

\newpage

\includepdf[pages=-]{bib/SPINK2_2017.pdf}

\newpage

#### Principaux résultats

```{r dfrecapaz, cache=TRUE, dependson="tablegene"}

df_remaining_variant_az <- df_recap %>%
  ungroup() %>% 
  filter(Family == "AZ") %>% 
  mutate(HGVSc = na.replace(HGVSc, "."),
         HGVSp = na.replace(HGVSp, "."),
         `HGVSc, HGVSp` = paste0(HGVSc," ; ", HGVSp)) %>% 
  select(-Family, -SIFT, -PolyPhen, -CANONICAL, -HGVSc, -HGVSp) 

```

```{r varrecapaz, cache=TRUE, dependson="dfrecapaz"}

nb_var_fam_az <- df_remaining_variant_az %>% nrow
gene_fam_az <- df_remaining_variant_az %>% collect() %>% .[["Gene"]]

```

L’analyse et le filtrage des données de séquençage des deux frères par notre pipeline a permis de retenir seulement `r nb_var_fam_az` variants répondant à tous les critères établis (**Table : **\@ref(tab:tabrecapaz)). Le premier de ces variants chevauchait la séquence codante du gène *GUF1* et entraînait la substitution d'une sérine par une isoleucine. Le second impactait le gène *SPINK2* et se situait trois nucléotides en amont du deuxième exon pouvant ainsi entraîner des erreurs d'épissage pouvant par la suite soit engendrer un décalage du cadre de lecture menant à la formation d'un codon stop prématuré ou bien sauter complètement la transcription de cet exon créant un codon stop au début de l'exon 3.  

Parmi ces deux gènes, seul *SPINK2* présentait une forte expression testiculaire dans les données Ensembl (**Figure : **\@ref(fig:plotexpfamaz)) et nous avons confirmé cette surexpression  par RT-PCR dans cette étude. De plus, un KO partiel de *Spink2* chez la souris avait déjà été décrit comme induisant des défauts partiels de la spermatogenèse [@Lee2011]. Ces arguments ont ainsi fait de *SPINK2* le candidat évident pour expliquer le phénotype de ces deux frères. Après avoir confirmé en séquençage Sanger la présence de la mutation de ce gène à l'état homozygote pour les deux frères et hétérozygotes pour les parents, nous avons, afin de continuer nos investigations, développé un modèle murin KO *Spink2*^-/-^ confirmant une azoospermie complète pour les souris mâle causée par un arrêt de la spermatogenèse au stage des spermatides rondes. De plus, malgré une fertilité normale, nous avons pu noter un taux élevé d'anomalies morphologiques du spermatozoïde ainsi qu'une motilité spermatique réduite chez les souris mâles hétérozygotes *Spink2*^+/-^. Les femelles, elles, ne présentaient aucun phénotype apparent. L'étude de la localisation de la protéine Spink2 chez la souris et SPINK2 chez l'humain a révélé que ces deux protéines localisaient dans la vésicule acrosomale depuis le début de la biogénèse de l'acrosome jusqu'au spermatozoïde mature.  Nous avons, par ailleurs, démontré que Spink2, une antiprotéase à sérine, permettait de neutraliser l’acrosine (Acr) pendant son transit par l’appareil de golgi, et qu’en son absence, Acr déstructurait le golgi, empêchait la formation acrosomale et entraînait le blocage au stade de spermatide ronde.    

Suite à cela, afin d'évaluer l'importance des variants du gène *SPINK2* dans l'infertilité humaine, nous avons effectué le séquençage Sanger de 611 patients parmi lesquels 210 étaient azoospermes, 393 oligozoospermes et 8 dont la cause n'était pas spécifiée. Parmi ces patients, seul 1 s'est révélé porter un variant non répertorié dans ExAC sur le gène *SPINK2*. Ce patient présentant un phénotype d'oligozoospermie porte à l'état hétérozygote un variant altérant le codon start du gène *SPINK2*. Ces résultats indiquent donc que chez l'homme, comme chez la souris, la présence de mutations homozygotes sur le gène *SPINK2*  induit un phénotype d'azoospermie ou d’oligozoospermie sévère tandis que la présence d’une mutation hétérozygote pouvait entraîner un phénotype d'oligozoospermie avec un taux élevé d’anomalies morphologiques du spermatozoïde. Le fait que même les hétérozygotes puissent subir une pression de sélection négative pourrait expliquer la rareté observée des mutations *SPINK2*.  


```{r tabrecapaz,cache=TRUE, dependson="dfrecapaz"}

caption <- "Liste des variants ayant passé l'ensemble des filtres pour les deux fères de la famille AZ"

df_remaining_variant_az %>% 
  kable(format = "latex",
        booktabs = TRUE,
        longtable = TRUE,
        caption = caption) %>%
  add_header_above(c(" ", "Impact" = 2, "Frequency" = 3))

```

```{r plotexpfamaz, fig.cap='(ref:plotexpfamaz)',fig.scap='(ref:plotexpfamaztitle)', dependson="varrecapaz", cache=TRUE}

fig_name <- "Expression tissulaire des gènes *SPINK2* et *GUF1*"
fig_name2 <- "Expression tissulaire des gènes SPINK2 et GUF1"
fig_description <- "Données provenant du projet de transcriptome Illumina BodyMap. Contrairement au gène *GUF1* (en rouge) qui a une expression relativement ubiquitaire, *SPINK2* (en bleu) a une expression quasi spécifique au testicule."
fig_cap <- paste0("**_",fig_name,"_** : ", fig_description)

gene_fam_az <- df_recap %>% filter(Family == "AZ") %>% collect() %>% .[["Gene"]]

plot_expression(gene_fam_az,"percent", TRUE)+
  xlab("") +
  theme(legend.position = c(1, 0),
        legend.justification = c(1,0))

```

(ref:plotexpfamaztitle) `r fig_name`

(ref:plotexpfamaz) `r fig_cap`


\newpage

### Article n°2

**Homozygous mutation of PLCZ1 leads to defective human oocyte activation and infertility that is not rescued by the WW-binding protein PAWP**

Jessica Escoffier J^\*^, Lee HC^\*^, Yassine S^\*^, Zouari R, Martinez G, **Karaouzène T**, Coutton C, Kherraf ZE, Halouani L, Triki C, Nef S, Thierry-Mieg N, Savinov SN, Fissore R, Ray PF, Arnoult C  

^\*^ Co-premiers auteurs  

Human Molecular Genetics, Décembre 2015  

\newpage

#### Contexte et objectifs  

L'activation ovocytaire regroupe une série de processus intervenant lors de la fécondation de l’ovocyte par le spermatozoïde. En 1990, plusieurs études ont démontré que chez les mammifères ces processus reposent principalement sur le relargage par le spermatozoïde de "facteurs spermatiques" qui déclenchent un signal constitué d'oscillations Ca^2+^. Plus tard, la protéine PLCZ1 fut identifiée comme la molécule responsable de l’induction de ces oscillations calciques. Cependant, l'incapacité à produire des modèles animaux *PLCZ1* KO capables de produire des spermatozoïdes matures a empêché d'attribuer l'exclusivité de ce rôle à *PLCZ1*, laissant ouverte la possibilité que l’activation ovocytaire puisse être tributaire d'autres facteurs spermatiques. C'est ainsi qu'en 2014 fut proposée la protéine PAWP comme facteur spermatique alternatif ou complémentaire à PLCZ1 [@Aarabi2014; @Aarabi2014a].   

Les travaux ci-dessous décrivent les analyses effectuées sur deux frères issus d'une union consanguine ayant tous deux été dans l'incapacité de concevoir un enfant spontanément. Des fécondations in vitro avec injection directe d’un spermatozoïde (ICSI) ont par la suite été réalisées et n’ont pas permis la fécondation ovocytaires.  
Comme dans l'étude précédente, en raison de l'historique de consanguinité de la famille des deux frères et du non-apparentement de leurs femmes respectives nous avons exclu l'hypothèse d'une cause féminine et nous avons recherché un variant homozygote commun aux deux frères par séquençage WES. Comme précédemment, j'ai été en charge de l'ensemble des analyses des données issues du séquençage des deux frères.  

\newpage

\includepdf[pages=-]{bib/PLCZ1_2016}

\newpage

#### Principaux résultats

```{r dfrecapff, cache=TRUE, dependson="tablegene"}

df_remaining_variant_ff <- df_recap %>% 
  ungroup() %>% 
  filter(Family == "FF") %>% 
  mutate(HGVSc = na.replace(HGVSc, "."),
         HGVSp = na.replace(HGVSp, "."),
         `HGVSc, HGVSp` = paste0(HGVSc," ; ", HGVSp)) %>% 
  select(-Family, -CANONICAL, -HGVSc, -HGVSp, -ESP, -`1KG`)

```

```{r varrecapff, cache=TRUE, dependson="dfrecapff"}

nb_var_fam_ff <- df_remaining_variant_ff %>% nrow
gene_fam_ff <- df_remaining_variant_ff %>% collect() %>% .[["Gene"]]

freq_var_plcz <- df_remaining_variant_ff %>% filter(Gene == "PLCZ1") %>% collect() %>% .[["ExAC"]]

```


Suite à l'analyse bio-informatique de ces deux frères, un seul variant subsistait après l'application de l'ensemble des filtres. Celui-ci était recensé uniquement dans la base de données ExAC avec une fréquence de `r freq_var_plcz` et entrait un faux-sens prédit comme *deleterious* par SIFT et *possibly damaging* par PolyPhen sur la séquence du gène *PLCZ1*. La forte expression testiculaire de ce gène (**Figure : **\@ref(fig:plotexpfamff)) couplée à l'implication déjà connue de celui-ci dans l'activation ovocytaire, ont fait de ce variant le candidat évident pour expliquer le phénotype de ces deux frères. De plus, aucun variant n'a été retrouvé sur la séquence du gène *WBP2NL* codant pour la protéine PAWP (l’autre gène candidat à la fonction d’activateur ovocytaire) bien que l'intégralité de la séquence codante de *WBP2NL* ait une couverture $\ge$ 40x (les zones moins couvertes du début de l'exon 1 et de la fin de l'exon 6 correspondant aux régions UTR) (**Figure : **\@ref(fig:plotcovplcz)). Ces résultats suggérant une parfaite fonctionnalité de la protéine PAWP ont pu être confirmés par *Western blot*, de même, la bonne localisation de la protéine PAWP a pu être observée chez les deux patients par Immunofluorescence alors que PLCZ1 était absent du sperme de nos patients.  

Cette étude confirme le rôle primordial de PLCZ1 dans l'activation ovocytaire et démontre que la présence de PAWP seul ne permet pas  cette activation.  

```{r tabrecapff,cache=TRUE, dependson="dfrecapaz"}

caption <- "Liste des variants ayant passé l'ensemble des filtres pour les deux fères de la famille FF"

df_remaining_variant_ff %>% 
  kable(format = "latex",
        booktabs = TRUE,
        longtable = TRUE,
        caption = caption) %>%
  add_header_above(c(" ", "Impact" = 4, "Frequency" = 1))

```

\newpage

```{r plotexpfamff, fig.cap='(ref:plotexpfamff)',fig.scap='(ref:plotexpfamfftitle)', fig.asp=.63, cache=TRUE}

fig_name <- "Expression tissulaire du gène *PLCZ1*"
fig_description <- "Données provenant du projet de transcriptome Illumina BodyMap"
fig_cap <- paste0("**_",fig_name,"_** : ", fig_description)

plot_expression(gene_fam_ff,"percent", TRUE)+
  xlab("") +
  theme(legend.position = c(1, 0),
        legend.justification = c(1,0))


```

(ref:plotexpfamfftitle) `r fig_name`
(ref:plotexpfamff) `r fig_cap`

```{r plotcovplcz, fig.cap='(ref:plotcovplcz)',fig.scap='(ref:plotcovplcztitle)', out.extra="scale=.37", cache=TRUE}

fig_name <- "Couverture des six exons de *WBP2NL* pour les deux frères de la famille FF"
fig_description <- "Les barres rouges représentent la couverture moyenne de 10 nucléotides, les bleues représentent les bornes de chaque exon."
fig_cap <- paste0("**_",fig_name,"_** : ", fig_description)

include_graphics(path = "figure/pawp_coverage.png")

```

(ref:plotcovplcztitle) `r fig_name`  
(ref:plotcovplcz) `r fig_cap`

\newpage

### Article n°3

**Whole-exome sequencing of familial cases of multiple morphological abnormalities of the sperm flagella (MMAF) reveals new DNAH1 mutations**
  
Amiri-Yekta A^\*^, Coutton C^\*^, Kherraf ZE, **Karaouzène T**, Le Tanno P, Sanati MH, Sabbaghian M, Almadani N, Sadighi Gilani MA, Seyedeh Hanieh Hosseini, Bahrami S, Daneshipour A, Bini M, Arnoult C, Colombo R, Gourabi H, Ray PF  

^\*^ Co-premiers auteurs  

Human Reproduction, Octobre 2016  

\newpage

#### Contexte et objectifs  

Dans une étude précédente non détaillée dans ce manuscrit (en [annexe](#dnah12014)), notre équipe a pu identifier *DNAH1* comme le premier gène codant pour une dynéine axonémale responsable uniquement d’infertilité masculine. Dans cette première étude, 5 de nos 18 patients non-apparentés, soit environ 28% d'entre eux, étaient porteur d'une mutation homozygote sur le gène *DNAH1* responsable de leur phénotype MMAF. Ces résultats ont ainsi démontré l'importance de l'implication de ce gène dans ce phénotype.  

Dans cette nouvelle étude, nous nous concentrons sur l'analyse des données génétiques de 5 familles iraniennes et d'une famille italienne soit un total de 12 individus parmi lesquels 10 ont été séquencés en WES. Cependant, pour des raisons techniques, seules les données de `r nb_run_fam_mmaf` d'entre eux ont été analysées sur notre pipeline décrit précédemment.  

Dans ce contexte j'ai effectué l'ensemble des analyses bio-informatiques de ces patients.         

\newpage

\includepdf[pages=-]{bib/Fam_DNAH1_2016.pdf}

\newpage

#### Principaux résultats

```{r dfrecapmmaf, cache=TRUE, dependson="tablegene"}

df_remaining_variant_mmaf <- df_recap %>% 
  ungroup() %>% 
  filter(grepl("MMAF", Family)) %>% 
  mutate(HGVSc = na.replace(HGVSc, "."),
         HGVSp = na.replace(HGVSp, "."),
         `HGVSc, HGVSp` = paste0(HGVSc," ; ", HGVSp)) %>% 
  select( -SIFT, -PolyPhen, -CANONICAL, -HGVSc, -HGVSp) %>% 
  group_by(Family) %>%
  mutate(N_GENE = n_distinct(Gene))

```

```{r varrecapmmaf, cache=TRUE, dependson="dfrecapmmaf"}

nb_var_fam_mmaf <- df_remaining_variant_mmaf %>% ungroup() %>% summarise(N = n_distinct(`HGVSc, HGVSp`)) %>% collect() %>% .[["N"]]
nb_gene_fam_mmaf_min <- df_remaining_variant_mmaf %>% collect() %>% .[["N_GENE"]] %>% min
nb_gene_fam_mmaf_max <- df_remaining_variant_mmaf %>% collect() %>% .[["N_GENE"]] %>% max

gene_fam_mmaf <- df_remaining_variant_mmaf %>% collect() %>% .[["Gene"]]

```

Après avoir été séquencés en WES, les données des `r nb_run_fam_mmaf` patients `r run_fam_mmaf_all %>% paste_vector("itallic")` ont été analysées au sein de notre pipeline. Compte tenu de l'historique de consanguinité de ces familles, l'ensemble des variants hétérozygotes ont été filtrés de même que l'ensemble des variants observés fréquemment dans la population générale et ceux n'ayant aucun impact sur la séquence codante. Aussi, dans les cas où les données de WES de plusieurs frères d'une même famille étaient disponibles, seuls les variants partagés par l'ensemble des frères ont été gardés. À l'issue de cette étape de filtrage, seuls quelques variants subsistaient pour chacune des familles impactant entre `r nb_gene_fam_mmaf_min` et `r nb_gene_fam_mmaf_max` gènes différents en fonction de celles-ci (**Tables :** \@ref(tab:tabmmaf1), \@ref(tab:tabmmaf2), \@ref(tab:tabmmaf3), \@ref(tab:tabmmaf4), \@ref(tab:tabmmaf5), **Figure : **\@ref(fig:plotremaininggenes)).  
  
Parmi cette liste de gènes, *DNAH1* fut retrouvé muté chez les deux frères de la famille MMAF3 ainsi que chez les deux frères de la famille MMAF6 (non analysée par notre pipeline). De même, un variant entraînant un décalage du cadre de lecture dans la séquence du gène *SPEF2* (codant pour la protéine *Sperm flagellar 2* (SPEF2)) a été retrouvé chez le patient P10 de la famille MMAF5. Aucun autre candidat évident n'a pu être identifié pour les individus composant les 3 autres familles. Ensuite, bien que le gène *SPEF2* ait déjà été caractérisé comme ayant un rôle dans la biogénèse du flagelle spermatique [@Lehti2017] nous nous sommes dans un premiers temps concentrés sur la caractérisation des deux variants retrouvés sur *DNAH1*.  

1. **Famille MMAF3 :** Les deux frères P5 et P6 analysés en WES étaient tous deux porteurs de la même mutation c.8626-1G > A qui fut par la suite confirmée en Sanger pour ces deux patients ainsi que pour leur troisième frère (P7) non analysé en WES. Cette mutation, absente des différentes bases de données, impacte le dernier nucléotide de l'intron 54 de *DNAH1*, c'est-à-dire, l'une des deux bases composant le site accepteur consensus d'épissage. Afin d'évaluer l'impact de cette mutation sur le transcrit de *DANH1*, nous avons étudiés, par RT-PCR, l'ARNm provenant de ces trois frères ainsi que de deux individus contrôle. Cette étude a révélé qu'aucune amplification du transcrit de *DNAH1* n'était observée chez les trois frères contrairement aux deux contrôles tandis que l'amplification ciblant *GAPDH* était positif pour les cinq individus confirmant ainsi l'intégrité de l'ARNm de l'ensemble des individus testés. Ces résultats suggèrent donc que les transcrits produits par les trois frères mutés ont été soumis au mécanisme de dégradation spécifique par *mRNA decay*. Afin de valider la pathogénicité de ce variant, la protéine DNAH a ensuite été localisée par immunofluorescence à la fois chez les patients et les contrôles, révélant que contrairement aux contrôles, la protéine DNAH1 était absente chez les trois frères, renforçant ainsi l'hypothèse d'une dégradation spécifique des ARNm.  

2. **Famille MMAF6 :** Le variant c.3860 T > G (p.Val1287Gly) induisant une mutation faux sens dans la séquence de l'exon 23 de *DNAH1* a été retrouvé dans les données WES des deux frères P11 et P12 (non analysés par notre pipeline) et a par la suite été confirmé en Sanger. Malheureusement, par manque de matériel, aucune étude par RT-PCR ou immunofluorescence n'a pu être effectuée sur ces patients. Cependant, le fait que ce variant faux-sens soit absent des bases de données et qu'il soit prédit comme *probably dammaging* par PolyPhen et *deleterious* par SIFT renforce l'hypothèse de la pathogénicité de ce variant.   

Ainsi, à l'issue de l'analyse de ces `r nb_mmaf_fam + 1` familles présentant un phénotype MMAF (dont seulement `r nb_mmaf_fam` ont été analysées sur notre pipeline), le variant responsable a pu être déterminé pour deux d'entre elles grâce à l'identification de deux nouveaux variants impactant la séquence codante du gène *DNAH1* confirmant ainsi l'importance de l'implication de ce gène dans le phénotype MMAF. De même un indel entraînant un décalage du cadre de lecture dans la séquence du gène *SPEF2* fait de ce gène, déjà connu comme ayant un rôle dans la formation des flagelles, un excellent candidat pour expliquer le phénotype du patient P10. Notre équipe travaille à l'heure actuelle à la caractérisation de ce gène. Cependant, aucun candidat évident n'a pu être identifié pour les `r (nb_mmaf_fam + 1) - 3` familles restantes laissant supposer que le variant responsable de leur phénotype ait été éliminé par un de nos filtres. Ainsi, la cause génétique de leur phénotype n'a soit pas été détectée soit a été éliminée par un de nos filtres. Afin d'identifier la cause génétique de leur phénotype, nous réanalysons actuellement les données de ces patients en appliquant des filtres moins stringents, en conservant les gènes sur lesquels deux variants hétérozygotes sont retrouvés, ce qui pourrait être la signature d'une hétérozygotie composite.  

\newpage

```{r plotremaininggenes, fig.height=7, fig.cap='(ref:plotremaininggenes)',fig.scap=fig_name, cache=TRUE}

fig_name <- "Nombre de gènes passant l'ensemble des filtres par famille"
fig_description <- "Chaque barre représente une des familles analysées. La hauteur de cette barre correspond au nombre de gènes ayant passé l'ensemble des filtres pour chaque famille. Les barres vertes caractérisent les familles pour lesquelles le gène responsable de la pathologie a été identifié parmi la liste de gènes (dans ce cas le symbole du gène est écrit au-dessus de la barre). La barre orange caractérise la famille pour laquelle un candidat potentiel a été identifié (le symbole du gène est écrit au-dessus suivit d'un \"?\"). Les barres rouges indiquent qu'aucun des gènes ayant passé les filtres ne semble expliquer le phénotype des individus de la famille (dans ce cas il est écrit \"???\" au-dessus de la barre)."
fig_cap <- paste0("**_",fig_name,"_** : ", fig_description)

ggplot(df_causal %>% filter(grepl("MMAF", Family)), aes(Family, N)) +
  geom_col(aes(fill = FIND_CAUSAL)) +
   scale_y_continuous(limits = c(0,max(df_causal$N) + 1), breaks = seq(0, max(df_causal$N) + 1,2)) +
  geom_text(aes(label = CAUSAL), position = position_dodge(width = .9), hjust = 1.1) +
  ylab("Nb of remaining genes after all filtering") +
  theme(axis.title.y=element_blank()) +
  scale_fill_manual(name = "Is the causal variant found?", limits = c("Yes", "Maybe", "No"), values = c("chartreuse3", "#FF7F00", "#E41A1C")) + 
  theme(legend.position = "bottom") + 
  coord_flip()


```

(ref:plotremaininggenes) `r fig_cap`

\newpage

## Résultats 2 : Étude d'une cohorte de femmes infertiles  
### Article n°4

**PATL2 Gene Mutation Causes Oocyte Meiotic Deficiency and Female Infertility** 

Christou-Kent M, Amiri-Yekta A, Kherraf ZE, **Karaouzène T**, Escoffier J, Guttin A, Martinez G, Le Blévec E, Lambert E, Fourati Ben Mustapha S, Cedrin-Durnerin I, Halouani L, Marrakchi O, Makni M, Latrous H, Kharouf M, Bottari S, Thierry-Mieg N, Coutton C, Zouari R, Issartel JP, Ray PF, Arnoult C

New England Journal of Medicine, 07 Juillet 2017 (soummis)

\newpage

#### Contexte et objectifs  

<!-- RUN -->

```{r dfrunovo, cache=TRUE}

df_run_ovo <- fread("data/exome_runs_all.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, drop = c(2,3,4,10:16), data.table = FALSE) %>% 
  rename(RUN = Magic_ID, PHENOTYPE = Pathologie, DATE = Date) %>%
  filter(!Project %in% c("Novogene","Integragen")) %>%
  mutate(YEAR = as.numeric(str_sub(DATE, start= -4)),
         PROJECT = paste0(Project," (",YEAR,")")) %>%
  filter(PHENOTYPE == "Ovo") %>% 
  select(-DATE, -PHENOTYPE)

```

```{r varrunovo, cache=TRUE, dependson="dfrunovo"}

run_ovo <- df_run_ovo %>% collect() %>% .[["RUN"]]
nb_ovo_run <- df_run_ovo %>% nrow

run_ctrl_ovo <- fread("data/exome_runs_all.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, drop = c(2,4,10:16), data.table = FALSE) %>% 
    rename(PHENOTYPE = Pathologie, DATE = Date) %>%
  mutate(RUN = if_else(Project == "Integragen", Patient, 
                       if_else(Project == "Novogene", paste0("s", Patient), Magic_ID)),
         PHENOTYPE = if_else(PHENOTYPE == "Flag", "MMAF", PHENOTYPE)) %>% 
  filter(!(PHENOTYPE %in% c("Ovo", "Azoo"))) %>%
  collect() %>%
  .[["RUN"]]

min_ovo_year <- df_run_ovo$YEAR %>% min
max_ovo_year <- df_run_ovo$YEAR %>% max

center_ovo <- df_run_ovo$Project %>% unique
nb_center_ovo <- center_ovo %>% length

```

<!-- ANNOTATION -->

```{r dfannotateovo, cache=TRUE}
 
df_annotate <- fread("zcat data/call_results/others_novogen_integragen_distinct_var_vep81_format_no_MODIFIER.csv.gz", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, data.table = FALSE)

```

<!-- CALL -->

```{r dfovocall, dependson=c("dfannotateovo","varrunovo","localfunction"), cache=TRUE}

df_ovo_call <- fread("data/call_results/others_novogen_integragen_var_genotype.csv",
                         sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, data.table = FALSE) %>%
  select(CHR, POSITION, REF, ALT, one_of(run_ovo)) %>%
  gather(RUN, CALL, -(CHR:ALT)) %>%
  filter(CALL %in% c(0, 2, 3, "b", "c"),
         !is.na(REF)) %>%
  mutate(STRAND = call_to_strand(CALL),
         TYPE = var_type(REF, ALT),
         CALL = call_to_geno(CALL))

df_distinct_ovo_call <- df_ovo_call %>%
  filter(grepl("zygous", CALL)) %>%
  distinct(CHR, POSITION, REF, ALT, TYPE) %>%
  variant_join(df_annotate, mode = "inner") %>%
  mutate(PolyPhen = gsub("_", " ", str_extract(PolyPhen, "\\w+")),
         SIFT = gsub("_", " ", str_extract(SIFT, "\\w+")),
         Consequence = sapply(strsplit(Consequence, "_variant", fixed = TRUE),"[[",1),
         Consequence = gsub("_", " ", Consequence),
         HGVSc = sapply(strsplit(HGVSc, split=':', fixed=TRUE), function(x) (x[2])),
         HGVSp = sapply(strsplit(HGVSp, split=':', fixed=TRUE), function(x) (x[2])))  


df_ovo_call_geno <- df_ovo_call %>%
  filter(grepl("zygous", CALL)) %>%
  group_by(RUN, TYPE, CALL) %>%
  distinct(CHR, POSITION, REF, ALT) %>%
  count() %>%
  left_join(df_run_ovo, by = "RUN") %>%
  select(-(Project:Model))
                       
df_ovo_call_strand <- df_ovo_call %>%
  group_by(RUN, STRAND) %>%
  count() %>%
  group_by(RUN) %>%
  mutate(N_ALL_STRAND = sum(n),
         P_STRAND = n / N_ALL_STRAND) %>%
  left_join(df_run_ovo, by = "RUN")

```

```{r varovocall, cache=TRUE, dependson="dfovocall"}

```

<!-- FILTER -->

```{r dfctrlovo, cache=TRUE,  dependson= c("varrunovo","callfunction")}

df_ctrl_ovo <- define_ctrl_var(run_ctrl_ovo)
  
```

```{r dfovofilter, cache=TRUE, dependson=c("dfctrlovo","dfovocall")}

maf_cutoff <- .01

df_distinct_ovo_filter <- df_distinct_ovo_call %>%
  filter_frequence(cutoff = maf_cutoff) %>%
  variant_join(df_ctrl_ovo, mode = "anti") %>%
  filter(Consequence != "synonymous",
         IMPACT != "MODIFIER",
         !(grepl("tolerated", SIFT) & grepl("benign", PolyPhen)),
         !grepl("NMD transcript", Consequence),
         !grepl("non coding transcript", Consequence))

df_ovo_filter <- df_ovo_call %>%
  select(-STRAND) %>%
  filter_genotype(het = FALSE) %>%
  variant_join(df_distinct_ovo_filter, mode = "inner") %>%
  ungroup()

df_ovo_filter_het <- df_ovo_call %>%
  select(-STRAND) %>%
  filter_genotype(homo = FALSE) %>%
  variant_join(df_distinct_ovo_filter, mode = "inner") %>%
  group_by(RUN, SYMBOL, Feature) %>%
  mutate(N_VAR_PER_RUN_PER_GENE = n()) %>%
  filter(N_VAR_PER_RUN_PER_GENE > 1) %>%
  group_by(SYMBOL) %>%
  mutate(N_RUN_PER_GENE = n_distinct(RUN)) %>%
  ungroup()

df_ovo_filter_stat <- df_ovo_filter %>%
  group_by(RUN) %>%
  mutate(N_GENE = n_distinct(SYMBOL)) %>%
  group_by(RUN, TYPE, N_GENE) %>%
  distinct(CHR, POSITION, REF, ALT) %>%
  summarise(N_VAR_PER_TYPE = n()) %>%
  group_by(RUN) %>%
  mutate(N_VAR_TOT = sum(N_VAR_PER_TYPE)) %>%
  right_join(df_run_ovo, by = "RUN")

```

```{r varovofilter, cache=TRUE, dependson="dfovofilter"}

nb_distinct_var <- df_ovo_filter %>% ungroup() %>% distinct(CHR, POSITION, REF, ALT) %>% nrow
nb_distinct_snv <- df_ovo_filter %>% ungroup() %>% filter(TYPE == "SNV") %>% distinct(CHR, POSITION, REF, ALT) %>% nrow
nb_distinct_indel <- df_ovo_filter %>% ungroup() %>% filter(TYPE == "Indel") %>% ungroup() %>% distinct(CHR, POSITION, REF, ALT) %>% nrow
nb_distinct_gene <- df_ovo_filter %>% ungroup() %>% distinct(SYMBOL) %>% nrow

nb_run_patl2 <- df_ovo_filter %>% filter(SYMBOL == "PATL2") %>% distinct(RUN) %>% nrow
p_run_patl2 <- (nb_run_patl2 / nb_ovo_run) %>% round(3) * 100

hgvsc_patl2 <- df_ovo_filter %>% filter(SYMBOL == "PATL2", CANONICAL == "YES") %>% distinct(HGVSc) %>% collect() %>% .[["HGVSc"]] 
hgvsp_patl2 <- df_ovo_filter %>% filter(SYMBOL == "PATL2", CANONICAL == "YES") %>% distinct(HGVSp) %>% collect() %>% .[["HGVSp"]] 
canonical_tr_patl2 <- df_ovo_filter %>% filter(SYMBOL == "PATL2", CANONICAL == "YES") %>% distinct(Feature) %>% collect() %>% .[["Feature"]]

```

```{r dfovotwohomohigh, cache=TRUE, dependson="dfovofilter"}

df_ovo_filter_high <- df_ovo_filter %>%
  filter(IMPACT == "HIGH",
         CANONICAL == "YES") %>%
  group_by(SYMBOL) %>%
  summarise(High = n_distinct(RUN)) %>%
  filter(High > 0)

df_ovo_filter_moderate <- df_ovo_filter %>%
  filter(IMPACT != "HIGH",
         CANONICAL == "YES") %>%
  group_by(SYMBOL) %>%
  summarise(Moderate = n_distinct(RUN))

df_ovo_filter_low <- df_ovo_filter_het %>%
  filter(CANONICAL == "YES") %>%
  group_by(SYMBOL, RUN) %>%
  filter(n() > 1) %>%
  group_by(SYMBOL) %>%
  summarise(Low = n_distinct(RUN))

df_ovo_filter_reduce <- df_ovo_filter_high %>%
  left_join(df_ovo_filter_moderate, by = "SYMBOL") %>%
  left_join(df_ovo_filter_low, by = "SYMBOL") %>%
  mutate(N_HIGH = High,
         N_MODERATE = Moderate,
         N_LOW = Low) %>%
  gather(EVIDENCE, N_RUN, High:Low, factor_key = TRUE) %>%
  group_by(SYMBOL) %>%
  mutate(N_RUN = na.replace(N_RUN, 0),
         N_TOT = sum(N_RUN))

```

Entre `r min_ovo_year` et `r max_ovo_year` notre équipe a pris en charge l’étude génétique de 23 femmes nord africaines présentant toutes une déficience méiotique ovocytaire (DMO) caractérisée par un blocage de la méiose au stade M1 et entrainant une infertilité. À l'heure actuelle, seul le gène TUBB8 retrouvé muté à l'état hétérozygote chez des patientes chinoises avait pu être lié à ce phénotype. Cette étude a donc pour objectif de caractériser la cause génétique responsable du phénotype DMO de ces 23 femmes. Parmi celles-ci, `r nb_ovo_run` ont été analysées par séquençage haut-débit. Dans ce contexte, j'ai, au cours de ma thèse, été en charge de l'ensemble des analyses bio-informatiques de ces `r nb_ovo_run` femmes.  

\newpage

\includepdf[pages=-]{bib/PATL2_2017.pdf}

\newpage

#### Principaux résultats

L'application de notre pipeline d'analyse sur les données de ces femmes nous a permis d'obtenir une liste de `r nb_distinct_var` variants impactant `r nb_distinct_gene` gènes différents. Parmi ces variants, aucun n'impactait le gène *TUBB8*. Afin de restreindre à nouveau la liste de gènes, nous nous sommes concentrés sur ceux retrouvés mutés à l'état homozygote chez au moins 2 femmes. Seul 3 gènes ont passé ce nouveau critère : *FAM58A*, *MGAM* et *PATL2*. Aucune investigation n'a pour l'instant été effectuée sur les `r nb_distinct_gene - 3` autres. En raison de la fréquence élevée du variant retrouvé sur *FAM58A* et de l'impact peu délétère du variant chevauchant *MGAM*, ces deux gènes ont été considérés comme de mauvais candidats. 

Ainsi, nous nous sommes dans un premier temps concentrés sur la caractérisation de *PATL2* dont l'orthologue *xpat1a* chez le xénope a été décrit comme étant exprimé au cours du développement de l'ovocyte [@Marnef2010; @Nakamura2010] faisant de ce gène un excellent candidat. Nous avons observé que `r nb_run_patl2` de nos patientes (`r p_run_patl2`%) étaient porteuses de la même mutation homozygote : `r hgvsc_patl2`, `r hgvsp_patl2` induisant un codon stop prématuré dans la séquence codante du transcrit canonique *PATL2*: `r canonical_tr_patl2`. Au vu de ces résultats un séquençage Sanger de la séquence codante de ce gène fut réalisé pour ces `r nb_run_patl2` femmes afin de confirmer cette mutation, ainsi que sur 8 femmes supplémentaires souffrant du même phénotype. Parmi ces dernières, une s'est révélée porter la même mutation à l'état homozygote. Au final six femmes sur 23 (26%) étaient homozygotes pour la mutation stop de *PATL2*.    

Dans un second temps, l'étude du modèle murin KO *Patl2*^-/-^ nous a permis de mettre en évidence une subfertilité importante chez les souris femelles tandis qu'aucun phénotype n'était observable chez les mâles.  

Pour finir, *xpat1a*, l'orthologue de *PATL2* chez le xénope, ayant été décrit comme réprimant la traduction de l'ARNm dans l'ovocyte, nous avons cherché à savoir si les souris femelles KO *Patl2*^-/-^ présentaient des dérégulations de leur transcriptome ovocytaire. Pour cela, nous avons procédé à une étude comparative des transcriptome ovocytaires aux stades GC et MII murins sur puces Affymetrix mesurant les valeurs d'expression d'environ 66,000 transcrits différents. Ainsi, nous avons pu mettre en évidence 134 transcrits différentiellement exprimés au stade GV parmi lesquels 95 étaient sous-exprimés tandis que 39 étaient sur-exprimés. Au stade MII, ces dérégulations se révélèrent être plus impressionnantes puisque 124 étaient sous-exprimées et 122 sur-exprimées démontrant ainsi une forte implication de *Patl2* dans la transcription ovocytaire des gènes murins.     

<!-- CLEAN -->

```{r cleanovo, include=FALSE, warning=FALSE, message=FALSE}

rm(df_annotate, df_run_ovo, df_ovo_call, df_distinct_ovo_call, 
   df_ctrl_ovo, df_distinct_ovo_filter, df_ovo_filter_stat)
gc()

```

\newpage  

## Résultats 3 : Étude d'une large cohorte de patients MMAF

### Article n°5

**Whole exome cohort study and analysis of mouse and Trypanosoma models demonstrate the importance of WDR proteins in flagellogenesis and male fertility** 

Coutton C, Vargas A, Amiri-Yekta A, Kherraf ZE, Fourati Ben Mustapha S, Le Tanno P, Wambergue-Legrand C, **Karaouzène T**, Martinez G, Daneshipour A, Hanieh Hosseini S, Mitchell V, Halouani L, Marrakchi O, Makni M, Latrous H, Kharouf M, Deleuze JF, Boland A, Hennebicq S, Satre V, Jouk PS, Bottari SP, Thierry-Mieg N, Conne B, Dacheux-Deschamps D, Schmitt A, Stouvenel L, Lorès P, El Khouri E, Fauré J, Wolf JP, Escoffier J, Gourabi H, Robinson DR, Nef S, Dulioust E, Zouari R, Bonhivers M, Touré A, Arnoult C, Ray PF

Nature Communications. En révision  

\newpage

#### Contexte et objectifs  

<!-- RUN -->

```{r dfrunbigmmaf, cache=TRUE}

retained_run_bigmmaf <- 
  c("08IF35",
    "JED",
    "09IF39",
    "09IF53",
    "16IF027",
    "16IF054",
    "DUZ.",
    "14IF049",
    "16IF047",
    "CO",
    "09IF24",
    "11IF06",
    "15IF067",
    "16IF104",
    "15IF060",
    "15IF065",
    "11IF02",
    "14IF034",
    "15IF061",
    "09IF27",
    "16IF053",
    "FLO",
    "09IF52",
    "11IF001",
    "11IF005",
    "14IF032",
    "14IF035",
    "14IF040-2",
    "14IF041",
    "12",
    "BO.F",
    "09IF28",
    "14IF037",
    "09IF21",
    "11IF042",
    "16IF107",
    "16IF036",
    "08IF39",
    "09IF26",
    "DJA",
    "16IF030",
    "16IF102",
    "14IF030",
    "14IF033",
    "10IF36-2",
    "10IF21",
    "16IF032",
    "09IF57",
    "ID.",
    "14IF031",
    "08IF36",
    "08IF41",
    "09IF30",
    "09IF58",
    "10IF017",
    "10IF35",
    "11IF16-1",
    "14IF036",
    "14IF038",
    "14IF039",
    "15IF059",
    "15IF063",
    "15IF064",
    "15IF066",
    "15IF068",
    "16IF042",
    "16IF055",
    "16IF105",
    "16IF106",
    "16IF109",
    "AY.",
    "BLO",
    "CHAF",
    "CHAUV",
    "CRO.",
    "ELANW-I",
    "MEN",
    "DIE.")

# Je ne retrouve pas DIE.

df_run_bigmmaf <- fread("data/exome_runs_all.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, drop = c(2,4,10:16), data.table = FALSE) %>% 
  rename(PHENOTYPE = Pathologie, DATE = Date) %>%
  mutate(Patient = toupper(Patient)) %>% 
  filter((Patient %in% retained_run_bigmmaf)) %>%
  mutate(RUN = if_else(Project == "Integragen", Patient, 
                       if_else(Project == "Novogene", paste0("s", Patient), Magic_ID)),
         RUN2 = Magic_ID) %>%
  select(-Magic_ID, -Patient) %>%
  mutate(PHENOTYPE = if_else(PHENOTYPE == "Flag", "MMAF", PHENOTYPE), 
         YEAR = as.numeric(str_sub(DATE, start= -4)),
         PROJECT = paste0(Project," (",YEAR,")")) %>%
  select(-DATE, -PHENOTYPE)

```

```{r varrunbigmmaf, dependson="dfrunbigmmaf", cache=TRUE}

runs_bigmmaf <- df_run_bigmmaf %>% collect() %>% .[["RUN"]]
runs_ctrl_bigmmaf <- fread("data/exome_runs_all.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, drop = c(2,4,10:16), data.table = FALSE) %>% 
    rename(PHENOTYPE = Pathologie, DATE = Date) %>%
  mutate(RUN = if_else(Project == "Integragen", Patient, 
                       if_else(Project == "Novogene", paste0("s", Patient), Magic_ID)),
         PHENOTYPE = if_else(PHENOTYPE == "Flag", "MMAF", PHENOTYPE)) %>% 
  filter(PHENOTYPE != "MMAF") %>% 
  collect() %>%
  .[["RUN"]]


min_year <- df_run_bigmmaf$YEAR %>% min
max_year <- df_run_bigmmaf$YEAR %>% max

center <- df_run_bigmmaf$Project %>% unique
n_center <- center %>% length

nb_run_bigmmaf <- retained_run_bigmmaf %>% length

nb_run_ctrl_bigmmaf <- runs_ctrl_bigmmaf %>% length


nb_hiseq4000 <- df_run_bigmmaf %>% filter(Model == "HiSeq4000") %>% nrow

```

<!-- ANNOTATION -->

```{r dfannotatebigmmaf, cache=TRUE}
 
df_annotate <- fread("zcat data/call_results/others_novogen_integragen_distinct_var_vep81_format_no_MODIFIER.csv.gz", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, data.table = FALSE)

```

<!-- CALL -->

```{r dfbigmmafcall, cache=TRUE, dependson=c("dfannotatebigmmaf","varrunbigmmaf","dfrunbigmmaf","callfunction")}

df_bigmmaf_call <- fread("data/call_results/others_novogen_integragen_var_genotype.csv", 
                         sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, data.table = FALSE) %>% 
  select(CHR, POSITION, REF, ALT, one_of(runs_bigmmaf)) %>%
  gather(RUN, CALL, -(CHR:ALT)) %>% 
  filter(CALL %in% c(0, 2, 3, "b", "c"),
         !is.na(REF)) %>%
  mutate(STRAND = call_to_strand(CALL),
         TYPE = var_type(REF, ALT),
         CALL = call_to_geno(CALL)) %>%
  left_join(df_run_bigmmaf %>% select(RUN, RUN2), by = "RUN") %>%
  mutate(RUN = RUN2) %>%
  select(-RUN2)

  df_distinct_call <- df_bigmmaf_call %>%  
    filter(grepl("zygous", CALL)) %>% 
    distinct(CHR, POSITION, REF, ALT, TYPE) %>%
    variant_join(df_annotate, mode = "inner") %>%
    mutate(PolyPhen = gsub("_", " ", str_extract(PolyPhen, "\\w+")),
           SIFT = gsub("_", " ", str_extract(SIFT, "\\w+")),
           Consequence = sapply(strsplit(Consequence, "_variant", fixed = TRUE),"[[",1),
           Consequence = gsub("_", " ", Consequence),
           HGVSc = sapply(strsplit(HGVSc, split=':', fixed=TRUE), function(x) (x[2])),
           HGVSp = sapply(strsplit(HGVSp, split=':', fixed=TRUE), function(x) (x[2])))

df_bigmmaf_call_geno <- df_bigmmaf_call %>% 
  filter(grepl("zygous", CALL)) %>% 
  group_by(RUN, TYPE, CALL) %>% 
  distinct(CHR, POSITION, REF, ALT) %>%
  count() %>%
  left_join(df_run_bigmmaf, by = "RUN") %>% 
  select(-(Project:Model))

df_bigmmaf_call_strand <- df_bigmmaf_call %>%
  group_by(RUN, STRAND) %>%
  count() %>%
  group_by(RUN) %>%
  mutate(N_ALL_STRAND = sum(n),
         P_STRAND = n / N_ALL_STRAND) %>%
  left_join(df_run_bigmmaf, by = "RUN")

```

<!-- FILTER-->

```{r dfctrlbigmmaf, cache=TRUE,  dependson= c("varrunbigmmaf","callfunction")}

df_ctrl_mmaf <- define_ctrl_var(runs_ctrl_bigmmaf)

```

```{r dffilterbigmmaf, cache=TRUE, dependson="dfbigmmafcall"}

maf_cutoff <- .01

df_distinct_filter <- df_distinct_call %>%
  filter_frequence(cutoff = maf_cutoff) %>%
  variant_join(df_ctrl_mmaf, mode = "anti") %>%
  filter(Consequence != "synonymous",
         IMPACT != "MODIFIER",
         !(grepl("tolerated", SIFT) & grepl("benign", PolyPhen)),
         !grepl("NMD transcript", Consequence),
         !grepl("non coding transcript", Consequence))

df_bigmmaf_filter <- df_bigmmaf_call %>% 
  select(-STRAND) %>%
  filter_genotype(het = FALSE) %>% 
  variant_join(df_distinct_filter, mode = "inner") %>% 
  # select(-Allele) %>% 
  mutate(SYMBOL = if_else(SYMBOL == "WDR52", "CFAP44", 
                          if_else(SYMBOL == "WDR96", "CFAP43", SYMBOL)),
         
         HGVSc = if_else(CHR == 3 & POSITION == 113063450 & REF == "G" & ALT == "A", "c.3175C>T",
                         if_else(CHR == 3 & POSITION == 113119479 & REF == "C" & ALT == "A", "c.1387G>T", 
                                 if_else(CHR == 3 & POSITION == 113114596 & REF == "C" & ALT == "T", "c.1890+1G>A", HGVSc))),
         
         HGVSp = if_else(CHR == 10 & POSITION == 105912486 & REF == "T" & ALT == "G", "p.Ser1181Lysfs*4", 
                         if_else(CHR == 10 & POSITION == 105944769 & REF == "C" & ALT == "T", "p.Lys714Val*11",
                                 if_else(CHR == 3 & POSITION == 113114596 & REF == "C" & ALT == "T", "p.Pro631Ile*22 ", HGVSp)))) %>%
  ungroup()
  
df_bigmmaf_filter_het <- df_bigmmaf_call %>% 
  select(-STRAND) %>% 
  filter_genotype(homo = FALSE) %>% 
  variant_join(df_distinct_filter, mode = "inner") %>% 
  # select(-Allele) %>%
  group_by(RUN, SYMBOL, Feature) %>%
  mutate(N_VAR_PER_RUN_PER_GENE = n()) %>% 
  filter(N_VAR_PER_RUN_PER_GENE > 1) %>% 
  group_by(SYMBOL) %>%
  mutate(N_RUN_PER_GENE = n_distinct(RUN)) %>%
  ungroup() %>%
  mutate(SYMBOL = if_else(SYMBOL == "WDR52", "CFAP44", 
                          if_else(SYMBOL == "WDR96", "CFAP43", SYMBOL)))

df_bigmmaf_filter_stat <- df_bigmmaf_filter %>% 
  group_by(RUN) %>%
  mutate(N_GENE = n_distinct(SYMBOL)) %>%
  group_by(RUN, TYPE, N_GENE) %>%
  distinct(CHR, POSITION, REF, ALT) %>%
  summarise(N_VAR_PER_TYPE = n()) %>%
  group_by(RUN) %>%
  mutate(N_VAR_TOT = sum(N_VAR_PER_TYPE)) %>%
  right_join(df_run_bigmmaf, by = "RUN") 

```

```{r varbigmmaffilter, dependson="dfbigmmaffilter", cache=TRUE}

n_distinct_var <- df_bigmmaf_filter %>% ungroup() %>% distinct(CHR, POSITION, REF, ALT) %>% nrow
n_distinct_snv <- df_bigmmaf_filter %>% ungroup() %>% filter(TYPE == "SNV") %>% distinct(CHR, POSITION, REF, ALT) %>% nrow
n_distinct_indel <- df_bigmmaf_filter %>% ungroup() %>% filter(TYPE == "Indel") %>% ungroup() %>% distinct(CHR, POSITION, REF, ALT) %>% nrow
n_distinct_gene <- df_bigmmaf_filter %>% ungroup() %>% distinct(SYMBOL) %>% nrow


n_distinct_gene_1_run <- df_bigmmaf_filter %>% filter(CANONICAL == "YES") %>% group_by(Feature) %>% 
  filter(n_distinct(RUN) == 1) %>% ungroup() %>% distinct(SYMBOL) %>% nrow

n_min_var <- df_bigmmaf_filter_stat %>% collect() %>% .[["N_VAR_TOT"]] %>% min
n_max_var <- df_bigmmaf_filter_stat %>% collect() %>% .[["N_VAR_TOT"]] %>% max

n_mean_indel <- df_bigmmaf_filter_stat %>% filter(TYPE == "Indel") %>% collect() %>% .[["N_VAR_PER_TYPE"]] %>% mean %>% round(0)
n_mean_snv <- df_bigmmaf_filter_stat %>% filter(TYPE == "SNV") %>% collect() %>% .[["N_VAR_PER_TYPE"]] %>% mean %>% round(0)

n_min_gene <- df_bigmmaf_filter_stat %>% collect() %>% .[["N_GENE"]] %>% min
n_max_gene <- df_bigmmaf_filter_stat %>% collect() %>% .[["N_GENE"]] %>% max


nb_run_dnah1 <- bind_rows(df_bigmmaf_filter %>% filter(SYMBOL == "DNAH1"),
                          df_bigmmaf_filter_het %>% filter(SYMBOL == "DNAH1")) %>%
  distinct(RUN) %>%
  nrow
          
```

```{r dftwohomohigh, cache=TRUE, dependson="dfbigmmaffilter"}

df_bigmmaf_filter_high <- df_bigmmaf_filter %>% 
  filter(IMPACT == "HIGH",
         CANONICAL == "YES") %>% 
  group_by(SYMBOL) %>%
  summarise(High = n_distinct(RUN)) %>% 
  filter(High > 2) %>%
  filter(!(SYMBOL %in% c("AC090286.4", "AC012309.5", "RP6-206I17.1","hsa-mir-150")),
         !grepl("HLA-", SYMBOL),
         !grepl("RP11", SYMBOL))

df_bigmmaf_filter_moderate <- df_bigmmaf_filter %>% 
  filter(IMPACT != "HIGH",
         CANONICAL == "YES") %>% 
  group_by(SYMBOL) %>%
  summarise(Moderate = n_distinct(RUN))

df_bigmmaf_filter_low <- df_bigmmaf_filter_het %>% 
  filter(CANONICAL == "YES") %>% 
  group_by(SYMBOL, RUN) %>%
  filter(n() > 1) %>% 
  group_by(SYMBOL) %>%
  summarise(Low = n_distinct(RUN))
  
df_bigmmaf_filter_reduce <- df_bigmmaf_filter_high %>% 
  left_join(df_bigmmaf_filter_moderate, by = "SYMBOL") %>%
  left_join(df_bigmmaf_filter_low, by = "SYMBOL") %>%
  mutate(N_HIGH = High,
         N_MODERATE = Moderate,
         N_LOW = Low) %>%
  gather(EVIDENCE, N_RUN, High:Low, factor_key = TRUE) %>% 
  group_by(SYMBOL) %>%
  mutate(N_RUN = na.replace(N_RUN, 0),
         N_TOT = sum(N_RUN)) 

```

```{r vartwohomohigh, cache=TRUE, dependson="dftwohomohigh"}

gene_at_least3 <- df_bigmmaf_filter_high %>% distinct(SYMBOL) %>% collect() %>% .[["SYMBOL"]]
nb_gene_at_least3 <- gene_at_least3 %>% length

nb_run_cfap43_high <- df_bigmmaf_filter_reduce %>% filter(EVIDENCE == "High", SYMBOL == "CFAP43") %>% collect() %>% .[["N_HIGH"]] 
nb_run_cfap43_moderate <- df_bigmmaf_filter_reduce %>% filter(EVIDENCE == "Moderate", SYMBOL == "CFAP43") %>% collect() %>% .[["N_MODERATE"]] 
nb_run_cfap43_low <- df_bigmmaf_filter_reduce %>% filter(EVIDENCE == "Low", SYMBOL == "CFAP43") %>% collect() %>% .[["N_LOW"]] 
nb_run_cfap43 <- nb_run_cfap43_high + nb_run_cfap43_moderate + nb_run_cfap43_low 
p_run_cfap43 <- (nb_run_cfap43 / nb_run_bigmmaf) %>% round(3) * 100   
  
  
nb_run_cfap44_high <- df_bigmmaf_filter_reduce %>% filter(EVIDENCE == "High", SYMBOL == "CFAP44") %>% collect() %>% .[["N_HIGH"]] 
nb_run_cfap44_moderate <- df_bigmmaf_filter_reduce %>% filter(EVIDENCE == "Moderate", SYMBOL == "CFAP44") %>% collect() %>% .[["N_MODERATE"]] 
nb_run_cfap44_low <- df_bigmmaf_filter_reduce %>% filter(EVIDENCE == "Low", SYMBOL == "CFAP44") %>% collect() %>% .[["N_LOW"]] 
nb_run_cfap44 <- nb_run_cfap44_high + nb_run_cfap44_moderate + nb_run_cfap44_low 
p_run_cfap44 <- (nb_run_cfap44 / nb_run_bigmmaf) %>% round(3) * 100   

nb_run_cfap <- df_bigmmaf_filter %>% filter(SYMBOL == "CFAP44" | SYMBOL == "CFAP43") %>% distinct(RUN) %>% nrow

```

```{r pierrerayanalysis}

# Pierre Ray 
# 
# bind_rows(df_runs %>% select(RUN = `Magic ID`, Patient) %>% filter(Patient == "BO.F") %>% inner_join(df_bigmmaf_filter),
#           df_runs %>% select(RUN = `Magic ID`, Patient) %>% filter(Patient == "BO.F") %>% inner_join(df_bigmmaf_filter_het)) %>% 
#   filter(CANONICAL == "YES") %>%
#   select(-CANONICAL) %>%
#   select(-N_VAR_PER_RUN_PER_GENE, -N_RUN_PER_GENE) %>%
#   add_exp() -> bo.f
#   write.table("~/Bureau/canonical_variants_homo_het_BO.F.csv", sep = "\t", row.names = FALSE)
# 
# plot_expression(gene = bo.f$SYMBOL %>% unique, mode = "percent", tissues = "testis", flip = TRUE)
#   


```

<!-- ### -->

Après avoir mis en évidence l'implication du gène *DNAH1* dans le phénotype MMAF notre équipe s'est en partie spécialisée dans la caractérisation ce syndrome. Ainsi, entre `r min_year` et `r max_year`, notre équipe a effectué le séquençage de `r nb_run_bigmmaf` individus présentant tous ce phénotype afin d'en établir la cause génétique. Ces séquençages ont été effectués dans `r n_center` centres différents que sont le Genoscope, Integragen, Novogene et la plateforme de séquençage de l’IGBMC de Strasbourg. La plupart de ces séquençages ont été effectués sur des Illumina HiSeq2000 sauf les `r nb_hiseq4000` plus récents qui ont été effectués sur un Illumina HiSeq4000 (**Table : **\@ref(tab:tabrunbigmmaf)).

```{r tabrunbigmmaf, cache=TRUE, dependson="dfrunbigmmaf"}

kable(df_run_bigmmaf %>% 
        mutate(Platform = paste0(Platform, " ", Model),
               Project = if_else(Project == "Strasbourg", "IGBMC", Project),
               Platform = if_else(grepl("2000?", Platform), "Illumina HiSeq2000", Platform)) %>%
        select(-Model, -PROJECT) %>%
        rename(Place = Project, Patient = RUN, Year = YEAR) %>% 
        group_by(Place, Year, Platform) %>% 
        summarise(`Nb of individuals` = n_distinct(Patient)) %>%
        arrange(Year),
      longtable = TRUE,
      booktabs = TRUE, 
      caption = "Liste des différents individus présentant un phénotype MMAF séquencé en WES") 

```

\includepdf[pages=1-61]{bib/CFAP_2017.pdf}

\newpage

#### Principaux résultats

L'application de de notre pipeline d'analyse sur les données de ces `r nb_run_bigmmaf` patients nous a permis d'obtenir une liste de `r n_distinct_var` variants distincts ayant passé l'ensemble de nos filtres (`r n_distinct_snv` SNPs et `r n_distinct_indel` indels), ceux-ci impactant un total de `r n_distinct_gene` gènes différents.  

Le gène *DNAH1* étant le candidat évident, nous avons cherché en priorité l'ensemble des variants retrouvés sur ce gène. Ainsi, nous avons obtenu une liste de 5 patients portant tous, soit au moins un variant homozygote sur le gène *DNAH1*, soit deux variants hétérozygotes sur ce même gène.  

Suite à cela, au vu du nombre important de gènes restant et afin d'étudier en priorité ceux pouvant expliquer le phénotype d'un maximum de patients nous avons limité nos recherches aux gènes sur lesquels **au moins 3 patients portaient un variant homozygote tronquant**. Cela nous a ainsi permis de mettre en évidence les gènes *CFAP43* et *CFAP44* sur lesquels des variants homozygotes ont été retrouvés chez respectivement 9 et 6 patients auxquels viennent s'ajouter 1 patient portant deux variants hétérozygotes sur le gène *CFAP43* (**Tables : **\@ref(tab:tabcfap43) et \@ref(tab:tabcfap44)). Ces deux gènes CFAP (pour *Cilia and Flagella Associated Protein*) avaient déjà été répertoriés dans les bases de données publiques comme ayant une forte expression testiculaire, et comme étant probablement impliqués dans la structure et / ou fonction du flagelle spermatique [@Ivliev2012]. De plus, ces deux gènes codent tous deux pour des protéines appartenant à la famille des WDR et comportent tous deux neuf répétitions WD (tryptophane - acide aspartique) [@Smith2008]. Ainsi, en tenant compte du nombre important de patients portant des variants sur un de ces deux gènes et le fait qu'ils codent tous deux pour des protéines appartenant à la même famille, nous avons décidé de nous concentrer dans un premiers temps sur la caractérisation de ces deux seuls gènes, ceux-ci étant les meilleurs candidats pour expliquer le phénotype d'infertilité de `r 10 + 6`  de nos patients.    

Un total de 9 a ainsi pu être identifié sur le gène *CFAP43* impactant 10 de nos patients n'ayant, à notre connaissance, aucun lien de parenté. Huit de ces variants ont un effet tronquant évident et le dernier est un variant intronique localisé 5 nucléotides après l’exon 16, non listé dans ExAC et prédit par Human Splicing Finder ([http://www.umd.be/HSF3](http://www.umd.be/HSF3)) comme altérant l'épissage de l'exon 16 de CFAP43.  

Pour *CFAP44*, 6 de nos patients portaient des variants homozygotes ayant tous un effet tronquant. 

L'analyse au microscope électronique à transmission des cellules spermatiques d'un patient portant un variant sur *CFAP43* et d'un autre portant un variant sur *CFAP44* révéla des défauts au niveau de l'axonème ainsi qu'une gaine fibreuse désorganisée pour chacun des deux patients.  

Ensuite, afin de compenser l'absence d'anticorps anti-CFAP43 et anti-CFAP44 fiables chez l'humain comme chez la souris nous avons décidé de caractériser leur orthologues chez *Trypanosoma brucei* (*T. brucei*), un protozoaire flagellé utilisé comme organisme modèle dans l'étude des flagelles chez qui, les protéines *Tb*CFAP43 et *Tb*CFAP44 respectivement orthologues de CFAP43 et CFAP44 avaient déjà été identifiées comme des protéines du flagelle [@Broadhead2006; @Subota2014]. Ensuite, l'utilisation d'ARN interférence nous a permis de produire des organismes *knock-down* pour ces deux gènes *TbCFAP43*^RAi^ et *TbCFAP44*^RNAi^ nous permettant ainsi d'évaluer la fonction de ces deux gènes au sein du flagelle du trypanosome. Cela nous a permis d'observer un arrêt de la prolifération cellulaire au bout de 24h ainsi que de nombreux défauts au niveau des flagelles pour l'ensemble des lignées cellulaires *TbCFAP43*^RAi^ et *TbCFAP44*^RNAi^. Cet arrêt de prolifération est typique des problèmes flagellaires chez le trypanosome qui dépend de son mouvement pour sa survie.  

Pour finir, l'impact de l'absence des protéines CFAP43 et 44 sur la spermatogénèse murine a été déterminé grâce à la génération de modèle KO utilisant la technologie CRISPR-Cas9 qui nous a permis d'obtenir des phénotypes reproductibles pour nos deux modèles de souris KO. Ces modèles nous ont permis d'observer que les mâles *Cfap43*^-/-^ et *Cfap44*^-/-^ présentaient tous deux de nombreuses anomalies au niveau des flagelles tandis que les femelles *Cfap43*^-/-^ et *Cfap44*^-/-^ étaient parfaitement fertiles.  

Pour conclure, cette étude portant sur la caractérisation du phénotype MMAF nous a permis d'd'identifier la cause génétique de 21 (`r ((21 / 78) * 100)%>% round(1)`%) de nos patients, ceci n'ayant aucun lien de parenté. L'utilisation de notre pipeline pour l'analyse des données NGS nous a permis à la fois de confirmer l'importance du gène *DNAH1* dans la structure du flagelle et son implication dans ce phénotype, mais aussi d'identifier deux nouveaux gènes, *CFAP43* et *CFAP44* respectivement responsables du phénotype de 10 et 6 de nos patients soit `r ((10 / 78) * 100)%>% round(1)` et `r ((6 / 78) * 100)%>% round(1)`% de notre cohorte.

```{r plottwohomohigh, cache=FALSE, fig.cap='(ref:plottwohomohigh)',fig.scap=fig_name, fig.height=6, dependson="dftwohomohigh"}
  
# fig_name <- "Listes des gènes sur lesquels un variants tronquant à l'état homozygote a été retrouvé chez au moins deux de nos patients"
# fig_description <- "La couleur des barres indique le type de variants portés par chaque patient. Vert : variant homozygote tronquant, Orange variant homozygote non tronquant et rouge au moins deux variants hétérozygotes. Les gènes sont classés dans l'ordre décroissant en fonction du nombre de variants homozygotes tronquant retrouvés parmi nos patients."
# fig_cap <- paste0("**_",fig_name,"_** : ", fig_description)
# 
# n_max <- df_bigmmaf_filter_reduce$N_TOT %>% max
# 
# ggplot(df_bigmmaf_filter_reduce, aes(reorder(reorder(reorder(SYMBOL,N_LOW), N_MODERATE), N_HIGH), N_RUN)) + 
#   geom_col(aes(fill = EVIDENCE)) +
#   scale_fill_manual(name = "Kind of variant", 
#                     values = c("#4DAF4A", "#FF7F00", "#E41A1C"),
#                     labels=c("Truncated homozygous", "Not truncated homozygous", "compound heterozygous?")) + 
#   scale_y_continuous(breaks = (1:n_max)) +
#   ylab("Nb of individuals") + 
#   xlab("") +  
#   coord_flip()  + 
#   theme(legend.position = "bottom")

# (ref:plottwohomohigh) `r fig_cap`

```




