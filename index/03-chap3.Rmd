---
output:
  word_document: default
  html_document: default
  pdf_document: default
  classoption: landscape
---
# Mise en place d’une stratégie pour l’analyse des données exomiques – application en recherche clinique  

```{r include.packages2, include=FALSE}
# This chunk ensures that the thesisdown package is
# installed and loaded. This thesisdown package includes
# the template files for the thesis.

if(!require(devtools))
  install.packages("devtools", repos = "http://cran.rstudio.com")

if(!require(bookdown))
  devtools::install_github('rstudio/bookdown')

if(!require(thesisdown))
  devtools::install_github("ismayc/thesisdown")

if(!require(kableExtra))
devtools::install_github("haozhu233/kableExtra")

library(thesisdown)
library(pander)
library(knitr)
library(tidyr)
library(dplyr)
library(data.table)
library(ggplot2)
library(stringi)
library(scales)
library(cowplot)
library(stringr)
library(foreach) 
library(viridis)
library(kableExtra)

theme_set(theme_gray()) # otherwise use cowplot default theme

source("script/manage_variants.R")
source("script/variant_filtering.R")
source("script/resume_data.R")
source("script/plot_vep_results.R")
source("script/gene_expression.R")

opts_knit$set(eval.after = c("fig.cap","fig.scap"))

knitr::opts_chunk$set(fig.align='center',echo=FALSE)

```

```{r localfunction, cache=TRUE}

open_ctrl <- function(file=NULL, pheno = "none", df=NULL) {
  
  if(is.null(df)) df <- fread(file, sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE)
  
  df %>%
    gather(RUN, CALL, starts_with("Ghs")) %>% 
    gather(RUN, CALL, starts_with("1")) %>% 
    
    filter(CALL %in% c(3, "c")) %>%
    mutate(N_CTRL = n_distinct(RUN),
           PHENO = pheno,
           CHR = as.character(CHR))  %>%
    select(-CALL) %>% 
    distinct(CHR, POSITION, REF, ALT, N_CTRL, PHENO)
}

`%tin%` <- function(x, y) {
    mapply(assign, as.character(substitute(x)[-1]), y,
      MoreArgs = list(envir = parent.frame()))
    invisible()
}

tab_gene <- function(df, gene) {
  
  tab_gene <- df %>% 
    filter(SYMBOL == gene) %>% 
    mutate(VARIANT = paste(CHR,POSITION,REF,ALT, sep = "-"),
           Consequence = sapply(strsplit(Consequence, "_variant", fixed = TRUE),"[[",1),
           Consequence = gsub("_", " ", Consequence)) %>%
    distinct(RUN, VARIANT, CALL, Consequence, SYMBOL) %>% 
    arrange(desc(CALL), RUN)
  
  run_homo <- tab_gene %>% filter(CALL == "Homozygous") %>% ungroup() %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
  run_het <- tab_gene %>% filter(CALL == "Heterozygous") %>% ungroup() %>% distinct(RUN) %>% collect() %>% .[["RUN"]]

  n_run_homo <- run_homo %>% length
  n_run_het <- run_het %>% length
  list(tab_gene, run_homo, run_het, n_run_homo, n_run_het)
}

na.replace <- function (x, char = "") {
    x[is.na(x)] <- char
    return(x)
}

plot_resume_analysis <- function(df) {
  
  
  levels <- c("High","Moderate","Low")
  
  df <- df %>% 
    mutate(TRUST = factor(TRUST, levels = levels))
  
  n_distinct_gene <- df %>% ungroup() %>% distinct(SYMBOL) %>% nrow
  
  if (n_distinct_gene == 1) {
  
  break_max <- df$N_RUN %>% max
  
  p <- ggplot(df, aes(TRUST, N_RUN)) +
    facet_wrap(~SYMBOL) 
    
  } else {
    
    break_max <- df$TOT %>% max
  
    p <- ggplot(df, aes(reorder(SYMBOL, -TOT), N_RUN)) 
  
    }
  
  p + geom_col(aes(fill = TRUST)) + 
    scale_fill_manual(guide = "none", limits = c("High","Moderate","Low"), values = c("#4DAF4A","#FF7F00","#E41A1C")) + 
    scale_y_continuous(breaks = c(0:break_max)) +
    ylab("Nb of individuals") + 
    xlab("")
  
}

tab_high <- function(df, caption = "", evidence = TRUE, landscape = FALSE) {

  df <- df %>% 
    ungroup() %>% 
    filter(CANONICAL == "YES") %>%
    mutate(HGVSc = na.replace(HGVSc, "."),
           HGVSp = na.replace(HGVSp, "."),
           `HGVSc, HGVSp` = paste0(HGVSc," ; ", HGVSp)) %>%
    select(Patient = RUN, Gene = SYMBOL, Evidence = EVIDENCE, `HGVSc, HGVSp`, Consequence, ESP, `1KG`, ExAC = ExAC_AF) %>%
    arrange(Gene) %>% 
    mutate(ESP = na.replace(ESP, "."),
           `1KG` = na.replace(`1KG`, "."),
           ExAC = na.replace(ExAC, "."))
  
  if(evidence == FALSE) df <- df %>% select(-Evidence)
  
  kdf <- df %>% kable(format = "latex",
                      booktabs = TRUE,
                      longtable = TRUE,
                      caption = caption) %>%
    add_header_above(c(rep(" ", ncol(df) - 5), "Variant impact" = 2, "Variant frequency" = 3))

  
    if (landscape == TRUE) kdf <- kdf %>% landscape(margin = NULL)

  kdf
  
}

tab_modelow <- function(df, caption = "", landscape = FALSE) {
  
  kdf <- df %>% 
    ungroup() %>%
    filter(CANONICAL == "YES") %>%
    mutate(HGVSc = na.replace(HGVSc, "."),
           HGVSp = na.replace(HGVSp, "."),
           `HGVSc, HGVSp` = paste0(HGVSc," ; ", HGVSp)) %>%

    select(Patient = RUN, Gene = SYMBOL, `HGVSc, HGVSp`, Consequence, SIFT, PolyPhen, ESP, `1KG`, ExAC = ExAC_AF) %>%
    distinct() %>% 
    mutate(ESP = na.replace(ESP, "."),
           `1KG` = na.replace(`1KG`, "."),
           ExAC = na.replace(ExAC, "."),
           SIFT = na.replace(SIFT, "."),
           SIFT = gsub(" low confidence", "", SIFT),
           PolyPhen = na.replace(PolyPhen, "."),
           PolyPhen = gsub("probably", "proba", PolyPhen),
           PolyPhen = gsub("possibly", "possib", PolyPhen)) %>%
    kable(format = "latex",
          booktabs = TRUE,
          longtable = TRUE,
          caption = caption) %>%
    add_header_above(c(" ", " ", "Variant impact" = 4, "Variant frequency" = 3))
  
  if (landscape == TRUE) kdf <- kdf %>% landscape(margin = NULL)

  kdf

}

paste_vector <- function(v, style = "none", sep = ", ", last = " et ", sort = TRUE) {
  
  if (sort == TRUE) v <- v %>% sort
  
  if (style == "bold") v <- paste0("**",v,"**")
  if (style == "itallic") v <- paste0("*",v,"*")
  if (style == "both") v <- paste0("**_",v,"_**")

  v_head <- v %>% head(-1) %>% paste(collapse = sep)
  
  v_tail <- v %>% tail(1)
  
  paste(v_head, last , v_tail)
}

gene_to_run <- function(df, genes) {
  
  df %>% 
    ungroup() %>% 
    filter(SYMBOL %in% genes) %>% 
    distinct(RUN) %>% 
    collect() %>%
    .[["RUN"]]
  
}

```

```{r callfunction, cache=TRUE}

call_to_strand <- function(call) {
  
  in_ds <- c(1:9)
  in_ss <- letters
  in_ns <- 0
  
  out_ds <- rep("DS", length(in_ds))
  out_ss <- rep("SS", length(in_ss))
  out_ns <- rep("NS", length(in_ns))
  
  ca <- c(1,3,4,5,0,"a","b")
  
  plyr::mapvalues(call, from = c(in_ds,in_ss,in_ns), to = c(out_ds, out_ss, out_ns), warn_missing = FALSE)
  
}

call_to_geno <- function(call) {

  in_ref <- c(1, "a")
  in_homo <- c(3, "c")
  in_het <- c(2, "b")
  in_none <- 0
  in_ambi <- c(4:7,"d","e","f","g","h","i")
  in_disc <- c(8,9)
  
  out_ref <- rep("Reference", length(in_ref))
  out_homo <- rep("Homozygous", length(in_homo))
  out_het <- rep("Heterozygous", length(in_homo))
  out_none <- rep("None", length(in_none))
  out_ambi <- rep("Ambigous", length(in_ambi))
  out_disc <- rep("Discordant", length(in_disc))
  
  plyr::mapvalues(call, 
                  from = c(in_ref, in_homo, in_het, in_none, in_ambi, in_disc), 
                  to = c(out_ref, out_homo, out_het, out_none, out_ambi, out_disc), 
                  warn_missing = FALSE)

}

var_type <- function (ref, alt) {
  
  vapply(stri_length(ref) == stri_length(alt), function(x) if(isTRUE(x)) "SNV" else "Indel", character(1))
  
}

var_call <- function(file) {
  
  fread(paste("zcat ", file), sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, data.table = FALSE) %>% 
    gather(RUN, CALL, starts_with("Ghs")) %>% 
    filter(!(CALL %in% c("*", "a", 1))) %>%
    mutate(TYPE = var_type(REF, ALT),
           STRAND = call_to_strand(CALL),
           CALL = call_to_geno(CALL))
  
}


define_ctrl_var <- function(ctrls, removed_genotypes = "homo", file = "data/call_results/others_novogen_integragen_var_genotype.csv") {
  
  if (removed_genotypes == "homo") {
    
    removed_call <- c(3, "c")
    
  }
  
  fread(file, sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, data.table = FALSE) %>% 
  select(CHR, POSITION, REF, ALT, one_of(ctrls)) %>% 
  gather(RUN, CALL, -(CHR:ALT)) %>% 
  filter(CALL %in% removed_call,
         !is.na(REF)) %>%
    distinct(CHR, POSITION, REF, ALT)
}


```

\newpage

En 2011, les bases moléculaires d'environ 3700 pathologies à transmission Mendélienne avaient été élucidées. Cependant, pour une quantité équivalente de pathologies Mendéliennes (ou suspectées de l'être) cette cause reste un mystère [@Amberger2011]. Avec plusieurs centaines de pathologies caractérisées depuis 2010 [@Ng], les séquençages WGS et WES ont, depuis leur émergence, révolutionnés les méthodes de recherche dans le cadre d'étude phénotype-génotype en permettant de manière rapide et à moindre coup le séquençage de la quasi-totalité des gènes humains. Dès lors, le défis de ces analyses n'est plus le séquençage de l'ADN mais l'interprétation des données massives produites. En effet, l'un des plus grands challenges des analyses phénotype-génotype réalisées par WES réside dans l'analyse de l'importante quantité de variant portés par chaque individu s'élevant à plusieurs dizaines de milliers lorsque l'on  compare avec le génome de référence. Même après avoir retiré les variants retrouvés fréquemment dans la population générale, des méthodes additionnelles sont nécessaires pour prédire, parmi les variants restant, lesquels induisent des conséquences fonctionnelles sérieuses afin de les prioriser [@Pelak2010]. De nombreux logiciels tel que Variant Effect Predictor [@McLaren2016], SnpEff [@Cingolani2012] ou encore ANNOVAR [@Wang2010] permettent d'identifier quels sont les variants qui ont un effet tronquant sur la protéine. Cependant, avec en moyenne 165 variants homozygotes ayant un effet tronquant retrouvés dans chaque exomes [@Pelak2010] ces méthodes, bien qu'efficaces sont souvent insuffisantes.   

D'autres logiciels tel que Exomiser [@Robinson2014] vont, à partir d'une liste de variants **déjà** appelés effectuer les étapes d'annotation, de filtrage et de priorisation. Malgré l'efficacité de ces logiciels, aucun d'entre eux ne couvrent l'ensemble des étapes allant de l'alignement des *reads* à la priorisation des variants. La plupart ayant pour point de départ une liste de variants appelés en amont. Ils ne contrôlent donc en aucune manière les étapes d'alignement et d'appel des variants. Or, comme il a été dit plus tôt, ces deux étapes constituent la base de l'analyse. 

Ce chapitre décrit à la fois la constitution d’un pipeline d’analyse des données de séquençage exomique recouvrant l'ensemble des étapes allant de l'allignement des séquences à la priorisation des variants ainsi que son utilisation dans le cadre de la recherche de mutations entrainant différents phénotypes d’infertilité d'une part de cas familiaux et, pour finir, d'une large cohorte d'individus non apparentés présentant tous le même phénotype.  

\newpage

## Méthode : Description du pipeline

### L'alignement des *reads*  

Comme expliqué plus tôt, l'étape d'alignement à pour objectif de repositioner l'ensemble des *reads* d'un individu le long d'un génome de référence. Cette étape peut ainsi être comparée à la reconstruction d'un puzzle dans lequel chaque *reads* peut-être assimilé à l'une des pièces tandis que le génome de référence serait ici le modèle (**Figure : **\@ref(fig:picdnamapping)).  

L'ensemble de nos exomes ayant été réalisés en *paired-end*, les deux extrémités de chaque fragment sont séquencées. Chaque *end* d'un même *read* peut donc être considérée comme un *read* à part entière qui sont alignées **indépendamment** le long du génome de référence. L'information fournit par le *paired-end* n'étant utilisé qu'à *posteriori* en tant que critère qualité. Au sein de notre pipeline, cette étape est effectué par le logiciel MAGIC [@Su2014] qui dans le cadre de nos études, s'est basé sur la version hg19 / GHRC37 du génome de référence. Suite à cet alignement, plusieurs critères sont observés afin de filtrer les *reads* présentant une faible qualité d'alignement.  

Ainsi, le premier de ces filtres consiste à tout d'abord filtrer l'ensemble des *reads* dupliqués, c'est à dire les *reads* ayant des séquences parfaitement identiques, ceux-ci étant souvent le résultats d'un excès d'amplification au moment des PCRs effectuées en amont. De la même manière, afin d'éviter toute ambiguité au momen de l'interprétation des résultats, l'ensemble des *reads* s'étant alignés sur plusieurs région du génome sont aussi filtrés. Une fois cela fait, nous vérifions la "compatibilité" des deux *ends* composant chacun des *reads* restant. Un *reads* est dit compatible lorsque les deux *ends* qui le composent s'alignent face à face (une sur le brin sens du génome de référence et l'autre sur le brin anti-sens) et couvrent une zone ne faisant pas plus de 3 fois la taille médiane de l'insert. Les *reads* dont les deux *ends* se sont alignées mais ne remplissant pas ces conditions seront dit "Non compatible", ceux dont une seule des deux *ends* s'est alignés seront appelés "orphelins" et enfin ceux pour lesquels aucune des deux *ends* ne se sont allignées sont appellés "non-aligné". L'ensemble des *reads* "non-compatible", "orphelins" et "non-alignés" sont, en raison de leur faible qualité, filtré et donc non considérés pour les analyses en aval. Les *reads* ayant passé l'ensemble des critères qualité mentionnés précédemment seront, eux, utilisés pour effectuer l'appel des variants.     

\newpage

### L'appel des variants  


Si l'allignement des séquences peut être comparé à la reconstruction d'un puzzle, l'appel des variant pourrait lui être vu comme un jeu des 7 erreurs, au cours duquel, pour chaque position couverte, les différences entre la séquence de l'individu séquencé et le génome de référence seront listées et appelées variants. Comme nous l'avons vu plus [tôt](#varcall), il est fortement conseillé d'effectuer l'appel des variants en tenant compte de l'aligneur choisi [@Nielsen2011; @DePristo2011; @Lunter2011]. C'est pourquoi, nous avons développé notre propre algorithme d'appel des variants spécialement conçu pour l'analyse des données de MAGIC. Ainsi, l'appel des variants sera directement basé sur quatre comptages (R$_+$, R$_-$, V$_+$ et V$_-$) fourni directement par MAGIC pour chaque position suffisement couvertes :  

1. **R**$_+$ **et R**$_-$ : Ces deux comptages correspondent au nombre de *reads* *forward* (+) et *reverse* (-) sur lesquels est observé l'allèle de **référence** (R) à une position donnée.  
2. **V**$_+$ **et V**$_-$ : À l'inverse de R$_+$ et R$_-$, ces comptages correspondent au nombre de *reads* *forward* et *reverse* sur lesquels est observé un allèle de **variant** (V) à une position donnée.  

Ainsi, les sommes : $R_+ + V_+$ et $R_- + V_-$ indiqueront respectivement la couverture d'une position en ne tenant que des *reads forward* et *reverse*. En fonction de ces couverturs nos appels seront classés en trois catégories : 

1. **Les appels *double strand* (DS) :**  Qualifie les positions ayant une couverture $\ge$ 10 sur **les deux** strands. Ces appels sont ceux sont ceux ayant la meilleure qualité.  
2. **Les appels *single strand* (SS) :**  Ces appels définissent les positions pour lesquels **un des deux** *strands* présentent une couverture $\le$ 10. Dans ce cas, ce *strand* est ignoré et l'appel est effectué uniquement en utilisant le second *strand*.   
3. **Les appels *non strand* (NS) :** Les positions NS sont celles pour lesquelles la couverture est $\le$ 10 sur **les deux** strands. Aucun appel n'est effectué à ces positions qui **ne sont pas conservés dans la suite des analyses**.    

Ensuite, chaque position couverte, des appels indépendants seront effectués pour chaque *strand* de telle sorte que, pour chaqune de ces position si : 

1. 0 à 20% des *reads* portent un variant, la position est appelée **homozygote référence**.  
2. 40 à 75% des *reads* portent un variant, la position est appelée **hétérozygote**.  
3. 85 à 100% des *reads* portent un variant, la position est appelée **homozygote variant**.  
4. 20 à 40% des *reads* portent un variant, l'appel sera considéré comme **ambigu bas**.  
5. 75 à 85% des *reads* portent un variant, l'appel sera considéré comme **ambigu haut**.  

Pour les positions SS, l'appel final coresspondra directement à l'appel effectué sur l'unique *strand* suffisemment couvert. Pour les positions DS, la concordance des appels fournis par chaque *end* est verifié. Ainsi, un variant sera considéré :

1. **Homozygote référence** si les deux appels sont homozygote référence, ou, un des appels est homozygote référence et l'autre ambigu bas.
2. **Hétérozygote** si les deux appels sont hétérozygotes, ou, si l'un des appels est hétérozygote et l'autre ambigu bas ou haut.  
3. **Homozygote variant** si les deux appels sont homozygote variant, ou, un des appels est homozygote variant et l'autre ambigu haut
5. **Ambigu** si les deux appels sont ambigu bas ou si ils sont tous les deux ambigu haut.  
4. **Discordant** pour toutes les combinaisons restantes.  

Dans le cadre de nos analyses, les appels ambigu et discordant sont filtrés.  

\newpage

### L'annotation  

Chaque variant retenu sera ensuite annoté tout d'abord par le logiciel *variant effect predictor* (VEP) [@McLaren2016] qui nous indiquera pour chaque variant la conséquence que celui-ci aura sur la séquence codante de l'ensemble des transcrits Ensembl qu'il chevauche (**Figure : **\@ref(fig:figvepcsq), **Table : **\@ref(tab:tabvepcsq)). Dans le cas de substitution faux-sens, c'est à dire entrainant le changement d'un seul acide-aminé de la séquence protéique, nous utiliserons les prédictions fournies par SIFT et PolyPhen afin d'estimer leur pathogénicité. Ensuite, nous ajoutons, pour chaque gène, son expression tissulaire en nous basant sur les données Ensembl [@Aken2017] générées par le projet Illumina BodyMap qui recense les données RNAseq des gènes humains pour 16 tissus différents. Suite à cela nous ajoutons, lorsque celle-ci est disponible, la fréquence du variant dans les bases de données ExAC [@Lek2016], ESP600 ([Exome Variant Server, NHLBI GO Exome Sequencing Project (ESP), Seattle, WA](http://evs.gs.washington.edu/EVS/)) et 1000Genomes [@1000GenomesProjectConsortium2015] donnant ainsi une estimation de sa fréquence dans la population générale. De même, la particularité de ce pipeline est qu'elle conserve l'ensemble des variants identifiés dans les études effectuées précédemment permettant d'ajouter aux annotations la fréquence d'un variant chez les individus déjà séquencé et donc la fréquence d'un variant dans chaque phénotype étudié créant ainsi une base de données interne qui pourra servir de contrôle dans les études ultérieur.    

```{r figvepcsq, fig.cap=fig_info,fig.scap=fig_name, out.extra="scale=.9"}

fig_name <- "Listes des différentes conséquences prédites par VEP et leur positionnement sur le transcrit"
fig_description <- ""
fig_from <- "[VEP site](http://www.ensembl.org/info/genome/variation/consequences.jpg)"
fig_info <- paste0(fig_name," d'après ",fig_from)

include_graphics(path = "figure/vep_csq.jpg")

```

\newpage
\blandscape

```{r tabvepcsq}

tab_name <- ""


df_vep_csq <-  fread("data/vep_csq_modif.csv", sep = "\t", header = TRUE, showProgress = FALSE, data.table = FALSE, verbose = FALSE) %>%
  select(`VEP consequence` = `Display term`,
         `VEP impact` = IMPACT,
         Description = `SO description`)

# kable(df_vep_csq,
#       format = "latex",
#       longtable = TRUE) %>%
#   column_spec(3, width = "11em" ) %>%
#   landscape() 

pander(df_vep_csq,
               justify = 'left',
               split.cells = c(.5,1,50),
               caption = "(\\#tab:tabvepcsq) Liste simplifiée des conséquences prédites par VEP avec leur description et impact associée")

```

\elandscape
\newpage

### Le filtrage des variants  

```{r}

maf_cutoff <- .01

```


L'étape de filtrage est extrêmement importante si l'on souhaite analyser de manière efficace les données provenant de WES. C'est pourquoi elle occupe une place importante dans notre pipeline. L'intégralité des paramètres de cette étape peuvent être modifiés par l'utilisateur de sorte à faire correspondre les critères de filtre aux besoins de l'étude. Afin de rendre son utilisation le plus efficace possible, nous avons souhaité définir des paramètres par défauts pertinent dans la plupart des études de séquençage exomique de sorte que à moins que le contraire ne soit spécifié les filtres suivant seront appliqués : 

1. **Filtre 1 : L'union des variants :** Dans le cas ou des individus présentant un lien de parenté et présentant le même phénotype sont analysé, seuls les variants observés chez l'ensemble des individus sont conservés.        

2. **Filtre 2 : Génotype des variants :**  Ce pipeline d'analyse a avant tout été développé pour la recherche de variant impliqué dans des pathologies à transmission récessives. C'est pourquoi, dans le cadre d'étude d'individus présentant un historique de consanguinité, l'ensemble des variants hétérozygotes sont filtrés. En revanche, dans le cas d'individus issus d'unions non consanguin nous procédons à la recherches de variants hétérozygotes composites, c'est à dire **au moins deux variants hétérozygotes différents situés sur chacun des deux allèles du même gène d'un patient**. Dès lors, bien que les variants soient différents, les deux allèles sont altérés rendant posiible l'apparition de phénotype récessifs. Malheureusement, dans le cadre des séquençages WES et WGS, il est impossible de connaitre le "phasage" de ces variants, c'est à dire que l'on ne peut déterminer si deux variants hétérozygotes sont situés sur le même allèles ou sur deux allèles différents (**Figure : **\@ref(fig:compositehet)). Pour cela, des analyses de biologie moléculaire sont nécessaires.  

\newpage

```{r piccompositehet,fig.cap=fig_info,fig.scap=fig_name, out.extra="scale=0.35"}

fig_name <- "Représentation schématique des phasages de deux variants avec les génotypes associés"
fig_description <- "Un variant est dit homozygote lorsque le **même** variant est présents sur les deux allèles d'un gène et hétérozygote lorsqu'il est présent sur **un seul** des deux allèles. On parlera d'hétérozygotes *cis* lorsque deux variants hétérozygotes différents seront positionnés sur **le même** allèle et d'hétérozygote *trans* (ou composite) lorsque ces deux variants hétérozygotes seront positionnés sur **deux allèles différents**. En WES et en WGS il est impossible de différentié les hétérozygotes *cis* des hétérozygotes *trans*"
fig_info <- paste(fig_name, fig_description, sep = " : ")

include_graphics("figure/hetero_composites.png")

```

3. **Filtre 3 : Les transcrits "non pertinents" :** Au cours de nos analyses nous nous sommes concentré uniquement sur les transcrits codant pour une protéine. Ainsi, l'ensemble des transcrits annotés comme étant non codant furent filtrés. De même  pour les transcrits annotés comme étant NMD (*nonsense-mediated decay*). En effet, ce mécanisme a pour but de contrôler la qualité des ARNm cellulaires chez les eucaryotes [@Chang2007] en éliminant les ARNm qui comportent un codon stop prématuré [@Baker2004], pouvant être le résultat d'une erreur de transcription, d'une mutation ou encore d'une erreur d'épissage. Il est donc peu probable que les variants présents sur des transcrits annotés NMD soient responsables du phénotype. Dès lors, ces transcrits ont été également filtrés. Ainsi, l'ensemble des variants impactant **uniquement** des transcrits non codant et / ou annoté NMD sont filtrés. 

4. **Filtre 4 : Impact du variant :** Afin de ne conserver que les variants ayant le plus probablement délétère sur la protéine, seuls sont conservés ceux impactant la séquence codante d'un transcrit. De plus les variants synonymes ne sont pas conservés (exceptés ceux se trouvant proches des régions d'épissage) car ceux-ci n'ont aucun effet sur la séquence protéique. Pour les variants faux sens (changement d'un seul acide-aminé de la séquence protéique) il est plus difficile de se trancher, dès lors, seuls ceux étant prédit comme *tolerated*  par SIFT [@Kumar2009] **et** comme *benign* par Polyphen [@Adzhubei2010] sont filtrés.  

5. **Filtre 5 : Fréquence des variants :**  La fréquence d'un variant dans la population générale est un moyen rapide d'avoir une prédiction fiable de l'effet délétère ou non de celui-ci. En effet, il est peu probable qu'un variant retrouvé fréquemment dans la population générale soit causal d'une pathologie sévère. C'est pourquoi, l'ensemble des variants ayant une fréquence $\ge$ `r maf_cutoff * 100`% dans l'une des trois bases de données que sont ExAC, ESP et 1KG sont filtrés.    

6. **Filtre 6 : Présence des variants dans la cohorte contrôle :** Au sien de notre pipeline, les données de l'ensemble des patients analysés dans les études anterieures sont conservés créant ainsi une base de donnée interne de variants. Dès lors, il devient possible d'utiliser chacun de ces patient comme contrôle lorsqu'ils ne sont pas porteur du même phénotype que celui des patients des études ulterieures. Ce filtre se révèle particulièrement intéréssant lorsque plusieurs patients porteurs de phénotypes différents ont subi le même protocole de séquençage ainsi l'ensemble des variants faux-positifs résultant d'artéfact liés au différentes étapes en amont de l'analyse bioinformatique pourront alors être filtré. De même ce filtre permet de mettre en évidence les variants propores à une population lorsque des patients provenant de la même région géographique et ne présentant toujours pas le même phénotype sont comparés.    

\newpage

## Résultats 1 : Analyse de 3 phénotypes par des cas familliaux  

```{r dfrunfam, cache=TRUE}

run_fam_az <- c("Ghs44", "Ghs45")
run_fam_ff <- c("Ghs113", "Ghs117")

run_fam_mmaf1 <- c("Ghs56", "Ghs58")
run_fam_mmaf2 <- c("Ghs59", "Ghs60")
run_fam_mmaf3 <- c("Ghs62", "Ghs130")
run_fam_mmaf4 <- c("Ghs119", "Ghs63")
run_fam_mmaf5 <- c("Ghs131")

run_fam_mmaf_all <- c(run_fam_mmaf1, run_fam_mmaf2, run_fam_mmaf3,
                 run_fam_mmaf4, run_fam_mmaf5)

run_fam_all <- c(run_fam_az, run_fam_ff, run_fam_mmaf_all)

df_fam_run <- data_frame(FAM = c("AZ","AZ","FF","FF","MMAF1","MMAF1","MMAF2","MMAF2","MMAF3","MMAF3","MMAF4","MMAF4","MMAF5"),
                     RUN = c(run_fam_az, run_fam_ff, run_fam_mmaf_all),
                     PHENOTYPE = c(rep("Azoospermia", 2), rep("Fertilization failure", 2),  rep("MMAF", 9)),
                     YEAR = c(2012, 2012,rep(2014, 11)),
                     # PLATFORM = c("Illumina HiSeq2000", "Illumina HiSeq2000", "Illumina HiSeq2000"),
                     PLACE = c(rep("Mount Sinai Institut", 2), rep("Genoscope (Evry)", 11)))

df_fam <- df_fam_run %>% 
  group_by(FAM, PHENOTYPE, YEAR, PLACE) %>%
  summarise(RUN = paste(RUN, collapse = ", ")) %>% 
  select(FAM, RUN, PHENOTYPE, YEAR, PLACE)

```

```{r varrunfam, cache=TRUE, dependson="dfrunfam"}

nb_fam <- df_fam %>% nrow
nb_pheno <- df_fam %>% summarise(N_PHENO = n_distinct(PHENOTYPE)) %>% collect() %>% .[["N_PHENO"]] 
min_year <- df_fam$YEAR %>% min
max_year <- df_fam$YEAR %>% max
nb_fam_run <- run_fam_all %>% length

```

Dans cette partie, se concentre sur l'analyse bioinformatique des résultats des séquençages exomiques de `r nb_fam_run` individus infertiles provenant de `r nb_fam` familles et présentant toutes un phénotype d'infertilité masculine différenteffectués entre `r min_year` et `r max_year` \@ref(tab:tabfam) :   

1. **Famille FAM** : Cette famille est composée de `r run_fam_az %>% length` frères azoospermes. Comme nous avons pu le voir, l'azoospermie est un phénotype d'infertilité masculine caractérisé par l'absence de spermatozoïde dans l’éjaculât. Des `r nb_fam_run` patients de cette étude, les frères `r run_fam_az %>% paste_vector` sont les deux seuls à ne pas avoir été séquencés au Génopole d'Évry.       
2. **Famille FF** :  Les spermatozoïdes des `r run_fam_ff %>% length` frères de cette famille sont caractérisés par leur incapacité à féconder l'ovocyte malgré leur morphologie et leur mibilité normales.  
3. **Famille MMAF** :  Le syndrome MMAF (*multiple morphological abnormalities of the sperm flagella*) dont souffrent les frères de cette famille se caractérise comme son nom l'indique, par la présence d'une majorité de spermatozoïdes présentant par une mosaïque d'anomalie morphologique du flagelle.   

```{r tabfam, cache=TRUE, dependson="dfrunfam"}

tab.name <- "Tableau récapitulatif des familles séquencées et de leur phénotype"

kable(df_fam,
      format = "latex",
      col.names = c("Family", "Individuals","Phenotype","Year", "Place"),
      caption = tab.name,
      longtable = TRUE,
      booktabs = TRUE)

```

\newpage 

### Résultats des différents étapes de l'analyse  

<!-- MAPPING -->

```{r dffammapping, dependson="dfrunfam", warning=FALSE, cache=TRUE}

df_read_fate_nb <- fread("data/magic_results/All_Exomes.read_fate.txt", sep = "\t", data.table = FALSE, header = TRUE, drop = c(1,3:5,7:23)) %>% 
    select(-contains("entropy"), -contains("but"), -contains("insert")) %>% 
  rename(RUN = `# Run`,
         `Map to 1 site` = `% reads, mapping uniquely to 1 genomic site and maximum 1 gene`,
         S2 = `% reads, mapping to 2 to 9 sites`,
         S10 = `% Rejected because they map to 10 or more`) %>% 
  filter(RUN != "All runs") %>%
  mutate(`Map to 2 or more sites`  = S2 + S10) %>% 
  select(-S2, -S10) %>% 
  filter(RUN %in% run_fam_all) %>% 
  gather(QUALITY, NB_OF_READS, `Raw reads`:`Map to 2 or more sites`)

pair_stat <- fread("data/magic_results/All_Exomes.pair_stats.txt", sep = "\t", data.table = FALSE, skip = 42, header = FALSE) %>% transpose() 
names(pair_stat) <- pair_stat[1,] 

pair_stat <- pair_stat %>%
  filter(Run %in% run_fam_all) %>% 
  select(RUN = Run, Compatible_pairs, Non_compatible_pairs, `Orphans Any`) %>% 
  rename(`Compatible` = Compatible_pairs,
         `Non compatible` = Non_compatible_pairs,
         Orphans = `Orphans Any`) %>%
  gather(QUALITY, NB_OF_READS, Compatible:Orphans) %>%
  mutate(NB_OF_READS = as.numeric(NB_OF_READS)) 

df_reads_summary <- rbind(df_read_fate_nb, pair_stat) %>% 
  mutate(IS_RETAINED = if_else((QUALITY == "Raw reads" |
                                   QUALITY == "% Well mapped" |
                                   QUALITY == "Compatible" |
                                   QUALITY == "Map to 1 site"), "Yes", "No" ),
         NB_OF_READS = if_else(QUALITY == "Raw reads", NB_OF_READS, NB_OF_READS / 100)) %>% 
  left_join(df_fam_run, by = "RUN") %>% 
  select(-(PHENOTYPE:PLACE))




```

```{r varfammapping, dependson="dffammapping", cache=TRUE}

raw_reads_median <- df_reads_summary %>% filter(QUALITY == "Raw reads") %>% collect() %>% .[["NB_OF_READS"]] %>% median %>% as.integer
unmap_reads_min <- df_reads_summary %>% filter(QUALITY == "% Unmapped") %>% collect() %>% .[["NB_OF_READS"]] %>% min %>% round(3) * 100
unmap_reads_max <- df_reads_summary %>% filter(QUALITY == "% Unmapped") %>% collect() %>% .[["NB_OF_READS"]] %>% max %>% round(3) * 100

max_site_1 <- df_reads_summary %>% filter(QUALITY == "Map to 1 site") %>% collect() %>% .[["NB_OF_READS"]] %>% max %>% round(3) * 100
min_site_1 <- df_reads_summary %>% filter(QUALITY == "Map to 1 site") %>% collect() %>% .[["NB_OF_READS"]] %>% min %>% round(3) * 100


comp_reads_median <- df_reads_summary %>% filter(QUALITY == "Compatible") %>% collect() %>% .[["NB_OF_READS"]] %>% median %>% round(3) * 100

```

<!-- CALL -->

```{r dfvarcall, cache=TRUE} 

# IF I want to view the methode for all sample 
# (not only fam), replace file by a cat of all
# Genotype file 
df_fam_call <- var_call("data/call_results/call_fam.csv.gz")

df_strand_all <- df_fam_call %>%
  select(RUN, STRAND) %>% 
  group_by(RUN, STRAND) %>%
  summarise(N = n()) %>%
  group_by(RUN) %>%
  mutate(P = N / sum(N),
         IS_RETAINED = if_else(STRAND == "NS","No",
                               if_else(STRAND == "DS", "Yes", "Yes but low quality")))
     
df_concordance_all <- df_fam_call %>%
  select(RUN, CALL, STRAND) %>%
  filter(STRAND == "DS") %>% 
  mutate(CALL = if_else(grepl("zygous", CALL), "Concordant", CALL)) %>%
  group_by(RUN, CALL) %>%
  summarise(N = n()) %>%
  group_by(RUN) %>%
  mutate(P = N / sum(N),
         IS_RETAINED = if_else(CALL == "Concordant","Yes","No"))

df_geno_all <- df_fam_call %>%
  select(RUN, CALL, TYPE) %>%
  filter(grepl("zygous", CALL)) %>% 
  group_by(RUN, CALL, TYPE) %>%
  summarise(N = n()) %>% 
  group_by(RUN) %>%
  mutate(P = N / sum(N),
         IS_RETAINED = if_else(grepl("zygous", CALL),"Yes","No")) %>%
  bind_rows(data_frame(RUN = "Ghs113", CALL = "Heterozygous", TYPE = "Indel", N = 0, P = 0, IS_RETAINED = "No")) %>% # it permits to have the "no" field in the legend of the barplot
  bind_rows(data_frame(RUN = "Ghs113", CALL = "Heterozygous", TYPE = "Indel", N = 0, P = 0, IS_RETAINED = "Yes but low quality")) 

```

```{r varvarcall, cache=TRUE, dependson="dfvarcall"}

median_percent_ss <- df_strand_all %>% filter(STRAND == "SS") %>% collect() %>% .[["P"]] %>% median %>% round(3) * 100 
median_percent_ds <- df_strand_all %>% filter(STRAND == "DS") %>% collect() %>% .[["P"]] %>% median %>% round(3) * 100 

min_percent_ns <- df_strand_all %>% filter(STRAND == "NS") %>% collect() %>% .[["P"]] %>% min %>% round(3) * 100
max_percent_ns <- df_strand_all %>% filter(STRAND == "NS") %>% collect() %>% .[["P"]] %>% max %>% round(3) * 100


concordant_median <- df_concordance_all %>% ungroup() %>% filter(CALL == "Concordant call") %>% collect() %>% .[["P"]] %>% median %>% round(3) * 100
wrong_median <- 100 - concordant_median

median_het_snv <- df_geno_all %>% filter(TYPE == "SNV" & CALL == "Heterozygous") %>% collect() %>% .[["N"]] %>% median %>% as.integer
median_het_indel <- df_geno_all %>% filter(TYPE == "Indel" & CALL == "Heterozygous") %>% collect() %>% .[["N"]] %>% median %>% as.integer

median_homo_snv <- df_geno_all %>% filter(TYPE == "SNV" & CALL == "Homozygous") %>% collect() %>% .[["N"]] %>% median %>% as.integer
median_homo_indel <- df_geno_all %>% filter(TYPE == "Indel" & CALL == "Homozygous") %>% collect() %>% .[["N"]] %>% median %>% as.integer

```

<!-- ANNOTATION -->

```{r dfannotation, cache=TRUE} 

annotate_file <- "results/annotate_variants.rds"
nb_feature_file <- "results/annotation_nb_feature.rds"
nb_impact_geno_file <- "results/annotation_impact_geno.rds"

if (!file.exists(annotate_file)) {
  
  df_annotate2 <- fread("~/all_chr_var.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE) %>%
    mutate(PolyPhen = gsub("_", " ", str_extract(PolyPhen, "\\w+")),
           SIFT = gsub("_", " ", str_extract(SIFT, "\\w+")),
           Consequence = sapply(strsplit(Consequence, "_variant", fixed = TRUE),"[[",1),
           Consequence = gsub("_", " ", Consequence),
           HGVSc = sapply(strsplit(HGVSc, split=':', fixed=TRUE), function(x) (x[2])),
           HGVSp = sapply(strsplit(HGVSp, split=':', fixed=TRUE), function(x) (x[2])))
  
  df_annotate <- df_fam_call %>%
    mutate(CHR = as.character(CHR)) %>%
    filter(grepl("zygous", CALL)) %>% 
    select(-STRAND) %>%
    left_join(df_annotate2, by = c("CHR", "POSITION", "REF", "ALT")) %>% 
    mutate(PHENO = if_else(FAM == "AZ","Azoo",
                           if_else(FAM == "FF", "Fert_fail", "MMAF"))) %>% 
    group_by(RUN) %>% 
    mutate(N_VAR_PER_RUN = n_distinct(CHR,POSITION,REF,ALT)) 
  
  saveRDS(df_annotate, annotate_file)
  
} else {
  
  df_annotate <- readRDS(annotate_file)
  
}

if (!file.exists(nb_feature_file)) {

df_nb_feature <- df_annotate %>%
  group_by(RUN) %>%
  summarise(TRANSCRIPT = n_distinct(Feature),
            GENE = n_distinct(SYMBOL)) %>%
  gather(FEATURE, NB, TRANSCRIPT:GENE) 

  saveRDS(df_nb_feature, nb_feature_file)


} else {
  
    df_nb_feature <- readRDS(nb_feature_file)

}

if (!file.exists(nb_impact_geno_file)) {


df_impact <- df_annotate %>% 
  group_by(RUN,CALL, IMPACT) %>%
  summarise(N = n()) %>%
  group_by(RUN) %>%
  mutate(P = N / sum(N))

  saveRDS(df_impact, nb_impact_geno_file)
  
} else {
  
      df_impact <- readRDS(nb_impact_geno_file)
}

```

```{r cleancall, include=FALSE, warning=FALSE}

rm(df_fam_call)
gc()

```

```{r varannotation, cache=TRUE, dependson="dfannotation"}

p_modifier_median <- df_impact %>% group_by(RUN,IMPACT) %>% summarise(N_IMPACT = sum(N)) %>% group_by(RUN) %>% mutate(P_IMPACT = (N_IMPACT / sum(N_IMPACT) * 100)) %>% filter(IMPACT == "MODIFIER") %>% collect() %>% .[["P_IMPACT"]] %>% median %>% as.integer


mean_transcript <- df_nb_feature %>% ungroup() %>% filter(FEATURE == "TRANSCRIPT") %>% summarise(MEAN = mean(NB)) %>% collect() %>% .[["MEAN"]] %>% round(0)
mean_gene <- df_nb_feature  %>% filter(FEATURE == "GENE") %>% collect() %>% .[["NB"]] %>% mean %>% round(0) %>% as.integer
mean_transcript <- df_nb_feature  %>% filter(FEATURE == "TRANSCRIPT") %>% collect() %>% .[["NB"]] %>% mean %>% round(0) %>% as.integer
rate_tr_gene = (mean_transcript / mean_gene) %>% round(0)

mean_percent_high <- df_impact %>% filter(IMPACT == "HIGH") %>% group_by(RUN) %>% summarise(SP = sum(P)) %>% collect() %>% .[["SP"]] %>% mean %>% round(4) * 100
mean_nb_het_high <- df_impact %>% filter(IMPACT == "HIGH" & CALL == "Heterozygous") %>% group_by(RUN) %>% summarise(SN = sum(N)) %>% collect() %>% .[["SN"]] %>% mean %>% round(0) 
mean_nb_homo_high <- df_impact %>% filter(IMPACT == "HIGH" & CALL == "Homozygous") %>% group_by(RUN) %>% summarise(SN = sum(N)) %>% collect() %>% .[["SN"]] %>% mean %>% round(0) 

```

```{r dffreqvar, cache=TRUE, dependson="dfannotation"}

df_freq <- df_annotate %>%
  group_by(RUN, ExAC_AF, `1KG`, ESP) %>% 
  distinct(CHR,POSITION,REF,ALT, N_VAR_PER_RUN) %>% 
  group_by(RUN) %>%
  rename(ExAC = ExAC_AF) %>%
  gather(DB,FREQ,ExAC:ESP)

df_freq2 <- df_freq %>%
  filter(!is.na(FREQ)) %>%
  group_by(DB) %>% 
  distinct(CHR,POSITION,REF,ALT,FREQ) %>% 
  select(-(CHR:ALT)) 

df_freq_stat <- df_freq %>%
  select(-(CHR:ALT)) %>% 
  group_by(RUN, DB) %>% 
  summarise(N_VAR_PER_RUN = mean(N_VAR_PER_RUN),
            N_PER_RUN_PER_DB = N_VAR_PER_RUN - sum(is.na(FREQ)),
            P_PER_RUN_PER_DB = N_PER_RUN_PER_DB / N_VAR_PER_RUN)

```

```{r varfreqvar, cache=TRUE, dependson="dffreqvar"}

min_percent_exac <- df_freq_stat %>% filter(DB == "ExAC") %>% collect() %>% .[["P_PER_RUN_PER_DB"]] %>% min %>% median %>% round(3) * 100
max_percent_exac <- df_freq_stat %>% filter(DB == "ExAC") %>% collect() %>% .[["P_PER_RUN_PER_DB"]] %>% max %>% median %>% round(3) * 100
min_percent_esp <- df_freq_stat %>% filter(DB == "ESP") %>% collect() %>% .[["P_PER_RUN_PER_DB"]] %>% min %>% median %>% round(3) * 100
max_percent_esp <- df_freq_stat %>% filter(DB == "ESP") %>% collect() %>% .[["P_PER_RUN_PER_DB"]] %>% max %>% median %>% round(3) * 100
median_percent_1kg <- df_freq_stat %>% filter(DB == "1KG") %>% collect() %>% .[["P_PER_RUN_PER_DB"]] %>% median %>% round(3) * 100

```

<!-- FILTER -->

```{r ctrldata, include=FALSE, cache=TRUE}

ctrl_file <- "results/all_ctrl.rds"
sample_ctrl_file <- "results/sample_ctrl.rds" 

if(!file.exists(ctrl_file)) {

  df_ctrl_az <- open_ctrl("data/genotype_not_azoo.csv", pheno = "Azoo")
  df_ctrl_ff <- open_ctrl("data/genotype_not_fert_fail.csv", pheno = "Fert_fail")
  df_ctrl_mmaf <- open_ctrl("data/genotype_not_MMAF.csv", pheno = "MMAF")
  
  nb_ctrl_az <-df_ctrl_az %>% collect() %>% .[["N_CTRL"]] %>% mean 
  nb_ctrl_ff <-df_ctrl_ff %>% collect() %>% .[["N_CTRL"]] %>% mean 
  nb_ctrl_mmaf <-df_ctrl_mmaf %>% collect() %>% .[["N_CTRL"]] %>% mean 
  
  fam_lab <- c("Az", "FF", "MMAF1", "MMAF2", "MMAF3", "MMAF4")
  
  nb_ctrl <- c(nb_ctrl_az,
               nb_ctrl_ff,
               nb_ctrl_mmaf,
               nb_ctrl_mmaf,
               nb_ctrl_mmaf,
               nb_ctrl_mmaf)
  
  df_sample_ctrl <- data_frame(FAM = fam_lab,
                               NB = nb_ctrl)
  
  df_ctrl_all <- rbind(df_ctrl_az,
                       df_ctrl_ff,
                       df_ctrl_mmaf)
  
  saveRDS(df_ctrl_all,ctrl_file)
  saveRDS(df_sample_ctrl,sample_ctrl_file)
  
  rm(df_ctrl_az, df_ctrl_ff, df_ctrl_mmaf)
  gc()
  
} else {
  
  df_ctrl_all <- readRDS(ctrl_file)
  df_sample_ctrl <- readRDS(sample_ctrl_file)
}

```

```{r dffilterfam, dependson="dfannotation", cache=TRUE}

maf_cutoff <- .01

df_filter_fam <- ungroup(df_annotate) %>% 
  filter_genotype(het = FALSE) %>%
  filter_frequence(cutoff = maf_cutoff) %>%
  variant_join(df_ctrl_all %>% mutate(CHR = as.character(CHR)), add_by = "PHENO", mode = "anti") %>% 
  filter(Consequence != "synonymous",
         IMPACT != "MODIFIER",
         !(grepl("tolerated", SIFT) & grepl("benign", PolyPhen)),
         !grepl("NMD transcript variant",Consequence),
         !grepl("non coding transcript", Consequence)) %>%
  group_by(FAM) %>%
  mutate(NB_FAM = n_distinct(RUN)) %>% 
  group_by(CHR, POSITION, REF, ALT, FAM, Feature) %>% 
  filter(n() == mean(NB_FAM))

```

```{r dffilterfamnmd, dependson="dfannotation", include=FALSE, warning=FALSE, cache=TRUE}

df_tmp <- ungroup(df_annotate) %>%
  select(CHR, POSITION, REF, ALT, RUN, Feature, Consequence) %>%
  mutate(IS_FILTERED = grepl("NMD transcript", Consequence) | grepl("non coding transcript", Consequence)) %>%
  select(-Consequence) %>%
  group_by(RUN, IS_FILTERED) %>%
  mutate(N_TRANSCRIT_PER_ISNMD = n_distinct(Feature))

df_filtered_tr <- df_tmp %>%
  summarise(N = n_distinct(Feature),
            TYPE = "Transcript")  

df_filtered_tr_vr <- df_tmp %>%
  group_by(CHR, POSITION, REF, ALT, RUN) %>% 
  mutate(IS_FILTERED = if_else(n_distinct(IS_FILTERED) == 1 & IS_FILTERED == TRUE, TRUE, FALSE)) %>%
  group_by(RUN, IS_FILTERED) %>%
  summarise(N = n_distinct(CHR,POSITION,REF,ALT),
            TYPE = "Variants") %>% 
  bind_rows(df_filtered_tr)


rm(df_tmp)
gc()

```

```{r varfilterfamnmd, cache=TRUE, dependson="dffilterfamnmd"}

max_tr <- ungroup(df_filtered_tr_vr) %>% filter(TYPE == "Transcript" & IS_FILTERED == TRUE) %>% collect() %>% .[["N"]] %>% max
min_tr <- ungroup(df_filtered_tr_vr) %>% filter(TYPE == "Transcript" & IS_FILTERED == TRUE) %>% collect() %>% .[["N"]] %>% min
mean_variant <- ungroup(df_filtered_tr_vr) %>% filter(TYPE == "Variants" & IS_FILTERED == TRUE) %>% collect() %>% .[["N"]] %>% mean %>% round(0)

```

```{r comparefilters, include=FALSE, cache=TRUE}

filter_file <- "results/filter.rds"
filter_spe_file <- "results/filter_spe.rds"

if (!file.exists(filter_file) | 
    !file.exists(filter_spe_file)) {

df_filtered_by_geno <- df_annotate %>% 
  filter_genotype(homo = FALSE) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN) %>%
  mutate(FILTER = "Genotype", 
         N_FILTERED = n_distinct(CHR,POSITION,REF,ALT),
         P_FILTERED = N_FILTERED / N_VAR_PER_RUN)

df_filtered_by_freq <- df_annotate %>%
  filter(!is.na(ExAC_AF) & ExAC_AF >= maf_cutoff,
         !is.na(ESP) & ESP >= maf_cutoff,
         !is.na(`1KG`) & `1KG` >= maf_cutoff) %>%
  mutate(FILTER = "Frequence", 
         N_FILTERED = n_distinct(CHR,POSITION,REF,ALT),
         P_FILTERED = N_FILTERED / N_VAR_PER_RUN)
  
df_fitered_by_impact <- df_annotate %>% 
  group_by(RUN) %>% 
  mutate(IS_FILTERED = if_else(Consequence != "synonymous_variant" &
                               IMPACT != "MODIFIER" &
                               (!(grepl("tolerated", SIFT) & grepl("benign", PolyPhen))), FALSE, TRUE)) %>%
  distinct(CHR, POSITION, REF, ALT, IS_FILTERED, N_VAR_PER_RUN) %>%
  group_by(CHR, POSITION, REF, ALT, RUN) %>% 
  mutate(N = n()) %>%
  filter(N == 1,
         IS_FILTERED == TRUE) %>%
  group_by(RUN) %>% 
  mutate(FILTER = "Variant impact", 
         N_FILTERED = n(),
         P_FILTERED = N_FILTERED / N_VAR_PER_RUN)

df_filtered_by_union <- df_annotate %>% 
  distinct(CHR, POSITION, REF, ALT, FAM, N_VAR_PER_RUN) %>% 
  group_by(FAM) %>%
  mutate(NB_FAM = n_distinct(RUN)) %>%
  group_by(CHR, POSITION, REF, ALT, FAM) %>% 
  filter(n() < NB_FAM) %>% 
  group_by(RUN) %>%
  mutate(FILTER = "Union", 
         N_FILTERED = n_distinct(CHR,POSITION,REF,ALT),
         P_FILTERED = N_FILTERED / N_VAR_PER_RUN)

df_fitered_by_transcript <- df_annotate %>%
  mutate(IS_FILTERED = if_else(grepl("NMD_transcript_variant", Consequence) | grepl("non_coding_transcript_variant", Consequence), TRUE, FALSE)) %>% 
    distinct(CHR, POSITION, REF, ALT, IS_FILTERED, N_VAR_PER_RUN) %>%
  group_by(CHR, POSITION, REF, ALT, RUN) %>% 
  mutate(N = n()) %>%
  filter(N == 1,
         IS_FILTERED == TRUE) %>%
  group_by(RUN) %>% 
  mutate(FILTER = "Transcript relevance", 
         N_FILTERED = n(),
         P_FILTERED = N_FILTERED / N_VAR_PER_RUN)
  
df_filter_ctrl <- df_annotate %>% 
  variant_join(df_ctrl_all, add_by = "PHENO", mode = "inner") %>%
  mutate(FILTER = "Ctrl", 
            N_FILTERED = n_distinct(CHR,POSITION,REF,ALT),
            P_FILTERED = N_FILTERED / N_VAR_PER_RUN)


resume_filter <- function(df) {
  
  df %>% group_by(RUN, FILTER) %>% select(RUN, FILTER, N_FILTERED, P_FILTERED) %>% summarise(N = mean(N_FILTERED), P = mean(P_FILTERED))
  
}

filter_stat <- rbind(resume_filter(df_filtered_by_geno),
                     resume_filter(df_filtered_by_freq),
                     resume_filter(df_fitered_by_impact),
                     resume_filter(df_filtered_by_union),
                     resume_filter(df_filter_ctrl),
                     resume_filter(df_fitered_by_transcript))

saveRDS(filter_stat, filter_file)

} else {
  filter_stat <- readRDS(filter_file)
}


```

```{r filterspe, cache=TRUE}


if (!file.exists(filter_spe_file)) {

spe_geno <- df_filtered_by_geno %>% 
  group_by(RUN) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN, FILTER, N_FILTERED, P_FILTERED) %>% 
  variant_join(df_filtered_by_freq, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_fitered_by_impact, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_filtered_by_union, add_by = "RUN", mode = "anti") %>%
  variant_join(df_filter_ctrl, add_by = "RUN", mode = "anti") %>%
  variant_join(df_fitered_by_transcript, add_by = "RUN", mode = "anti") 

spe_freq <- df_filtered_by_freq %>% 
  group_by(RUN) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN, FILTER, N_FILTERED, P_FILTERED) %>% 
  variant_join(df_filtered_by_geno, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_fitered_by_impact, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_filtered_by_union, add_by = "RUN", mode = "anti") %>%
  variant_join(df_filter_ctrl, add_by = "RUN", mode = "anti") %>%
  variant_join(df_fitered_by_transcript, add_by = "RUN", mode = "anti") 

spe_impact <- df_fitered_by_impact %>% 
  group_by(RUN) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN, FILTER, N_FILTERED, P_FILTERED) %>% 
  variant_join(df_filtered_by_freq, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_filtered_by_geno, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_filtered_by_union, add_by = "RUN", mode = "anti") %>%
  variant_join(df_filter_ctrl, add_by = "RUN", mode = "anti") %>%
  variant_join(df_fitered_by_transcript, add_by = "RUN", mode = "anti") 

spe_union <- df_filtered_by_union %>% 
  group_by(RUN) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN, FILTER, N_FILTERED, P_FILTERED) %>% 
  variant_join(df_filtered_by_freq, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_fitered_by_impact, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_filtered_by_geno, add_by = "RUN", mode = "anti") %>%
  variant_join(df_filter_ctrl, add_by = "RUN", mode = "anti") %>%
  variant_join(df_fitered_by_transcript, add_by = "RUN", mode = "anti") 

spe_ctrl <- df_filter_ctrl %>% 
  group_by(RUN) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN, FILTER, N_FILTERED, P_FILTERED) %>% 
  variant_join(df_filtered_by_freq, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_fitered_by_impact, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_filtered_by_union, add_by = "RUN", mode = "anti") %>%
  variant_join(df_filtered_by_geno, add_by = "RUN", mode = "anti") %>%
  variant_join(df_fitered_by_transcript, add_by = "RUN", mode = "anti") 

spe_tr <- df_fitered_by_transcript %>% 
  group_by(RUN) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN, FILTER, N_FILTERED, P_FILTERED) %>% 
  variant_join(df_filtered_by_freq, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_fitered_by_impact, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_filtered_by_union, add_by = "RUN", mode = "anti") %>%
  variant_join(df_filter_ctrl, add_by = "RUN", mode = "anti") %>%
  variant_join(df_filtered_by_geno, add_by = "RUN", mode = "anti") 

spe_all <- rbind(spe_geno,
                 spe_freq,
                 spe_impact,
                 spe_union,
                 spe_ctrl,
                 spe_tr) %>% 
  group_by(RUN, FILTER) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN, N_FILTERED, P_FILTERED) %>% 
  summarise(N_FILTERED_SPE = n_distinct(CHR, POSITION, REF, ALT),
            P_FILTERED_SPE = N_FILTERED_SPE / mean(N_VAR_PER_RUN))

saveRDS(spe_all, spe_filter_file)

} else {
  spe_all <- readRDS(filter_spe_file)
}


```

```{r}

mean_filter_tr <- filter_stat %>% filter(FILTER == "Transcript relevance") %>% collect() %>% .[["P"]] %>% mean %>% round(3) * 100
max_filter_impact <- filter_stat %>% filter(FILTER == "Variant impact") %>% collect() %>% .[["P"]] %>% max %>% round(3) * 100
min_filter_ctrl <- filter_stat %>% filter(FILTER == "Ctrl") %>% collect() %>% .[["P"]] %>% min %>% round(3) * 100
max_filter_ctrl <- filter_stat %>% filter(FILTER == "Ctrl") %>% collect() %>% .[["P"]] %>% max %>% round(3) * 100

mean_filter_spe_impact <- spe_all %>% filter(FILTER == "Variant impact") %>% collect() %>% .[["N_FILTERED_SPE"]] %>% mean %>% round(0) 
mean_filter_spe_geno <- spe_all %>% filter(FILTER == "Genotype") %>% collect() %>% .[["N_FILTERED_SPE"]] %>% mean %>% round(0) 
mean_filter_spe_ctrl <- spe_all %>% filter(FILTER == "Ctrl") %>% collect() %>% .[["N_FILTERED_SPE"]] %>% mean %>% round(0) 
max_filter_spe_ctrl <- spe_all %>% filter(FILTER == "Ctrl") %>% collect() %>% .[["N_FILTERED_SPE"]] %>% max
min_filter_spe_ctrl <- spe_all %>% filter(FILTER == "Ctrl") %>% collect() %>% .[["N_FILTERED_SPE"]] %>% min

max_filter_spe_other <- spe_all %>% filter(FILTER == "Transcript relevance" | FILTER == "Union" | FILTER ==  "Frequence") %>% collect() %>% .[["N_FILTERED_SPE"]] %>% max

```

```{r remaininggense, cache=TRUE, dependson="dffilterfam"}

df_remaining_gene <- df_filter_fam %>% 
  group_by(FAM) %>%
  mutate(SIFT = gsub("_", " ", str_extract(SIFT, "\\w+")),
         SIFT = if_else(grepl("low confidence", SIFT), 
                        str_split(SIFT, "low confidence")[[1]],
                        SIFT)) %>% 
  filter(CANONICAL == "YES") %>%
  mutate(CAUSAL = if_else(FAM == "AZ", "SPINK2", 
                          if_else(FAM == "FF","PLCZ1",
                                  if_else(FAM == "MMAF3","DNAH1", 
                                          if_else(FAM == "MMAF4", "TGIF2?", "???")))),
         FIND_CAUSAL = if_else(CAUSAL == "???","No",
                               if_else(grepl("[?]", perl = TRUE, CAUSAL),"Maybe","Yes"))) %>%
  rename(Family = FAM) %>% 
  
  mutate(HGVSc = if_else(CHR == "3" & POSITION == 52420175 & REF == "G" & ALT == "A", "c.8626-1G > A", HGVSc)) %>% # DNAH1 HGVSc mutation
  
  
  filter(!(SYMBOL %in% c("NBPF13P","HLA-DRB6","JMJD7-PLA2G4B"))) 

n_gene_az <- df_remaining_gene %>% filter(Family == "AZ") %>% distinct(SYMBOL) %>% nrow
n_gene_ff <- df_remaining_gene %>% filter(Family == "FF") %>% distinct(SYMBOL) %>% nrow
n_gene_mmaf3 <- df_remaining_gene %>% filter(Family == "MMAF3") %>% distinct(SYMBOL) %>% nrow

```

#### Résultat de l'alignement  

Pour rappel, l'[alignement]({#lalignement}) consiste à repositionner l'ensemble des *reads* générés au cours de l'étape de séquençage le long d'un génome de référence. 

La quantité de *reads* composant les exomes de chaque individu peut varier en fonction de plusieurs paramètres et n'est donc pas égale pour chaque patient bien que l'ordre de grandeur reste le même avec une médiane de `r raw_reads_median` *reads*. Seuls les deux frères AZ1 et AZ2 se distinguent avec près de 3 fois plus de *reads* que les autres patients. Cette différence peut être expliquée car ces deux patients sont les deux seuls à voir été séquencés au Mount Sinaï Institut or leur protocole d'amplification précédent le séquençage contient un nombre de cycles de PCR supérieur à ceux appliqués au Génopole d'Évry où ont été séquencés les autres patients. Il faut noter que ce nombre plus important de *reads* n'est en rien le reflet d'une meilleure qualité. En effet, celui-ci est causé par une grande quantité de *reads* dupliqués qui seront pour la plupart filtrés au cours des analyses ultérieures (**Table :**  \@ref(tab:tabfam), **Figure : **\@ref(fig:plotfammapping) - **A**).  

 La première étape du contrôle qualité des *reads* consiste à filtrer les *reads* ne s'étant pas alignés sur le génome. Ces *reads* sont extrêmement minoritaires puisqu'ils ne représentent qu'entre `r unmap_reads_min` et `r unmap_reads_max` % des *reads* de nos individus (**Figure : **\@ref(fig:plotfammapping) - **B**).  

 Dans nos analyses, seuls les *reads* compatibles sont conservés, c'est à dire environs `r comp_reads_median` % des *reads* s'étant correctement alignés.  (**Figure : **\@ref(fig:plotfammapping) - **C**).  

La dernière étape de ce contrôle-qualité consiste à analyser le nombre de site auxquels se sont alignés les *reads*. En effet, certaine zone du génome étant dupliqué, l'une des problématiques des *short-reads* est qu'il est possible que ceux-ci s'alignent à plusieurs régions différentes du génome. Afin d'éviter toute ambiguïté, seul ceux s'étant aligné sur un site unique sont conservés pour la suite des analyses. Ces *reads* représente entre `r min_site_1` et `r max_site_1` % des *reads* ayant passé les précédents filtres (**Figure : **\@ref(fig:plotfammapping) - **D**).  

\newpage 

```{r plotfammapping, dependson="varfammapping", fig.cap=fig_info,fig.scap=fig_name,fig.width=6.3, fig.height=6.9, cache=TRUE}

fig_name <- "Processus simplifié du contrôle qualité des *reads*"
fig_description_all <- "Pour chacun des graphiques, les *reads* représentés en vert sont conservés tandis que ceux en rouge sont filtrés"
fig_description_A <- "**A** : Quantité de *reads* bruts générés pour chaque patient au cours de l'étape de séquençage. La médiane des *reads* est représentée en bleue"
fig_description_B <- "**B** : Pourcentage pour chaque individu de *reads* s'étant aligné correctement et ne s'étant pas alignés sur le génome de référence"
fig_description_C <- "**C** : Distribution pour chaque patient des *reads* compatibles (Comp), non compatibles (Non comp) et orphelins (Orphans)"
fig_description_D <- "**D** : Présentation pour chaque *reads* du nombre de site auxquels ils s'alignent"
fig_description <- paste(fig_description_all, fig_description_A,fig_description_B,fig_description_C, fig_description_D, sep = ". ")

fig_info <- paste0(fig_name, " : ", fig_description)

pA <- ggplot(df_reads_summary %>% filter(QUALITY == "Raw reads"), aes(RUN, NB_OF_READS)) + 
  geom_bar(stat = "identity", aes(fill = IS_RETAINED)) +
  scale_x_discrete(limits = run_fam_all) + 
  # facet_wrap(~FAM, scales = "free_x") +
  xlab("") + 
  ylab("Nb of raw reads") + 
  scale_fill_manual(values = c("chartreuse3", "#E41A1C"), guide = "none") +
  geom_hline(col = "blue", aes(yintercept = raw_reads_median)) + 
  geom_text(data=data.frame(x=0,y=median(df_reads_summary$NB_OF_READS)), col = "blue", x = 12.5, y = 110000000, label = raw_reads_median) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))


pB <- ggplot(df_reads_summary %>% 
               filter(QUALITY == "% Well mapped" | 
                        QUALITY == "% Unmapped"), aes(QUALITY, NB_OF_READS)) + 
  geom_boxplot(outlier.size = -1, aes(fill = IS_RETAINED)) + 
  geom_jitter(position=position_jitter(0.3)) +
  facet_wrap(~factor(QUALITY, levels = c("% Well mapped", "% Unmapped")), scales = "free", nrow = 1) + 
  ylab("% of reads") +
  scale_y_continuous(labels = percent) + 
  xlab("") + 
  scale_fill_manual(values = c("#E41A1C", "chartreuse3"), guide = "none") + 
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

pC <- ggplot(df_reads_summary %>% 
         filter(QUALITY == "Compatible" | 
                  QUALITY == "Non compatible" |
                  QUALITY == "Orphans") %>%
           mutate(QUALITY = if_else(QUALITY == "Compatible", "Comp",
                                    if_else(QUALITY == "Non compatible", "Non comp", QUALITY))), aes(QUALITY, NB_OF_READS)) + 
         geom_boxplot(outlier.size = -1, aes(fill = IS_RETAINED)) + 
         geom_jitter(position=position_jitter(0.3)) +
  facet_wrap(~QUALITY, scales = "free", nrow = 1) + 
  ylab("% of reads") +
  scale_y_continuous(labels = percent) + 
  xlab("") + 
  scale_fill_manual(values = c("#E41A1C", "chartreuse3"), guide = "none") + 
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y = element_blank())

pD <- ggplot(df_reads_summary %>% 
               filter(QUALITY == "Map to 1 site" | 
                        QUALITY == "Map to 2 or more sites"), aes(QUALITY, NB_OF_READS)) + 
  geom_boxplot(outlier.size = -1, aes(fill = IS_RETAINED)) + 
  geom_jitter(position=position_jitter(0.3)) +
  facet_wrap(~QUALITY, scales = "free", nrow = 1) + 
  scale_fill_manual(name = "Retained read ?", values = c("#E41A1C", "chartreuse3")) +
  ylab("% of reads") +
  xlab("") + 
  scale_y_continuous(labels = percent) + 
  theme(axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        legend.position="bottom") +
  coord_flip()


row1 <- plot_grid(pA, labels = c("A"))
row2 <- plot_grid(pB,pC, ncol = 2,labels = c("B","C"))

plot_grid(row1,row2, pD, ncol = 1, labels = c("","","D"), rel_heights = c(1,.7,.7, .7))

```

\newpage  

#### L'appel des variants  

Dans nos données, les appels SS sont majoritaires et représentent environ `r median_percent_ss` % de nos appels (contre `r median_percent_ds` % d'appels DS). Au vus de l'importance de ces appels, nous avons fait le choix de les conserver afin de ne pas filtrer une quantité trop importante de données. Ces appels seront cependant considérés comme étant de faible qualité, de fait, leurs analyses et interprétation seront plus précautionneuses. En revanche, au vus de la trop grande incertitude de l'appel des variants NS, ceux-ci sont systématiquement filtrés éliminant ainsi entre `r min_percent_ns` et `r max_percent_ns` % des positions appelées pour chaque patient (**Figure : **\@ref(fig:plotvarcall) - **A**).  

Les appels discordant et ambigus sont filtrés, soit environ `r concordant_median` % des variants DS. Il est intéressant de noter que bien que les variants *single strand* (SS) soient conservés, on peut s'attendre à ce qu'environ `r wrong_median` % de ceux-ci soient aberrants, ceux-ci n'ayant pu subir le même contrôle que les SS (**Figure : **\@ref(fig:plotvarcall) - **B**). 

Pour l'ensemble des variants ayant passé les filtres énoncés ci-dessus, c'est à dire les variants SS et les variants DS avec appels concordants, le génotype est déterminé en fonction du pourcentage de *reads* portant le variant à cette position. Ainsi, pour chaque individu nous avons pu établir une liste de SNVs et d'indels avec leur génotype associé. Pour chacun de nos `r nb_fam_run` patients les ordres de grandeur du nombre de variants appelés sont identique. Ainsi pour chaque patient nous avons appelés environ `r median_het_snv + median_het_indel` variants hétérozygotes (`r median_het_snv` SNVs et `r median_het_indel` indels) et `r median_homo_snv + median_homo_snv` variants homozygotes (`r median_homo_snv` SNVs et `r median_homo_indel` indels) (**Figure : **\@ref(fig:plotvarcall) - **C**).    

\newpage

```{r plotvarcall, dependson="dfvarcall", fig.cap=fig_info,fig.scap=fig_name, fig.height=7.5, cache=TRUE}

fig_name <- "Contrôle qualité des variants appelés"
fig_description_all <- "Pour chacun des graphiques, les variants représentés en vert et en orange sont conservés tandis que ceux en rouge sont filtrés"
fig_description_A <- "**A** : Distribution du *stranding* des appels pour chaque patient"
fig_description_B <- "**B** : Comparaison des appels entre les deux *ends* des variants appelés DS"
fig_description_C <- "**C** : Distribution des SNVs et indels en fonction de leur génotype pour chaque patients (représentés par une barre"
fig_description <- paste(fig_description_all, fig_description_A,fig_description_B,fig_description_C, sep = ". ")
fig_info <- paste0(fig_name, " : ", fig_description)

pA <- ggplot(df_strand_all, aes(STRAND, P)) +
  geom_boxplot(outlier.size = -1, aes(fill = IS_RETAINED)) + 
  geom_jitter(size = 2, position=position_jitter(0.3)) +
  ylab("% of called variant") +
  xlab("") +
    facet_wrap(~factor(STRAND, levels = c("DS", "SS", "NS")), scales = "free") +
  scale_fill_manual(guide = "none", values = c("#E41A1C", "chartreuse3", "#FF7F00")) +
  scale_y_continuous(labels = percent) + 
  theme(axis.title.x = element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

pB <- ggplot(df_concordance_all, aes(CALL, P)) +
  geom_boxplot(aes(fill = IS_RETAINED), outlier.size = -1) + 
  geom_jitter(size = 2, position=position_jitter(0.3)) +
  ylab("% of called variant") +
  xlab("") +
  facet_wrap(~factor(CALL, levels = c("Concordant", "Ambigous", "Discordant")), scales = "free") +
  scale_fill_manual(guide = "none", values = c("#E41A1C", "chartreuse3")) + 
  scale_y_continuous(labels = percent) + 
  theme(axis.title.x = element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

pC <- ggplot(df_geno_all,aes(RUN, N)) + 
  geom_bar(stat = "identity", aes(fill = IS_RETAINED)) +
  facet_grid(TYPE~CALL, scales = "free") +
  ylab("Nb of variant") + 
  scale_fill_manual(name = "Is the variant retained?", values = c("#E41A1C", "chartreuse3", "#FF7F00"), breaks = c("Yes","Yes but low quality", "No")) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1),
          axis.title.x = element_blank(),
          legend.position = "bottom")

row1 <- plot_grid(pA,pB, labels = c("A","B"), ncol = 1)
plot_grid(row1, pC,labels = c("", "C"), rel_heights = c(.52,.48), ncol = 1)

```

\newpage

#### L'annotation des variants

Après avoir annoté nos variants, nous avons pu constater que pour chaque patient `r mean_gene` gènes sont en moyenne affecté par au moins un variant homozygote pour en moyenne `r mean_transcript` transcrits (soit environ `r rate_tr_gene` transcrits par gènes). Il faut noter que parmi ces gènes se trouvent à la fois des gènes codant pour des protéine **et** d'autres non codant (**Figure : **\@ref(fig:plotannotation) - **A**).  

Chaque variant affectera l'ensemble des transcrits qu'il chevauche, ainsi un même variant pourra impacter plusieurs transcrits. Ces impacts sont ensuite classés par VEP en quatre catégories qui sont, de la plus délétère à la moins délétère : *HIGH*, *MODERATE*, *LOW*, *MODIFIER* (**Table :**\@ref(tab:tabvepcsq)).  

Comme attendu, les variants ayant un impact tronquant se retrouvent être les moins fréquent chez chacun de nos patients. Ceci est d'autant plus flagrant pour l'impact *HIGH* qui regroupe, entre autres, les variants créant un codon stop ou encore ceux causant un décalage du cadre de lecture (**Table :**\@ref(tab:tabvepcsq)), se retrouvent, par rapport aux autres impacts, en quantité extrêmement faible puisqu'ils ne représentent en moyenne que `r mean_percent_high` % des variants. Cependant, bien que ce pourcentage soit faible, cela représente tout de même une moyenne de `r mean_nb_het_high` variants *HIGH* hétérozygotes par patients et `r mean_nb_homo_high` variants *HIGH* homozygotes par patient) (**Figure : **\@ref(fig:plotannotation) - **B**).  

<!-- Parmi ces variants, certains étaient déjà recensés dans une des trois base donnée (ExAC, ESP et 1KG). Ainsi, on peut observer qu'entre `r min_percent_exac` et `r max_percent_exac` % de nos variant étaient listés dans ExAC et entre `r min_percent_esp` et `r max_percent_esp` % dans ESP. En revanche environ `r median_percent_1kg` % d'entre eux sont recensés dans 1KG (**Figure : **\@ref(fig:plotvarannotation) - **C**) (À discuter !!!!!).   -->

<!-- (À discuter !!!!!) (**Figure : **\@ref(fig:plotvarannotation) - **D**) -->

<!-- LES FIGURES SUR LA FRÉQUENCE SONT À DISCUTER CAR LEUR INTERPRÉTATION ME LAISSE PERPLEX (SURTOUT LA PROPORTION DE NOS VARIANTS PRÉSENTS DANS 1KG) -->

\newpage

```{r plotannotation, dependson=c("dfvarannotation","dffreqvar"), fig.cap=fig_info,fig.scap=fig_name,fig.width=6.5, fig.height=7, cache=TRUE}

fig_name <- "Annotation des variants"
fig_description_A <- "**A** : Quantification du nombre de gènes (en bleu) / transcrits (en rose) impactés par au moins un variant pour chaque patient chacun représentés par une barre"
fig_description_B <- "**B** : Distribution des impacts HIGH MODERATE LOW et MODIFIER en fonction des patients et du génotype du variant"
fig_description_C <- "**C** : Pourcentage des variants retrouvés au sein des trois bases de données : ExAC, ESP et 1KG"
fig_description_D <- "**D** : Distribution des fréquences de nos variants au sein des trois bases de données : ExAC, ESP et 1KG"

fig_description <- paste(fig_description_A,fig_description_B, sep = ". ")
fig_info <- paste0(fig_name, " : ", fig_description)


pA <- ggplot(df_nb_feature, aes(RUN, NB)) + 
  geom_bar(stat = "identity", position = position_nudge(),  aes(fill = FEATURE)) + 
  xlab("") + 
  ylab("Nb of feature impacted") + 
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  scale_fill_brewer(palette = "Set1", name = "Feature", labels = c("Gene", "Transcript")) 

pB <- ggplot(df_impact, aes("", P)) +
  geom_boxplot(aes(fill = CALL), alpha = .3, outlier.size = -1) + 
  geom_jitter(aes(col = CALL), size = 1, position = position_jitterdodge(0.2)) +
  facet_wrap(~factor(IMPACT, levels = c("HIGH", "MODERATE", "LOW", "MODIFIER")), scales = "free", nrow = 1) +
  scale_y_continuous(labels = percent_format()) + 
  scale_color_brewer(palette = "Set1", name = "Call") +
  scale_fill_brewer(palette = "Set1", name = "Call") + 
  theme(axis.title = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

# pC <- ggplot(df_freq_stat, aes("", P_PER_RUN_PER_DB)) + 
#   geom_boxplot(outlier.size = -1, aes(fill = DB)) + 
#   geom_jitter(size = 1, position = position_jitter(0.2)) +
#   facet_wrap(~DB, scales = "free") + 
#   ylab("% of variant found within a DB") + 
#   xlab("") +
#   scale_x_discrete(labels = c("1KG","ESP6500","ExAC")) +
#   scale_y_continuous(labels = percent) +
#    scale_fill_brewer(palette = "Set1", guide = "none") +
#   theme(axis.text.x = element_blank(),
#         axis.ticks.x = element_blank())
#         
# pD <- ggplot(df_freq2, aes(FREQ)) + 
#   geom_line(aes(col = DB), stat = "bin", bins = 150) +
#    scale_color_brewer(palette = "Set1", name = "Data base", labels = c("1KG","ESP6500","ExAC")) + 
#   xlab("Variant frequency") +
#   ylab("Nb of variants") + 
#   scale_x_continuous(labels = percent)

# row1 <- plot_grid(pA, pB, labels = c("A","B"), ncol = 1)
# row2 <- plot_grid(pC, pD, labels = c("C","D"), ncol = 2)
# 
# plot_grid(row1,row2, ncol = 1, labels = c("","",""), rel_heights = c(1,.5))
plot_grid(pA, pB, labels = c("A","B"), ncol = 1)

```

```{r cleanfreq, include=FALSE, warning=FALSE}

rm(df_freq, df_freq2, df_freq_stat)
gc()


```

#### Le filtrage des variants  

Les étapes précédentes nous ont permis de mettre en évidence pour chaque patient une liste de variants passant l'ensemble de nos critères qualités. Ces variants ont dès lors pu être annotés nous permettant notamment d'avoir connaissance de leurs impacts sur les différents transcrits qu'ils chevauchent ou encore leur fréquence dans la population générale. Désormais, afin de ne conserver que les variants ayant la plus forte probabilité d'être responsable du phénotype de ces patients, nous avons appliqué successivement les six filtres précédemment décrits.

1. **Filtre 1 : L'union des variants :** Dans cette étude nous analysons les données génétiques de `r nb_fam` chacune composée de 2 frères. Nous avons donc émmi l'hypothèse que le phénotype de chacun de frères d'une même famille était dûe à une cause génétique commune. C'est pourquoi, seul les variants observés chez l'ensemble des membres d'une même famille furent conservés.  Ainsi se filtre a permis de filtrer entre ... et ... variants pour chacun des patients.     

2. **Filtre 2 : Génotype des variants :**  Ici, nous avons émis l'hypothèse d'une transmission récessive du phénotype. Ainsi, seuls les variants homozygotes ont été conservés. filtrant en moyenne ... variant par individu soit une moyenne de ... % de leurs variants (**Figure : **\@ref(fig:plotvarcall), \@ref(fig:plotcomparefilter)).     

3. **Filtre 3 : Impact du variant :** Ce filtre consistant à se baser à la fois sur les prédiction VEP mais aussi, dans le cas de variants faux-sens, sur les prédiction SIFT et PolyPhen permet de ne conserver que les variant ayant les effet les plus délétères. Ce filtre est, de prime abord le plus efficace puisqu'il permet de filtrer environs ... % (médiane) des variants de chaque individu.  

4. **Filtre 4 : Les transcrits "non pertinents" :** Cette étape de filtre permet de filtrer systématiquement entre `r min_tr` et `r max_tr` transcrits différents par patients. Cependant, un même variant pouvant impacter à la fois des transcrits "non pertinents" **et** des transcrits "pertinents", seuls ceux impactant **uniquement** des transcrits "non pertinents" sont filtrés, soit une moyenne de `r mean_variant` variants par individus (**Figure : **\@ref(fig:plotfilternonpertinanttr)).    

```{r plotfilternonpertinanttr, fig.cap=fig_info,fig.scap=fig_name,fig.width=6.3, fig.height=3.5, cache=TRUE}

fig_name <- "Filtrage des transcrits jugés \"non pertinents\" et des variants les chevauchant"
fig_description <- "Pour chaque patient nous avons filtrer les transcrits jugés \"non pertinents\" pour l'analyse, c'est à dire ceux ne codant pas pour une protéine et ceux annoté NMD. Dès lors, l'intégralité des variants chevauchant uniquement des transcrits non pertinents ont pu systématiquement être filtrés (boites rouges). Les autres furent conservés (boites vertes)"
fig_info <- paste0(fig_name, " : ", fig_description)

ggplot(df_filtered_tr_vr, aes(IS_FILTERED, N)) + 
  geom_boxplot(aes(fill = IS_FILTERED), outlier.size = -1) + 
  geom_jitter(size = 2, position=position_jitter(0.3)) +
  scale_fill_manual(name = "Retained?", values = c("chartreuse3", "#E41A1C"), labels = c("Yes","No")) +
  facet_wrap(~TYPE, scales = "free") +
  ylab("Nb of transcripts / variants") + 
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

```

5. **Fréquence des variants :**  Filtrer systématiquement les variants retrouvés avec une fréquence $\ge$ `r maf_cutoff` dans l'une des trois bases de données que sont ExAC, 1KG et ESP6500 permet de filtrer entre ... et ... variants par patients.    

6. **Présence des variants dans la cohorte contrôle :**  Au cours de nos différentes études, nous avons été amenés à séquencé un total de ` n_tot_runs` individus présentant un des ` n_pheno_tot` phénotypes que nous avons étudiés (**Table : **\@ref(tab:TODO)). Ces phénotypes étant très différent, on peut émettre l'hypothèse que leurs causes génétiques soient également différentes. De même, les variants recherchés étant rares, il est peu probable qu'un individu porte les variants de deux phénotypes différents. Ainsi, pour chacune des `r nb_fam` familles, nous avons pu constituer une cohorte contrôle composée dans l'ensemble des patients précédemment analysés et ne présentant pas le même phénotype que celui étudié dans la famille (**Figure :** \@ref(fig:plotsamplectrl)). Dès lors, nous avons pu filtrer l'ensemble des variants retrouvés à la fois chez nos patients et observés à l'état homozygote dans la cohorte contrôle. Cette cohorte contrôle présente ainsi le même rôle que les bases de données publiques. Sont intérêt principale par rapport à celles-ci est que les individus qui la composent ont pour la plupart la même origine ethnico-géographique que nos patients. De plus ceux-ci ont été séquencés en même temps dans les mêmes centres permettant ainsi d'identifier les artefacts dus aux protocoles de séquençage.   

\newpage

```{r plotsamplectrl, fig.cap=fig_info,fig.scap=fig_name, fig.height=4, cache=TRUE}
     
fig_name <- "Nombre d'individus composant la cohorte contrôle de chaque famille"
fig_description <- "Ici, chaque barre représente une famille et sa hauteur est déterminée par le nombre d'individus composant la cohorte contrôle à laquelle elle a été confronté. Chaque individu de la cohorte contrôle a été séquencés en WES par notre équipe. Afin d'être considéré comme \"contrôle\" et intégrer cette cohorte, un individu doit être sain ou présenter un phénotype d'infertilité différent de la famille étudiée. Par exemple, un individus MMAF pourra servir de contrôle aux familles AZ et FF mais pas aux familles MMAF1-4"
fig_info <- paste0(fig_name, " : ", fig_description)
                         
ggplot(df_sample_ctrl, aes(FAM, NB, fill = FAM)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = NB), position = position_dodge(width = .9), vjust = -.25) +
  ylab("Number of control individuals") +
   scale_fill_brewer(palette = "Set1", guide = "none") +
  xlab("Family")


```

\newpage

Comme on pouvait s'y attendre, ces six filtres ont un pouvoir discriminant extrêmement différent. En effet, tandis que le filtre "Transcript relevance" (filtre n°4) éliminer en moyenne `r mean_filter_tr` % des variants de chaque individu, le filtre "Variant impact" (filtre n° 3) élimine jusqu'à `r max_filter_impact` % de ces mêmes variants. Cette différence n'est pas surprenante. En effet, comme nous l'avions vu plus tôt, les variants de la catégorie VEP *MODIFIER*  qui regroupe entre autres les variants chevauchant les séquences UTRs et introniques (**Table :** \@ref(tab:tabvepcsq)) représentent en moyenne `r p_modifier_median`% des variants de nos patients. Ceux-ci étant tous filtrés, on s'attendait donc à une valeur aussi élevée. On peut également constater l'importance de la cohorte contrôle qui, je le rappelle, permet de filtrer l'ensemble des variants homozygotes observés en son sein, puisque ce filtre permet retirer entre `r min_filter_ctrl` et `r max_filter_ctrl`% des variants de chaque individus (**Figure :** \@ref(fig:plotcomparefilter) - **A**).      

Cependant, regarder uniquement le pourcentage de variants filtrés par chaque filtre révèle une information partielle. En effet, dans ce cas de figure, on observe la quantité de variant éliminé par chaque filtre indépendamment les uns des autres. Ainsi, un même variant peut donc être filtré par plusieurs filtres. Dès lors, il faut également analyser la quantité de variants filtrés **spécifiquement** par chaque filtre. Ainsi, on peut constater que le classement des filtres en fonctions de leur stringence reste quasiment identique. Il est tout de même intéressant de noter que désormais le filtre "Variant impact" apparait moins efficace que les filtres "Ctrl" et "Genotype" en filtrant spécifiquement une moyenne de `r mean_filter_spe_impact` variants par individu contre `r mean_filter_spe_geno` pour le filtre génotype et `r mean_filter_spe_ctrl` pour le filtre "Ctrl". Ainsi, ce dernier devient celui filtrant spécifiquement le plus de variants avec entre `r min_filter_spe_ctrl` et `r max_filter_spe_ctrl` variants spécifiquement filtrés par patients confirmant ainsi l'importance de ce filtre dans nos analyses. Aussi, les filtres "Transcript relevance", "Union" et "Frequency" apparaissent désormais comme étant anecdotiques en comparaison aux trois autres filtres puisqu'ils filtrent au maximum `r max_filter_spe_other` variants spécifiques (**Figure :** \@ref(fig:plotcomparefilter) - **B**).  

\newpage

```{r plotcomparefilter, fig.cap=fig_info,fig.scap=fig_name, fig.height=7, cache=TRUE}

fig_name <- "Comparaison de l'efficacité de chacun des six filtres utilisés"
fig_description_A <- "**A** : Comparaison du pourcentage de variants filtrés par chacun des six filtres indépendamment les uns des autres pour chaque patient (représenté par les points. Dès lors, un même variant peut-être filtré par plusieurs filtres"
fig_description_B <- "**B** : Comparaison du nombre de variant filtrés spécifiquement par chacun des filtres. Ici, un variant ne peut-être filtré que par un seul filtre"
fig_description <- paste(fig_description_A, fig_description_B, sep = ". ")
fig_info <- paste0(fig_name, " : ", fig_description)

pA <- ggplot(filter_stat, aes(FILTER, P)) + 
  geom_boxplot(fill = "#E41A1C", outlier.size = -1) + 
  scale_x_discrete(limits = c("Transcript relevance","Union","Frequence","Genotype","Ctrl","Variant impact")) + 
  geom_jitter(position=position_jitter(0.3)) +
  ylab("% of filtered variants") + 
  xlab("") +
  scale_y_continuous(labels = percent) 

pB <- ggplot(spe_all, aes(FILTER, N_FILTERED_SPE)) + 
  geom_boxplot(fill = "#E41A1C", outlier.size = -1) + 
  geom_jitter(position=position_jitter(0.3)) +
  ylab("Nb of filtered variants") + 
  xlab("") +
  scale_x_discrete(limits = c("Transcript relevance","Union","Frequence","Genotype","Ctrl","Variant impact")) 
  # facet_wrap(~factor(FILTER, levels = c("Transcript relevance","Union","Frequence","Genotype","Ctrl","Variant impact")), scales = "free")

plot_grid(pA,pB, labels = c("A","B"), ncol = 1)

```

Après avoir appliqué l'ensemble de ces filtres, seuls quelques variants subsistent nous permettant d'obtenir une liste de gènes restreinte pour chaque famille et ainsi de tirer des conclusions quant au variant responsable du phénotype de chacune d'entre elles. Ces travaux ont ainsi pu mener à l'écriture de trois articles dont je suis co-auteur.   

\newpage

```{r tablegene, dependson="remaininggense", cache=TRUE}

df_recap <- df_remaining_gene %>% 
  mutate(SIFT = na.replace(SIFT, "."),
         PolyPhen = na.replace(PolyPhen, "."),
         ExAC_AF = na.replace(ExAC_AF, "."),
         ESP = na.replace(ESP, "."),
         `1KG` = na.replace(`1KG`, "."),
         PolyPhen = gsub("probably", "proba", PolyPhen),
         PolyPhen = gsub("possibly", "possib", PolyPhen),
         HGVSc = na.replace(HGVSc, "."),
         HGVSp = na.replace(HGVSp, "."),
         `HGVSc, HGVSp` = paste0(HGVSc," ; ", HGVSp)) %>%
  select(Family, Gene = SYMBOL, HGVSc, HGVSp, `HGVSc, HGVSp`, CANONICAL, Consequence, SIFT, PolyPhen, ExAC = ExAC_AF, ESP, `1KG`) %>% 
  distinct() %>% 
  arrange(Family)

```

\newpage  

### Article n° 3

**SPINK2 deficiency causes infertility by inducing sperm defects in heterozygotes and azoospermia in homozygotes** 

Kherraf ZE^\*^, Christou-Kent M^\*^, **Karaouzène T**, Amiri-Yekta A, Martinez G, Vargas AS, Lambert E, Borel C, Dorphin B, Aknin-Seifer I, Mitchell MJ, Metzler-Guillemain C, Escoffier J, Nef S, Grepillat M, Thierry-Mieg N, Satre V, Bailly M, Boitrelle F, Pernet-Gallay K, Hennebicq S, Fauré J, Bottari SP, Coutton C, Ray PF, Arnoult C  

^\*^ Co-premiers auteurs  

EMBO Molecular Medicine, Mai 2017

\newpage

#### Contexte et objectifs   

L'oligospermie, comme l'azoospermie sont des phénotypes d'infertilités masculines liées à la quantité de spermatozoïdes présent dans l'éjaculât. Les différentes études publiées ces dernières années montrent que les microdélétions du chromosome Y sont retrouvées chez 10% des hommes avec une azoospermie non-obstructives et chez 5% des patients avec une oligozoospermie sévères [@Hotaling2014]. Ces taux bien qu'élevé ne représente qu'une infime partie des cas d'azoospermie et d'oligospermie suggérant l'implication de nombreux autres gènes dans ce phénotype.  

Entre 2005 et 2014 deux frères issus d'un union consanguin ont demandé des conseils médicaux auprès de différentes cliniques d'infertilité après deux ans de tentatives infructueuses de consevoir un enfant. Ces deux frères étant marriés à des femmes non-apparentées la piste de l'implication d'une cause féminine fut exclu et les recherches concentrées sur l'analyse des deux frères. Après analyse de leur éjaculât, (et de l'épydidime) ... tout deux présentèrent de sévères défauts de production de spermatozoïdes. Au vu de la similarité du phénotype et du lien de parenté les liant, l'hypothèse d'une cause génétique commune fut émmise. L'analyse de leur karyotype et du locus AZF du chromosome Y ne révélant aucune anomalie, la procédure d'un séquençage WES fut décidé.  

Dans ce contexte, l'objectif de mon travail sur l'analyse phénotype de ces deux frères a été d'effectuer l'ensemble des analyses des données WES obtenues après leur séquençage afin de mettre en évidence une mutation homozygote commune aux deux frères pouvant expliquer leur phénotype. Dans un second temps, j'ai pu mettre en place le protocole de génotypage des souris au locus du gène *Spink2* permettant d'identifier les souris sauvages *Spink2*^+/+^ des souris KO *Spink2*^-/-^. Pour finir, afin d'estimer l'importance des variants du gène *SPINK2* comme cause d'infertilité masculine chez l'humain, j'ai également contribué au séquençage Sanger de la séquence codante de *SPINK2* d'une partie des 611 patients séquencés dans cette étude.  

\newpage

\includepdf[pages=-]{bib/SPINK2_2017.pdf}

\newpage

#### Principaux résultats

```{r dfrecapaz, cache=TRUE, dependson="tablegene"}

df_remaining_variant_az <- df_recap %>%
  ungroup() %>% 
  filter(Family == "AZ") %>% 
  mutate(HGVSc = na.replace(HGVSc, "."),
         HGVSp = na.replace(HGVSp, "."),
         `HGVSc, HGVSp` = paste0(HGVSc," ; ", HGVSp)) %>% 
  select(-Family, -SIFT, -PolyPhen, -CANONICAL, -HGVSc, -HGVSp) 

```

```{r varrecapaz, cache=TRUE, dependson="dfrecapaz"}

nb_var_fam_az <- df_remaining_variant_az %>% nrow
gene_fam_az <- df_remaining_variant_az %>% collect() %>% .[["Gene"]]

```

Après avoir analyser les données de séquençage des deux frères au sein de notre pipeline décrite précédement, seul `r nb_var_fam_az` variants passèrent l'ensemble des filtres. Ces deux variants impactant respectivement les gènes `r paste_vector(gene_fam_az, "itallic")`. Parmis ces deux gènes, seul *SPINK2* présentaient une forte expression testiculaire dans les données Ensembl (**Figure : **\@ref(fig:plotexpfamaz)) que nous avons pu confirmer par RT-PCR dans cette étude. De plus, des mutations du gène *Spink2* chez la souris avait déjà été identifiée comme induisant des défauts de la spermatogenèse [@Lee2011]. Ces arguments ont ainsi fait de *SPINK2* le candidat évident pour expliquer le phénotype de ces deux frères. Après avoir confirmé en séquençage Sanger la mutation de ce gène à l'état homozygote pour les deux frères et hétérozygotes pour les parents, nous avons, afin de continuer nos investigations, développés un modèle murin KO *Spink2*^-/-^ confirmant une azoospermie complète pour les sours mâle spermiogenesis causé par un arret de la spermatogénèse au stage des spermatides rondes. De plus, malgré une fertilité normale, nous avons pu noter un taux élevé d'anomalies morphologiques du spermatozoïde ainsi qu'une motilité spermatique réduite chez les souris mâles hétérozygotes *Spink2*^+/-^. Les femelles, elles ne présentaient aucun phénotype apparent. L'étude de la localisation de la protéine Spink2 chez la souris et SPINK2 chez l'humain a révélés que ces deux protéines localisaient dans la vésicule acrosomale depuis le début de la biogénèse de l'acrosome jusqu'au spermatozoïde mature.  

Suite à cela, afin d'évaluer l'importance des variants du gène *SPINK2* dans l'infertilité humaine, nous avons effectués le séquençage Sanger de 611 patient parmi lesquels 210 étaient azoospermes, 393 oligozoospermes et 8 dont la cause n'étaient pas spécifiée. Parmi cet ensemble de patient, seul 1 (le patient p105) s'est révélé porter un variant non répertorié dans ExAC sur le gène *SPINK2*. Ce patient présentant un phénotype d'oligozoospermie porte à l'état hétérozygote un variant altérant le codon start du gène *SPINK2*. Ces résultats laissent donce supposer que chez l'homme, la présence de mutations homozygotes sur le gène *SPINK2* induit un phénotype d'azoospermie tandis que les mutation hétérozygotes entrainent, elles, un phénotype d'oligozoospermie. Cette forte séléction négative pouvant expliquer la rareté des mutations observées sur ce gènes.  


```{r tabrecapaz,cache=TRUE, dependson="dfrecapaz"}

caption <- "Liste des variants ayant passé l'ensemble des filtres pour les deux fères de la famille AZ"

df_remaining_variant_az %>% 
  kable(format = "latex",
        booktabs = TRUE,
        longtable = TRUE,
        caption = caption) %>%
  add_header_above(c(" ", "Variant impact" = 2, "Variant frequency" = 3))

```

\newpage

```{r plotexpfamaz, fig.cap=fig_info,fig.scap=fig_name, dependson="varrecapaz", cache=TRUE}

fig_name <- "Expression tissulaire des gènes *SPINK2* et *GUF1*"
fig_description <- "Données provenant du projet de transcriptome Illumina bodyMap"
fig_info <- paste0(fig_name, " : ", fig_description)

gene_fam_az <- df_recap %>% filter(Family == "AZ") %>% collect() %>% .[["Gene"]]

plot_expression(gene_fam_az,"percent", TRUE)+
  xlab("") +
  theme(legend.position = c(1, 0),
        legend.justification = c(1,0))


```

\newpage

### Article n° 4

**Homozygous mutation of PLCZ1 leads to defective human oocyte activation and infertility that is not rescued by the WW-binding protein PAWP**

Jessica Escoffier J^\*^, Lee HC^\*^, Yassine S^\*^, Zouari R, Martinez G, **Karaouzène T**, Coutton C, Kherraf ZE, Halouani L, Triki C, Nef S, Thierry-Mieg N, Savinov SN, Fissore R, Ray PF, Arnoult C  

^\*^ Co-premiers auteurs  

Human Molecular Genetics, Décembre 2015  

\newpage

#### Contexte et objectifs  

L'activation ovocitaire regroupe une série de processus intervenant au cour de la fécondation d'un ovocyte par un spermatozoïde. en 1990, plusieurs études démontrèrent que chez les mamifères ces processus reposent principalement sur le relargage par le spermatozoïde de "facteurs spermatiques" qui déclenchent un signal de calcium, constitué d'oscillations Ca^2+^ [ref]. Plus tard, la protéine PLC$\zeta$ fu identifiée comme la molécule responsable de ces oscilations calciques. Cependant, en raison de l'incapacité àproduire des modèles animaux *PLC*$\zeta$ KO capable de produire des spermatozoïdes mature a empeché d'attribuer l'exclusivité de ce rôle à *PLC*$\zeta$ laissant ouverte la possibilité de la nécessité d'autres facteurs spermatiques. C'est ainsi qu'en 2014 fut proposé la protéine PAWP comme facteur spermatique alternatif ou complémentaire de PLC$\zeta$ [@Aarabi2014; @Aarabi2014a].   

Les travaux ci-dessous décrivent les analyses effectuées sur deux frères issus d'un union consanguin ayant tout deux été dans l'incapacité de concevoir un enfant par voies naturelles et pour qui, malgré des paramètres spermatiques normaux, l'ensemble des procédures de reproduction assités effectuées se sont soldés par un échec d'activation ovocitaire.   

Comme dans l'étude précédente, en raison de l'historique de cansanguinité de la famille des deux frères ainsi que le fait que leur femmes respectives soient non apparentées nous a permi d'exclure l'hypothèse d'une cause féminine et nous a conduit à rechercher un variant homozygote commun aux deux frères. Nous avons ainsi effectué un séquençage WES de ces deux frères. Comme précédemment, dans cette étude, j'ai été en charge de l'ensemble des analyses des données issus du séquençage des deux frères.  

\newpage

\includepdf[pages=-]{bib/PLCZ1_2016}

\newpage

#### Principaux résultats

```{r dfrecapff, cache=TRUE, dependson="tablegene"}

df_remaining_variant_ff <- df_recap %>% 
  ungroup() %>% 
  filter(Family == "FF") %>% 
  mutate(HGVSc = na.replace(HGVSc, "."),
         HGVSp = na.replace(HGVSp, "."),
         `HGVSc, HGVSp` = paste0(HGVSc," ; ", HGVSp)) %>% 
  select(-Family, -CANONICAL, -HGVSc, -HGVSp, -ESP, -`1KG`)

```

```{r varrecapff, cache=TRUE, dependson="dfrecapff"}

nb_var_fam_ff <- df_remaining_variant_ff %>% nrow
gene_fam_ff <- df_remaining_variant_ff %>% collect() %>% .[["Gene"]]

freq_var_plcz <- df_remaining_variant_ff %>% filter(Gene == "PLCZ1") %>% collect() %>% .[["ExAC"]]

```


Suite à l'analyse bioinformatique de ces deux frères, un seul variant subsistait après l'application de l'ensemble des filtres. Celui-ci était recancé uniquement dans la base de donnée ExAC avec une fréquence de `r freq_var_plcz` et entrait un faux-sens prédit comme *deleterious* par SIFT et *possibly damaging* par PolyPhen sur la séquence du gène *PLC*$\zeta 1$. La forte expression testiculaire de ce gène (**Figure : **\@ref(fig:plotexpfamff)) couplée à l'implication déjà connu de celui-ci dans l'activationn ovocitaire, ont fait de ce variant le candidat évident pour expliquer le phénotype de ces deux frères. De plus, aucun variant n'a été retrouvé sur la séquence du gène *WBP2NL* codant pour la protéine PAWP bien que l'intégralité de la séquence codante de *WBP2NL* ait une couverture $\ge$ 40x (les zones moins couvertes du début de l'exon 1 et de la fin de l'exon 6 correspondant aux régions UTR) (**Figure : **\@ref(fig:plotcovplcz)). Ces résultats suggérant une parfaite fonctionnalité de la protéine PAWP ont pu être confirmée par *Western blot*, de même, la bonne localisation de la protéine PAWP a pu être observée chez les deux patients par Immunofluorescence.  

Cette étude présente le premier cas de *knock-down* de PLC$\zeta$ n'entrainant pas d'effets sur la spermatogénèse démontrant ainsi le rôle primordial de cette protéine dans l'activation ovocitaire. De plus, la parfaite localisation et fonctionnalité de la protéine PAWP la disculpe de toute implication dans le phénotype de nos patients. 

```{r tabrecapff,cache=TRUE, dependson="dfrecapaz"}

caption <- "Liste des variants ayant passé l'ensemble des filtres pour les deux fères de la famille FF"

df_remaining_variant_ff %>% 
  kable(format = "latex",
        booktabs = TRUE,
        longtable = TRUE,
        caption = caption) %>%
  add_header_above(c(" ", "Variant impact" = 4, "Variant frequency" = 1))

```

\newpage

```{r plotexpfamff, fig.cap=fig_info,fig.scap=fig_name, fig.asp=.65, cache=TRUE}

fig_name <- "Expression tissulaire du gène PLCZ1*"
fig_description <- "Données provenant du projet de transcriptome Illumina bodyMap"
fig_info <- paste0(fig_name, " : ", fig_description)

plot_expression(gene_fam_ff,"percent", TRUE)+
  xlab("") +
  theme(legend.position = c(1, 0),
        legend.justification = c(1,0))


```

```{r plotcovplcz, fig.cap=fig_info,fig.scap=fig_name, ,out.extra="scale=.4", cache=TRUE}

fig_name <- "Couverture des 6 éxons de *WBP2NL* pour les deux frères de la famille FF"
fig_info <- paste0(fig_name)

include_graphics(path = "figure/pawp_coverage.png")

```


\newpage

### Article n° 5

#### Whole-exome sequencing of familial cases of multiple morphological abnormalities of the sperm flagella (MMAF) reveals new DNAH1 mutations
  
Amiri-Yekta A^\*^, Coutton C^\*^, Kherraf ZE, **Karaouzène T**, Le Tanno P, Sanati MH, Sabbaghian M, Almadani N, Sadighi Gilani MA, Seyedeh Hanieh Hosseini, Bahrami S, Daneshipour A, Bini M, Arnoult C, Colombo R, Gourabi H, Ray PF  

^\*^ Co-premiers auteurs  

Human Reproduction, Octobre 2016  

\newpage

#### Contexte et objectifs  

Dans une étude précédente non détaillée dans ce manuscrit , notre équipe a pu identifier le gène *DNAH1* comme le premier gène codant pour une dynéine axonèmale responsable uniquement d’infertilité masculine. Dans cette première étude, ... de nos ... patients (non apparentés), soit environs ... d'entre eux, étaient porteur d'une mutation homozygote sur le gène *DNAH1* responsable de leur phénotype MMAF. Ces résultats ont ainsi démontrés l'importance de l'implication de ce gène dans ce phénotype.  

Dans cette nouvelle étude, nous nous concentrons sur l'analyses des données génétiques de 5 familles iraniène et d'une famille italienne pour un total de 12 individus. Parmis eux 10 sont nés d'un union consanguain. Pour des raisons techniques et materiels, seuls deux de ces individus ont, pour l'instant, été analysés sur notre pipeline décrite précédement (famille MMAF). Pour les autres les données familles séquencés en haut débit, les variants utilisés furent ceux fournit par les centres de séquençage auxquels nous avons ensuite appliqué les même critères de filtre.  

Dans ce contexte j'ai effectué les l'ensemble des analyses des deux patients patients de la familles MMAF décrites ci-dessus, mais également l'ensemble des analyses de filtrage appliqué aux données des 8 autres patients séquencés en WES.     

\newpage

\includepdf[pages=-]{bib/Fam_DNAH1_2016.pdf}

\newpage

#### Principaux résultats

```{r dfrecapmmaf, cache=TRUE, dependson="tablegene"}

df_remaining_variant_mmaf <- df_recap %>% 
  ungroup() %>% 
  filter(Family == "MMAF") %>% 
  mutate(HGVSc = na.replace(HGVSc, "."),
         HGVSp = na.replace(HGVSp, "."),
         `HGVSc, HGVSp` = paste0(HGVSc," ; ", HGVSp)) %>% 
  select(-Family, -SIFT, -PolyPhen, -CANONICAL, -HGVSc, -HGVSp)



```

```{r varrecapmmaf, cache=TRUE, dependson="dfrecapmmaf"}

nb_var_fam_mmaf <- df_remaining_variant_mmaf %>% nrow
gene_fam_mmaf <- df_remaining_variant_mmaf %>% collect() %>% .[["Gene"]]

```

Dans cette étude nous avons séquencé un total de 12 patients provenant de  6 familles différentes. Tout ces patients souffrent d'un syndrome MMAF induisant une infertilité. Parmi ceux-ci 10 ont été séquençé en WES, cependant, seulement ... d'entre eux ont été analysé au sein de notre pipeline d'analyse. Après l'aplication de l'ensemble des filtres seul ... variants subsistaient impactant respectivement les gènes ... . 



**Famille MMAFXXX** : À l'issue des filtres, ` n_gene_mmaf3` gènes ressortaient chez ces deux frères : *MYH11* et *DNAH1*. Or, notre équipe ayant déjà établit le lien entre des mutations du gène *DNAH1* et le syndrome MMAF [@BenKhelifa2014] ce gène s'est révélé être un candidat idéal pour expliquer le phénotype de ces 2 frères. De plus, l'implication de *MYH11* dans le phénotype de dissection aortique [@Imai2015] l'ont écarté des candidats pour le phénotype MMAF.   

\newpage


```{r tabrecapmmaf, cache=TRUE, dependson="dfrecapmmaf"}

caption <- "Liste des variants ayant passé l'ensemble des filtres pour les deux fères P5 et P6 de la famille MMAF3"

df_remaining_variant_mmaf %>%
  kable(format = "latex",
        booktabs = TRUE,
        longtable = TRUE,
        caption = caption) %>% 
  add_header_above(c(" ", "Variant impact" = 2, "Variant frequency" = 3))

```

\newpage

```{r plotexpfammmaf, dependson="varrecapmmaf", fig.cap=fig_info,fig.scap=fig_name, cache=TRUE}

fig_name <- "Expression tissulaire des gènes DNAH1 et MYH11"
fig_description <- "Données provenant du projet de transcriptome Illumina bodyMap"
fig_info <- paste0(fig_name, " : ", fig_description)

plot_expression(gene_fam_mmaf,"percent", TRUE)+
  xlab("") +
  theme(legend.position = c(1, 0),
        legend.justification = c(1,0))

```

\newpage

## Résultats 2 : Étude d'une cohorte de femmes infertiles  
### Article n° 6

**PATL2 Gene Mutation Causes Oocyte Meiotic Deficiency and Female Infertility** 

Christou-Kent M, Amiri-Yekta A, Kherraf ZE, **Karaouzène T**, Escoffier J, Guttin A, Martinez G, Le Blévec E, Lambert E, Fourati Ben Mustapha S, Cedrin-Durnerin I, Halouani L, Marrakchi O, Makni M, Latrous H, Kharouf M, Bottari S, Thierry-Mieg N, Coutton C, Zouari R, Issartel JP, Ray PF, Arnoult C

New England Journal of Medicine, 07 Juillet 2017 (soummis)

\newpage

#### Contexte et objectifs  

<!-- RUN -->

```{r dfrunovo, cache=TRUE}

df_run_ovo <- fread("data/exome_runs_all.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, drop = c(2,3,4,10:16), data.table = FALSE) %>% 
  rename(RUN = Magic_ID, PHENOTYPE = Pathologie, DATE = Date) %>%
  filter(!Project %in% c("Novogene","Integragen")) %>%
  mutate(YEAR = as.numeric(str_sub(DATE, start= -4)),
         PROJECT = paste0(Project," (",YEAR,")")) %>%
  filter(PHENOTYPE == "Ovo") %>% 
  select(-DATE, -PHENOTYPE)

```

```{r varrunovo, cache=TRUE, dependson="dfrunovo"}

run_ovo <- df_run_ovo %>% collect() %>% .[["RUN"]]
nb_ovo_run <- df_run_ovo %>% nrow

run_ctrl_ovo <- fread("data/exome_runs_all.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, drop = c(2,4,10:16), data.table = FALSE) %>% 
    rename(PHENOTYPE = Pathologie, DATE = Date) %>%
  mutate(RUN = if_else(Project == "Integragen", Patient, 
                       if_else(Project == "Novogene", paste0("s", Patient), Magic_ID)),
         PHENOTYPE = if_else(PHENOTYPE == "Flag", "MMAF", PHENOTYPE)) %>% 
  filter(!(PHENOTYPE %in% c("Ovo", "Azoo"))) %>%
  collect() %>%
  .[["RUN"]]

min_ovo_year <- df_run_ovo$YEAR %>% min
max_ovo_year <- df_run_ovo$YEAR %>% max

center_ovo <- df_run_ovo$Project %>% unique
nb_center_ovo <- center_ovo %>% length

```

<!-- ANNOTATION -->

```{r dfannotateovo, cache=TRUE}
 
df_annotate <- fread("zcat data/call_results/others_novogen_integragen_distinct_var_vep81_format_no_MODIFIER.csv.gz", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, data.table = FALSE)

```

<!-- CALL -->

```{r dfovocall, dependson=c("dfannotateovo","varrunovo","localfunction"), cache=TRUE}

df_ovo_call <- fread("data/call_results/others_novogen_integragen_var_genotype.csv",
                         sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, data.table = FALSE) %>%
  select(CHR, POSITION, REF, ALT, one_of(run_ovo)) %>%
  gather(RUN, CALL, -(CHR:ALT)) %>%
  filter(CALL %in% c(0, 2, 3, "b", "c"),
         !is.na(REF)) %>%
  mutate(STRAND = call_to_strand(CALL),
         TYPE = var_type(REF, ALT),
         CALL = call_to_geno(CALL))

df_distinct_ovo_call <- df_ovo_call %>%
  filter(grepl("zygous", CALL)) %>%
  distinct(CHR, POSITION, REF, ALT, TYPE) %>%
  variant_join(df_annotate, mode = "inner") %>%
  mutate(PolyPhen = gsub("_", " ", str_extract(PolyPhen, "\\w+")),
         SIFT = gsub("_", " ", str_extract(SIFT, "\\w+")),
         Consequence = sapply(strsplit(Consequence, "_variant", fixed = TRUE),"[[",1),
         Consequence = gsub("_", " ", Consequence),
         HGVSc = sapply(strsplit(HGVSc, split=':', fixed=TRUE), function(x) (x[2])),
         HGVSp = sapply(strsplit(HGVSp, split=':', fixed=TRUE), function(x) (x[2])))  


df_ovo_call_geno <- df_ovo_call %>%
  filter(grepl("zygous", CALL)) %>%
  group_by(RUN, TYPE, CALL) %>%
  distinct(CHR, POSITION, REF, ALT) %>%
  count() %>%
  left_join(df_run_ovo, by = "RUN") %>%
  select(-(Project:Model))
                       
df_ovo_call_strand <- df_ovo_call %>%
  group_by(RUN, STRAND) %>%
  count() %>%
  group_by(RUN) %>%
  mutate(N_ALL_STRAND = sum(n),
         P_STRAND = n / N_ALL_STRAND) %>%
  left_join(df_run_ovo, by = "RUN")

```

```{r varovocall, cache=TRUE, dependson="dfovocall"}

```

<!-- FILTER -->

```{r dfctrlovo, cache=TRUE,  dependson= c("varrunovo","callfunction")}

df_ctrl_ovo <- define_ctrl_var(run_ctrl_ovo)
  
```

```{r dfovofilter, cache=TRUE, dependson=c("dfctrlovo","dfovocall")}

maf_cutoff <- .01

df_distinct_ovo_filter <- df_distinct_ovo_call %>%
  filter_frequence(cutoff = maf_cutoff) %>%
  variant_join(df_ctrl_ovo, mode = "anti") %>%
  filter(Consequence != "synonymous",
         IMPACT != "MODIFIER",
         !(grepl("tolerated", SIFT) & grepl("benign", PolyPhen)),
         !grepl("NMD transcript", Consequence),
         !grepl("non coding transcript", Consequence))

df_ovo_filter <- df_ovo_call %>%
  select(-STRAND) %>%
  filter_genotype(het = FALSE) %>%
  variant_join(df_distinct_ovo_filter, mode = "inner") %>%
  ungroup()

df_ovo_filter_het <- df_ovo_call %>%
  select(-STRAND) %>%
  filter_genotype(homo = FALSE) %>%
  variant_join(df_distinct_ovo_filter, mode = "inner") %>%
  group_by(RUN, SYMBOL, Feature) %>%
  mutate(N_VAR_PER_RUN_PER_GENE = n()) %>%
  filter(N_VAR_PER_RUN_PER_GENE > 1) %>%
  group_by(SYMBOL) %>%
  mutate(N_RUN_PER_GENE = n_distinct(RUN)) %>%
  ungroup()

df_ovo_filter_stat <- df_ovo_filter %>%
  group_by(RUN) %>%
  mutate(N_GENE = n_distinct(SYMBOL)) %>%
  group_by(RUN, TYPE, N_GENE) %>%
  distinct(CHR, POSITION, REF, ALT) %>%
  summarise(N_VAR_PER_TYPE = n()) %>%
  group_by(RUN) %>%
  mutate(N_VAR_TOT = sum(N_VAR_PER_TYPE)) %>%
  right_join(df_run_ovo, by = "RUN")

```

```{r varovofilter, cache=TRUE, dependson="dfovofilter"}

nb_distinct_var <- df_ovo_filter %>% ungroup() %>% distinct(CHR, POSITION, REF, ALT) %>% nrow
nb_distinct_snv <- df_ovo_filter %>% ungroup() %>% filter(TYPE == "SNV") %>% distinct(CHR, POSITION, REF, ALT) %>% nrow
nb_distinct_indel <- df_ovo_filter %>% ungroup() %>% filter(TYPE == "Indel") %>% ungroup() %>% distinct(CHR, POSITION, REF, ALT) %>% nrow
nb_distinct_gene <- df_ovo_filter %>% ungroup() %>% distinct(SYMBOL) %>% nrow

nb_run_patl2 <- df_ovo_filter %>% filter(SYMBOL == "PATL2") %>% distinct(RUN) %>% nrow
p_run_patl2 <- (nb_run_patl2 / nb_ovo_run) %>% round(3) * 100

hgvsc_patl2 <- df_ovo_filter %>% filter(SYMBOL == "PATL2", CANONICAL == "YES") %>% distinct(HGVSc) %>% collect() %>% .[["HGVSc"]] 
hgvsp_patl2 <- df_ovo_filter %>% filter(SYMBOL == "PATL2", CANONICAL == "YES") %>% distinct(HGVSp) %>% collect() %>% .[["HGVSp"]] 
canonical_tr_patl2 <- df_ovo_filter %>% filter(SYMBOL == "PATL2", CANONICAL == "YES") %>% distinct(Feature) %>% collect() %>% .[["Feature"]]

```

```{r cache=dfovotwohomohigh, cache=TRUE, dependson="dfovofilter"}

df_ovo_filter_high <- df_ovo_filter %>%
  filter(IMPACT == "HIGH",
         CANONICAL == "YES") %>%
  group_by(SYMBOL) %>%
  summarise(High = n_distinct(RUN)) %>%
  filter(High > 0)

df_ovo_filter_moderate <- df_ovo_filter %>%
  filter(IMPACT != "HIGH",
         CANONICAL == "YES") %>%
  group_by(SYMBOL) %>%
  summarise(Moderate = n_distinct(RUN))

df_ovo_filter_low <- df_ovo_filter_het %>%
  filter(CANONICAL == "YES") %>%
  group_by(SYMBOL, RUN) %>%
  filter(n() > 1) %>%
  group_by(SYMBOL) %>%
  summarise(Low = n_distinct(RUN))

df_ovo_filter_reduce <- df_ovo_filter_high %>%
  left_join(df_ovo_filter_moderate, by = "SYMBOL") %>%
  left_join(df_ovo_filter_low, by = "SYMBOL") %>%
  mutate(N_HIGH = High,
         N_MODERATE = Moderate,
         N_LOW = Low) %>%
  gather(EVIDENCE, N_RUN, High:Low, factor_key = TRUE) %>%
  group_by(SYMBOL) %>%
  mutate(N_RUN = na.replace(N_RUN, 0),
         N_TOT = sum(N_RUN))

```



Entre `r min_ovo_year` et `r max_ovo_year` notre équipe a pris en charge le diagnostique de 23 femmes nord africaine présentant toutes une déficience méiotique ovocytaire (DMO) caractérisé par un blocquage de la méïose au stade M1 et unduisant une infertilité. À l'heure actuelle, seul le gène *TUBB8*  retrouvé muté à l'état hétérozygote chez des patientes chinoise avait pu être lié à ce phénotype. Cette étude a donc pour objectif de caractériser la cause génétique responsable du phénotype DMO de ces 23 femmes. Parmi cells-ci, `r nb_ovo_run` ont été analysées par séquençage haut-débit. Dans ce contexte, j'ai, au cours de ma thèse, été en charge de l'ensemble des analyses bio-informatiques de ces `r nb_ovo_run` femmes.  

\newpage

\includepdf[pages=-]{bib/PATL2_2017.pdf}

\newpage

#### Principaux résultats

L'application de notre pipeline d'analyse sur les données de ces femmes nous a permis d'obtenir une liste de `r nb_distinct_var` variants impactant `r nb_distinct_gene` gènes différents. Parmi ces variants, aucin n'impactait le gène *TUBB8*. Afin de restreindre à nouveau la liste de gènes, nous nous sommes concentré sur ceux retrouvés mutés à l'état homozygote chez au moins 2 femmes. Seul 3 gènes ont passés ce nouveau critère : *FAM58A*, *MGAM* et *PATL2*. Aucune investigation n'a pour l'instant été effectuée sur les `r nb_distinct_gene - 3` autres. En raison de la fréquence élevée du variant retrouvé sur *FAM58A* et de l'impact peu délétère du variant chevauchant *MGAM*, ces deux gènes ont été considéré comme de mauvais candidats. 

Ainsi, nous nous sommes dans un premier temps concentré sur la caractérisation de *PATL2* dont l'orthologue *xpat1a* chez le xenope a été décrit comme étant exprimé au cours du dévelopement de l'ovocyte [@Marnef2010; @Nakamura2010] faisant de ce gène un excellent candidat. `r nb_run_patl2` de nos patients, soit `r p_run_patl2`% d'entre elles, révélèrent porter une même mutation : `r hgvsc_patl2`, `r hgvsp_patl2` induisant un codon stop prématuré dans la séquence codante du transcrit canonique *PATL2*: `r canonical_tr_patl2`. Au vu de ces résultats un séquençage Sanger de la séquence codante de ce gène fut réalisé pour ces `r nb_run_patl2` femmes afin de confirmer cette mutation, de même que sur 8 femmes supplémentaires souffrant du même phénotypes. Parmi ces dernières, une s'est révélée porter la même mutation à l'état homozygote.  

Dans un second temps, l'étude du modèle murin KO *Patl2*^-/-^ nous a permi de mettre en évidence une subfertilité importante chez les souris femelles tandis qu'aucun phénotype n'était observable chez les mâles.  

Pour finir, *xpat1a*, l'orthologue de *PATL2* chez le xénope, ayant été décrit comme réprimant la traduction de l'ARNm dans l'ococyte nous avons cherché à savoir si les souris femelles KO *Patl2*^-/-^ présentait des dérégulation de leur transcriptome ovocytaire. Pour cela, nous avons procédés à une étude comparative des transcriptome ovocytaires au stades GC et MII murins sur puces Affymetrix mesurant les valeurs d'expression d'environ 66,000 transcrits différents. Ainsi, nous avons pu mettre en évidence 134 transcrits différentiellement exprimés au stade GV parmi lesquels 95 étaient sous-exprimés tandis que 39 étaient sur-exprimés. Au stade MII, ces dérégulation se révélèrent être plus impréssionnantes puisque 124 étaient sous-exprimés et 122 sur-exprimés démontrant ainsi un forte implication de *Patl2* dans la transcription ovocytaire des gènes murins.     

<!-- CLEAN -->

```{r cleanovo, warning=FALSE, message=FALSE}

rm(df_annotate, df_run_ovo, df_ovo_call, df_distinct_ovo_call, 
   df_ctrl_ovo, df_distinct_ovo_filter, df_ovo_filter_stat)
gc()

```

\newpage  

## Résultats 3 : Étude d'une large cohorte de patients MMAF

### Article n° 7

**Whole exome cohort study and analysis of mouse and Trypanosoma models demonstrate the importance of WDR proteins in flagellogenesis and male fertility** 

Coutton C, Vargas A, Amiri-Yekta A, Kherraf ZE, Fourati Ben Mustapha S, Le Tanno P, Wambergue-Legrand C, **Karaouzène T**, Martinez G, Daneshipour A, Hanieh Hosseini S, Mitchell V, Halouani L, Marrakchi O, Makni M, Latrous H, Kharouf M, Deleuze JF, Boland A, Hennebicq S, Satre V, Jouk PS, Bottari SP, Thierry-Mieg N, Conne B, Dacheux-Deschamps D, Schmitt A, Stouvenel L, Lorès P, El Khouri E, Fauré J, Wolf JP, Escoffier J, Gourabi H, Robinson DR, Nef S, Dulioust E, Zouari R, Bonhivers M, Touré A, Arnoult C, Ray PF

EMBO Molecular Medicine, Mai 2017

\newpage

#### Contexte et objectifs  

<!-- RUN -->

```{r dfrunbigmmaf, cache=TRUE}

run_mmaf_fam <- c("Ghs56","Ghs58","Ghs62","Ghs130","Ghs63","Ghs119","Ghs59","Ghs60","Ghs61")

df_run_bigmmaf <- fread("data/exome_runs_all.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, drop = c(2,4,10:16), data.table = FALSE) %>% 
  mutate(RUN = if_else(Project == "Integragen", Patient, 
                       if_else(Project == "Novogene", paste0("s", Patient), Magic_ID)),
         RUN2 = Magic_ID) %>%
  select(-Magic_ID, -Patient) %>%
  rename(PHENOTYPE = Pathologie, DATE = Date) %>%
  mutate(PHENOTYPE = if_else(PHENOTYPE == "Flag", "MMAF", PHENOTYPE), 
         YEAR = as.numeric(str_sub(DATE, start= -4)),
         PROJECT = paste0(Project," (",YEAR,")")) %>%
  filter(!(RUN %in% run_mmaf_fam),
         PHENOTYPE == "MMAF") %>%
  select(-DATE, -PHENOTYPE)


```

```{r varrunbigmmaf, dependson="dfrunbigmmaf", cache=TRUE}

runs_bigmmaf <- df_run_bigmmaf %>% collect() %>% .[["RUN"]]
runs_ctrl_bigmmaf <- fread("data/exome_runs_all.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, drop = c(2,4,10:16), data.table = FALSE) %>% 
    rename(PHENOTYPE = Pathologie, DATE = Date) %>%
  mutate(RUN = if_else(Project == "Integragen", Patient, 
                       if_else(Project == "Novogene", paste0("s", Patient), Magic_ID)),
         PHENOTYPE = if_else(PHENOTYPE == "Flag", "MMAF", PHENOTYPE)) %>% 
  filter(PHENOTYPE != "MMAF") %>% 
  collect() %>%
  .[["RUN"]]


min_year <- df_run_bigmmaf$YEAR %>% min
max_year <- df_run_bigmmaf$YEAR %>% max

center <- df_run_bigmmaf$Project %>% unique
n_center <- center %>% length

nb_run_bigmmaf <- runs_bigmmaf %>% length
nb_run_ctrl_bigmmaf <- runs_ctrl_bigmmaf %>% length

```

<!-- ANNOTATION -->

```{r dfannotatebigmmaf, cache=TRUE}
 
df_annotate <- fread("zcat data/call_results/others_novogen_integragen_distinct_var_vep81_format_no_MODIFIER.csv.gz", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, data.table = FALSE)

```

<!-- CALL -->

```{r dfbigmmafcall, cache=TRUE, dependson=c("dfannotatebigmmaf","varrunbigmmaf","dfrunbigmmaf","callfunction")}

df_bigmmaf_call <- fread("data/call_results/others_novogen_integragen_var_genotype.csv", 
                         sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, data.table = FALSE) %>% 
  select(CHR, POSITION, REF, ALT, one_of(runs_bigmmaf)) %>%
  gather(RUN, CALL, -(CHR:ALT)) %>% 
  filter(CALL %in% c(0, 2, 3, "b", "c"),
         !is.na(REF)) %>%
  mutate(STRAND = call_to_strand(CALL),
         TYPE = var_type(REF, ALT),
         CALL = call_to_geno(CALL)) %>%
  left_join(df_run_bigmmaf %>% select(RUN, RUN2), by = "RUN") %>%
  mutate(RUN = RUN2) %>%
  select(-RUN2)

  df_distinct_call <- df_bigmmaf_call %>%  
    filter(grepl("zygous", CALL)) %>% 
    distinct(CHR, POSITION, REF, ALT, TYPE) %>%
    variant_join(df_annotate, mode = "inner") %>%
    mutate(PolyPhen = gsub("_", " ", str_extract(PolyPhen, "\\w+")),
           SIFT = gsub("_", " ", str_extract(SIFT, "\\w+")),
           Consequence = sapply(strsplit(Consequence, "_variant", fixed = TRUE),"[[",1),
           Consequence = gsub("_", " ", Consequence),
           HGVSc = sapply(strsplit(HGVSc, split=':', fixed=TRUE), function(x) (x[2])),
           HGVSp = sapply(strsplit(HGVSp, split=':', fixed=TRUE), function(x) (x[2])))

df_bigmmaf_call_geno <- df_bigmmaf_call %>% 
  filter(grepl("zygous", CALL)) %>% 
  group_by(RUN, TYPE, CALL) %>% 
  distinct(CHR, POSITION, REF, ALT) %>%
  count() %>%
  left_join(df_run_bigmmaf, by = "RUN") %>% 
  select(-(Project:Model))

df_bigmmaf_call_strand <- df_bigmmaf_call %>%
  group_by(RUN, STRAND) %>%
  count() %>%
  group_by(RUN) %>%
  mutate(N_ALL_STRAND = sum(n),
         P_STRAND = n / N_ALL_STRAND) %>%
  left_join(df_run_bigmmaf, by = "RUN")

```

<!-- FILTER-->

```{r dfctrlbigmmaf, cache=TRUE,  dependson= c("varrunbigmmaf","callfunction")}

df_ctrl_mmaf <- define_ctrl_var(runs_ctrl_bigmmaf)

```

```{r dffilterbigmmaf, cache=TRUE, dependson="dfbigmmafcall"}

maf_cutoff <- .01

df_distinct_filter <- df_distinct_call %>%
  filter_frequence(cutoff = maf_cutoff) %>%
  variant_join(df_ctrl_mmaf, mode = "anti") %>%
  filter(Consequence != "synonymous",
         IMPACT != "MODIFIER",
         !(grepl("tolerated", SIFT) & grepl("benign", PolyPhen)),
         !grepl("NMD transcript", Consequence),
         !grepl("non coding transcript", Consequence))

df_bigmmaf_filter <- df_bigmmaf_call %>% 
  select(-STRAND) %>%
  filter_genotype(het = FALSE) %>% 
  variant_join(df_distinct_filter, mode = "inner") %>% 
  # select(-Allele) %>% 
  mutate(SYMBOL = if_else(SYMBOL == "WDR52", "CFAP44", 
                          if_else(SYMBOL == "WDR96", "CFAP43", SYMBOL))) %>%
  ungroup()
  
df_bigmmaf_filter_het <- df_bigmmaf_call %>% 
  select(-STRAND) %>% 
  filter_genotype(homo = FALSE) %>% 
  variant_join(df_distinct_filter, mode = "inner") %>% 
  # select(-Allele) %>%
  group_by(RUN, SYMBOL, Feature) %>%
  mutate(N_VAR_PER_RUN_PER_GENE = n()) %>% 
  filter(N_VAR_PER_RUN_PER_GENE > 1) %>% 
  group_by(SYMBOL) %>%
  mutate(N_RUN_PER_GENE = n_distinct(RUN)) %>%
  ungroup() %>%
  mutate(SYMBOL = if_else(SYMBOL == "WDR52", "CFAP44", 
                          if_else(SYMBOL == "WDR96", "CFAP43", SYMBOL)))

df_bigmmaf_filter_stat <- df_bigmmaf_filter %>% 
  group_by(RUN) %>%
  mutate(N_GENE = n_distinct(SYMBOL)) %>%
  group_by(RUN, TYPE, N_GENE) %>%
  distinct(CHR, POSITION, REF, ALT) %>%
  summarise(N_VAR_PER_TYPE = n()) %>%
  group_by(RUN) %>%
  mutate(N_VAR_TOT = sum(N_VAR_PER_TYPE)) %>%
  right_join(df_run_bigmmaf, by = "RUN") 

```

```{r varbigmmaffilter, dependson="dfbigmmaffilter", cache=TRUE}

n_distinct_var <- df_bigmmaf_filter %>% ungroup() %>% distinct(CHR, POSITION, REF, ALT) %>% nrow
n_distinct_snv <- df_bigmmaf_filter %>% ungroup() %>% filter(TYPE == "SNV") %>% distinct(CHR, POSITION, REF, ALT) %>% nrow
n_distinct_indel <- df_bigmmaf_filter %>% ungroup() %>% filter(TYPE == "Indel") %>% ungroup() %>% distinct(CHR, POSITION, REF, ALT) %>% nrow
n_distinct_gene <- df_bigmmaf_filter %>% ungroup() %>% distinct(SYMBOL) %>% nrow

n_min_var <- df_bigmmaf_filter_stat %>% collect() %>% .[["N_VAR_TOT"]] %>% min
n_max_var <- df_bigmmaf_filter_stat %>% collect() %>% .[["N_VAR_TOT"]] %>% max

n_mean_indel <- df_bigmmaf_filter_stat %>% filter(TYPE == "Indel") %>% collect() %>% .[["N_VAR_PER_TYPE"]] %>% mean %>% round(0)
n_mean_snv <- df_bigmmaf_filter_stat %>% filter(TYPE == "SNV") %>% collect() %>% .[["N_VAR_PER_TYPE"]] %>% mean %>% round(0)

n_min_gene <- df_bigmmaf_filter_stat %>% collect() %>% .[["N_GENE"]] %>% min
n_max_gene <- df_bigmmaf_filter_stat %>% collect() %>% .[["N_GENE"]] %>% max


nb_run_dnah1 <- bind_rows(df_bigmmaf_filter %>% filter(SYMBOL == "DNAH1"),
                          df_bigmmaf_filter_het %>% filter(SYMBOL == "DNAH1")) %>%
  distinct(RUN) %>%
  nrow
          
```

```{r dftwohomohigh, cache=TRUE, dependson="dfbigmmaffilter"}

df_bigmmaf_filter_high <- df_bigmmaf_filter %>% 
  filter(IMPACT == "HIGH",
         CANONICAL == "YES") %>% 
  group_by(SYMBOL) %>%
  summarise(High = n_distinct(RUN)) %>% 
  filter(High > 2) %>%
  filter(!(SYMBOL %in% c("AC090286.4", "AC012309.5", "RP6-206I17.1","hsa-mir-150")),
         !grepl("HLA-", SYMBOL),
         !grepl("RP11", SYMBOL))

df_bigmmaf_filter_moderate <- df_bigmmaf_filter %>% 
  filter(IMPACT != "HIGH",
         CANONICAL == "YES") %>% 
  group_by(SYMBOL) %>%
  summarise(Moderate = n_distinct(RUN))

df_bigmmaf_filter_low <- df_bigmmaf_filter_het %>% 
  filter(CANONICAL == "YES") %>% 
  group_by(SYMBOL, RUN) %>%
  filter(n() > 1) %>% 
  group_by(SYMBOL) %>%
  summarise(Low = n_distinct(RUN))
  
df_bigmmaf_filter_reduce <- df_bigmmaf_filter_high %>% 
  left_join(df_bigmmaf_filter_moderate, by = "SYMBOL") %>%
  left_join(df_bigmmaf_filter_low, by = "SYMBOL") %>%
  mutate(N_HIGH = High,
         N_MODERATE = Moderate,
         N_LOW = Low) %>%
  gather(EVIDENCE, N_RUN, High:Low, factor_key = TRUE) %>% 
  group_by(SYMBOL) %>%
  mutate(N_RUN = na.replace(N_RUN, 0),
         N_TOT = sum(N_RUN)) 

```

```{r vartwohomohigh, cache=TRUE, dependson="dftwohomohigh"}

gene_at_least3 <- df_bigmmaf_filter_high %>% distinct(SYMBOL) %>% collect() %>% .[["SYMBOL"]]
nb_gene_at_least3 <- gene_at_least3 %>% length

nb_run_cfap43_high <- df_bigmmaf_filter_reduce %>% filter(EVIDENCE == "High", SYMBOL == "CFAP43") %>% collect() %>% .[["N_HIGH"]] 
nb_run_cfap43_moderate <- df_bigmmaf_filter_reduce %>% filter(EVIDENCE == "Moderate", SYMBOL == "CFAP43") %>% collect() %>% .[["N_MODERATE"]] 
nb_run_cfap43_low <- df_bigmmaf_filter_reduce %>% filter(EVIDENCE == "Low", SYMBOL == "CFAP43") %>% collect() %>% .[["N_LOW"]] 
nb_run_cfap43 <- nb_run_cfap43_high + nb_run_cfap43_moderate + nb_run_cfap43_low 
p_run_cfap43 <- (nb_run_cfap43 / nb_run_bigmmaf) %>% round(3) * 100   
  
  
nb_run_cfap44_high <- df_bigmmaf_filter_reduce %>% filter(EVIDENCE == "High", SYMBOL == "CFAP44") %>% collect() %>% .[["N_HIGH"]] 
nb_run_cfap44_moderate <- df_bigmmaf_filter_reduce %>% filter(EVIDENCE == "Moderate", SYMBOL == "CFAP44") %>% collect() %>% .[["N_MODERATE"]] 
nb_run_cfap44_low <- df_bigmmaf_filter_reduce %>% filter(EVIDENCE == "Low", SYMBOL == "CFAP44") %>% collect() %>% .[["N_LOW"]] 
nb_run_cfap44 <- nb_run_cfap44_high + nb_run_cfap44_moderate + nb_run_cfap44_low 
p_run_cfap44 <- (nb_run_cfap44 / nb_run_bigmmaf) %>% round(3) * 100   

nb_run_cfap <- df_bigmmaf_filter %>% filter(SYMBOL == "CFAP44" | SYMBOL == "CFAP43") %>% distinct(RUN) %>% nrow

```

```{r pierrerayanalysis}

# Pierre Ray 
# 
# bind_rows(df_runs %>% select(RUN = `Magic ID`, Patient) %>% filter(Patient == "BO.F") %>% inner_join(df_bigmmaf_filter),
#           df_runs %>% select(RUN = `Magic ID`, Patient) %>% filter(Patient == "BO.F") %>% inner_join(df_bigmmaf_filter_het)) %>% 
#   filter(CANONICAL == "YES") %>%
#   select(-CANONICAL) %>%
#   select(-N_VAR_PER_RUN_PER_GENE, -N_RUN_PER_GENE) %>%
#   add_exp() -> bo.f
#   write.table("~/Bureau/canonical_variants_homo_het_BO.F.csv", sep = "\t", row.names = FALSE)
# 
# plot_expression(gene = bo.f$SYMBOL %>% unique, mode = "percent", tissues = "testis", flip = TRUE)
#   


```

<!-- ### -->

Après avoir mis en évidence l'implication du gène *DNAH1* dans le phénotype MMAF notre équipe s'est en partie spécialisé dans la caractérisation ce syndrome. Ainsi, entre `r min_year` et `r max_year`, notre équipe a effectué le séquençage de `r nb_run_bigmmaf` individus présentant tous ce phénotype afin d'en établir la cause génétique. Ces séquençages ont été effectué dans `r n_center` centres différents que sont `r center %>% paste_vector`. La plupart de ces séquençages ont été effectués sur des Illumina HiSeq2000 exceptés les ... plus récent qui ont été effectués sur un Illumina HiSeq4000 (**Table : **\@ref(tab:tabrunbigmmaf)).

```{r tabrunbigmmaf, cache=TRUE, dependson="dfrunbigmmaf"}

kable(df_run_bigmmaf %>% 
        mutate(Platform = paste0(Platform, " ", Model)) %>%
        select(-Model, -PROJECT) %>%
        rename(Place = Project, Patient = RUN, Year = YEAR) %>% 
        group_by(Place, Year, Platform) %>% 
        summarise(`Nb of individuals` = n_distinct(Patient)) %>%
        arrange(Year),
      longtable = TRUE,
      booktabs = TRUE, 
      caption = "Liste des différents individus présentant un phénotype MMAF séquencés en WES") 

```

\includepdf[pages=-]{bib/CFAP_2017.pdf}

\newpage

#### Principaux résultats

L'application de de notre pipeline d'analyse sur les données de ces `r nb_run_bigmmaf` patients nous a permi d'obtenir une liste de `r n_distinct_var` variant distincts ayant passés l'ensemble de nos filtres (`r n_distinct_snv` SNPs et `r n_distinct_indel` indels), ceux-ci impactant un total de `r n_distinct_gene` gènes différents.  

Le gène *DNAH1* étant le candidat évident, nous avons chercher en priorité l'ensemble des variants retrouvés sur ce gène. Ainsi, nous avons obtenus une liste de `r nb_run_dnah1` patients portant tous soit au moins variant homozygote sur le gène *DNAH1* soit deux variants hétérozygotes sur ce même gène (**Table : **\@ref(tab:tabdnah1)).  

**décrire les variants DNAH1**

Au vu du nombre important de gènes restant et afin d'étudier en priorité ceux pouvant expliquer le phénotype d'un maximum de patients nous avons, comme précédemment, limité nos recherches aux gènes sur lesquels **au moins 3 patients portaient un variant tronquant** réduisant à nouveaux cette liste à `r nb_gene_at_least3` gènes différents : `r gene_at_least3 %>% paste_vector("itallic")` (**Figure : **\@ref(fig:plottwohomohigh)).

Cela nous a ainsi permi de mettre en évidence les gènes *CFAP43* et *CFAP44* sur lesquels des variants homozygotes tronquants ont été retrouvés chez respectivement `r nb_run_cfap43_high` et `r nb_run_cfap44_high` patiens (**Tables : **\@ref(tab:tabcfap43) et \@ref(tab:tabcfap44)). Ces deux gènes CFAP (pour *Cilia and Flagella Associated Protein*) avaient déjà été répertorié dans les bases de données publiques comme ayant une forte expression testiculaire, et comme étant probablement impliqués dans la structure et / ou fonction du flagelle spermatique [@Ivliev2012]. De plus, ces deux gènes codent tous deux pour des protéines appartenant à la famille des WDR et comportent tous deux neuf répétitions WD [@Smith2008]. Ainsi, en tenant compte du nombre important de patients portantdes variants sur un de ces deux gènes et le fait qu'ils codent tous deux pour des protéines appartenant à la même famille, nous avons décidé de nous concentrer dans un premiers temps à la caractérisation de ces deux seuls gènes, ceux-ci étant les meilleurs candidats pour expliquer le phénotype d'infertilité de `r nb_run_cfap`  de nos patients.    

Ainsi, un total de `r nb_run_cfap43_high + nb_run_cfap43_moderate` de nos patients révélèrent porter des variants homozygotes sur le gène *CFAP43*. En méttant de cotés les `r nb_run_cfap43_high` portant un variant ayant un effet tronquant évident, les variants portés par les `r nb_run_cfap44_moderate` autres patients révélèrent eux aussi avoir un effet probablement délétère. Le premier d'entre eux est un variants intronique non listé dans ExAC et prédit par Human Splicing Finder (http://www.umd.be/HSF3) comme altérant probablement le site consensus d'épissage de l'éxon 16 de *CFAP43*. Pour le second ...   

**détail des variants CFAP 44 (pareil que pour *CFAP43*)**

L'analyse au microscope éléctronique à transmission des celulles spermatiques d'un patient portant un variant sur *CFAP43* et d'un autre portant un variant sur *CFAP44* révéla des défauts au niveau de l'axonème ainsi qu'une gaine fibreuse désorganisée pour chacun des deux patients.  

Ensuite, afin de compenser l'absence d'anticorps anti-CFAP43 et anti-CFAP44 fiables chez l'humain comme chez la souris nous avons décidé de caractériser leur orthologues chez *Trypanosoma brucei* (*T. brucei*), un protozoaire flagellé utilisé comme organisme modèle dans l'études des flagelles chez qui, les protéines *Tb*CFAP43 et *Tb*CFAP44 respectivement orthologues de CFAP43 et CFAP44 avaient déjà été identifées comme des protéines du flagelles [@Broadhead2006; @Subota2014]. Ensuite, l'utilisation d'ARN interférence nous a permi de produire des organismes *knock-down* pour ces deux gènes *TbCFAP43*^RAi^ et *TbCFAP44*^RNAi^ nous permettant ainsi d'évaluer la fonction de ces deux gènes au sein du flagelle du trypanosome. Cela nous a permi d'observerun arret de la prolifération cellulaire au bout de 24h ainsi que de nombreux defauts au niveau des flagelles pour l'ensemble des lignées cellulaires *TbCFAP43*^RAi^ et *TbCFAP44*^RNAi^.   

Pour finir, l'impact de l'absence des protéines CFAP43 et 44 sur la spermatogénèse murine a été déterminé grâce à la génération de modèle KO utilisant la technologie CRISPR-Cas9 qui nous a permi d'obtenir des phénotype reproductible pour nos deux modèles de souris KO. Ces modèles nous ont permis d'observer que les mâles *Cfap43*^-/-^ et *Cfap44*^-/-^ présentaient tous deux de nombreuses anomalies au niveaux des flagelles tandis que les femelles *Cfap43*^-/-^ et *Cfap44*^-/-^ étaient elles parfaitement fertiles.  

Pour conclure, cette étude portant sur la caractérisation du phénotype MMAF de ... individus non apparentés. L'utilisation de notre pipeline pour l'analyse des données NGS nous a permis à la fois de confirmer l'importance du gène *DNAH1* dans la structure du flagelle et son implication dans ce phénotype, mais aussi d'identifier deux nouveaux gènes, *CFAP43* et *CFAP44* respectivement responsables du phénotype de `r nb_run_cfap43` et `r nb_run_cfap44` de nos patients soit `r p_run_cfap43` et `r p_run_cfap43`% de notre cohorte.


\newpage

```{r plottwohomohigh, cache=FALSE, fig.cap=fig_info,fig.scap=fig_name, fig.height=6, dependson="dftwohomohigh"}

fig_name <- "Listes des gènes sur lesquels un variants tronquant à l'état homozygote a été retrouvé chez au moins deux de nos patients"
fig_info <- paste0(fig_name, " : La couleur des barres indiquent le type de variants portés par chaque patient. Vert : variant homozygote tronquant, Orange variant homozygote non tronquant et rouge au moins deux variants hétérozygotes. Les gènes sont classés dans l'ordre décroissant en fonction du nombre de variants homozygotes tronquant retrouvés parmi nos patients.")

n_max <- df_bigmmaf_filter_reduce$N_TOT %>% max

ggplot(df_bigmmaf_filter_reduce, aes(reorder(reorder(reorder(SYMBOL,N_LOW), N_MODERATE), N_HIGH), N_RUN)) + 
  geom_col(aes(fill = EVIDENCE)) +
  scale_fill_manual(name = "Kind of variant", 
                    values = c("#4DAF4A", "#FF7F00", "#E41A1C"),
                    labels=c("Truncated homozygous", "Not truncated homozygous", "compound heterozygous?")) + 
  scale_y_continuous(breaks = (1:n_max)) +
  ylab("Nb of individuals") + 
  xlab("") +  
  coord_flip()  + 
  theme(legend.position = "bottom")

```


\newpage

## Conclusion  
