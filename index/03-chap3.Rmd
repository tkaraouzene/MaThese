---
output:
  word_document: default
  html_document: default
  pdf_document: default
  classoption: landscape
---
# Mise en place d’une stratégie pour l’analyse des données exomiques – application en recherche clinique  

```{r include.packages2, include=FALSE}
# This chunk ensures that the thesisdown package is
# installed and loaded. This thesisdown package includes
# the template files for the thesis.

if(!require(devtools))
  install.packages("devtools", repos = "http://cran.rstudio.com")
if(!require(thesisdown))
  devtools::install_github("ismayc/thesisdown")

library(thesisdown)
library(knitr)
library(tidyr)
library(dplyr)
library(data.table)
library(ggplot2)
library(stringi)
library(scales)
library(cowplot)
library(stringr)
library(foreach) 

theme_set(theme_gray()) # otherwise use cowplot default theme

source("script/manage_variants.R")
source("script/variant_filtering.R")
source("script/resume_data.R")
source("script/plot_vep_results.R")
source("script/gene_expression.R")

opts_knit$set(eval.after = c("fig.cap","fig.scap"))

knitr::opts_chunk$set(fig.align='center',echo=FALSE)

```

```{r localfunction, cache=TRUE}

open_ctrl <- function(file, pheno = "none") {
  
  fread(file, sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE) %>% 
    gather(RUN, CALL, starts_with("Ghs")) %>%
    filter(CALL %in% c(3, "c")) %>%
    mutate(N_CTRL = n_distinct(RUN),
           PHENO = pheno)  %>%
    select(-CALL) %>% 
    distinct(CHR, POSITION, REF, ALT, N_CTRL, PHENO)
}

`%tin%` <- function(x, y) {
    mapply(assign, as.character(substitute(x)[-1]), y,
      MoreArgs = list(envir = parent.frame()))
    invisible()
}

tab_gene <- function(df, gene) {
  
  tab_gene <- df %>% 
    filter(SYMBOL == gene) %>% 
    mutate(VARIANT = paste(CHR,POSITION,REF,ALT, sep = "-"),
           Consequence = sapply(strsplit(Consequence, "_variant", fixed = TRUE),"[[",1),
           Consequence = gsub("_", " ", Consequence)) %>%
    distinct(RUN, VARIANT, CALL, Consequence, SYMBOL) %>% 
    arrange(desc(CALL), RUN)
  
  run_homo <- tab_gene %>% filter(CALL == "Homozygous") %>% ungroup() %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
  run_het <- tab_gene %>% filter(CALL == "Heterozygous") %>% ungroup() %>% distinct(RUN) %>% collect() %>% .[["RUN"]]

  n_run_homo <- run_homo %>% length
  n_run_het <- run_het %>% length
  list(tab_gene, run_homo, run_het, n_run_homo, n_run_het)
}

na.replace <- function (x, char = "") {
    x[is.na(x)] <- char
    return(x)
}

```


## Intro  

<!-- Comme vu précédemment, l'émergence du séquençage haut débit, avec notamment le WGS et le WES, a révolutionné les méthodes de recherche dans le cadre d'étude phénotype-génotype en permettant de manière rapide et à moindre coup le séquençage de la quasi totalité des gènes humains. Les causes de plusieurs centaines de pathologies ont pu être identifiées grâce à ces technique depuis leur premier succès pubilié en 2010 [@Ng].  Dès lors, l'analyse des données issues du séquençage est devenu la clef dans la réussite de ces études.  -->

<!-- Il existe de nombreux logiciels qui à partir des variants appelés effectuent les étapes d'annotation et de filtrage. C'est par exemple le cas d'Exomiser [TODO: insert ref and Exomiser describtion] ou encore de [TODO: insert at least one other soft]. La plupart de ces logiciels fonctionnent très bien, cependant tous prennent pour point de départ des variants appelés en amont. Ils ne contrôlent donc en aucune manière les étapes d'alignement et d'appel des variants. Or, comme il a été dit plus tôt, ces deux étapes constituent la bases de l'analyse [TODO insert ref] et les résultats -->

<!-- Ce chapitre décrit la constitution et l’utilisation d’un pipeline d’analyse des données de séquençage exomique et son utilisation dans le cadre de la recherche de mutations entrainant différents phénotypes d’infertilité. La difficulté des études génétiques visant à identifier des gènes pathogènes vient de l’abondance de variants rares chez tout un chacun et de la difficulté d’effectuer des tris efficaces et justes pour ne retenir que la ou les mutations causales. Thomas développe un pipeline se basant sur des outils existant mais permettant d’effectuer des tris successifs efficaces et pertinents   -->

\newpage

## Résultats  


```{r allruns}


df_runs <- fread("data/exome_runs.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, data.table = FALSE) %>%
  rename(Phenotype = Pathologie) %>%
  filter(Phenotype != "TVPC")

run_az_fam <- c("Ghs44","Ghs45")
run_ff_fam <- c("Ghs113","Ghs117")
run_mmaf_fam <- c("Ghs56","Ghs58","Ghs62","Ghs130","Ghs63","Ghs119","Ghs59","Ghs60","Ghs61")

run_all_fam <- c(run_az_fam, run_ff_fam, run_mmaf_fam)

df_runs_analysed <- df_runs %>% 
  filter(Phenotype == "Flag" | 
           `Magic ID` %in% run_all_fam)

resume_pheno <- df_runs %>% 
  group_by(Phenotype) %>% 
  summarise(N_per_Patho = n()) %>% 
  spread(Phenotype, N_per_Patho) %>% 
  rename(Azoospermia = Azoo, 
         MMAF = Flag, 
         `Fertilization failure` = Fert_fail, 
         Globozoospermia = Globo, 
         Macrozoospermia = Macro,
         `Oocyte defect` = Ovo,
         Healthy = CTRL) %>% 
  gather(Phenotype,`Nb of individuals`, Azoospermia:`Oocyte defect`)


resume_tot <- resume_pheno %>% 
  ungroup() %>% 
  summarise(N_tot = sum(`Nb of individuals`),
            N_pheno = n_distinct(Phenotype) - 1)



```

```{r}

n_tot_runs <- resume_tot %>% collect() %>% .[["N_tot"]]
n_pheno_tot <- resume_tot %>% collect() %>% .[["N_pheno"]]

n_run_analysed <- df_runs_analysed %>% nrow
n_run_fam <- run_all_fam %>% length

n_run_bigmmaf <- n_run_analysed - n_run_fam

```

Dans cette partie, nous allons détailler les résultats de l'analyse des données de WES de `r n_run_analysed` patients tous atteins d'un phénotype d'infertilité. Ces études seront séparées en deux parties distinctes, la première se concentrera sur l'études de ... familles incluant `r n_run_fam` de ces patients. Le seconde portera sur l'analyse des `r n_run_bigmmaf` patients restant étant tous non-apparentés et présentant un phénotype MMAF. 


### Description de la pipeline  

Après avoir été séquencés les données receuillies pour ces patients sont procéssés au sein de la même pipeline d'analyse qui comprend quatre étapes allant de l'alignement de *reads* au filtrage des variants : 

1. **L'alignement** : L'alignement des *reads* le long du génome de référence (hg19 / GHRC37) est effectué par le logiciel MAGIC [@Su2014]. Afin d'écarté toute ambiguité au moment de l'interprétation de l'alignement, l'intégralité des *reads* dupliqués et / ou s'alignant à plusieurs zones du génome  seront filtrés et ne seront donc pas pris en compte pour l'ensemble des analyses en aval. Suite à celà,, MAGIC va produire quatre comptages pour chaque position couverte du génome : R+, V+, R- et V- :  
    a. **R+ et R-** : Ces deux comptages correspondent au nombre de *reads* *forward* (+) et *reverse* (-) sur lesquels est observé l'allèle de **référence** (R) à une position donnée.  
    b. **V+ et V-** : À l'inverse de R+ et R-, ces comptages correspondent au nombre de *reads* *forward* et *reverse* sur lesquels est observé un allèle de **variant** (V) à une position donnée.  
2. **L'appel des variants** : Comme nous l'avons vu plus [tôt](#varcall), il est fortement conseillé d'effectuer l'appel des variants en tenant compte de l'aligneur choisi [@Nielsen2011, @DePristo2011, @Lunter2011]. C'est pourquoi, nous avons conçu notre propre algorithme d'appel des variants spécialement conçu pour l'analyse des données de MAGIC. Ainsi, l'appel des variants sera directement basé sur les quatre comptages vus précédemment. Tout d'abord, les positions ayant une couverture < 10 sur l'un des deux *strands* sera considérée comme de faible qualité, celles ayant   une couverture < 10 sur les deux *strands* seront exclus. Ensuite pour chaque variant, des appels indépendants seront effectués pour chaque *strand*. L'appel final sera une synthèse de ces deux appels où seul les cas où ces deux appels sont concordants seront considérés comme de bonne qualité.    
3. **L'annotation** : Chaque variant retenu sera ensuite annoté tout d'abord par le logiciel *variant effect predictor* (VEP) [@McLaren2016] qui nous indiquera pour chaque variant la conséquence que celui-ci aura sur la séquence codante de l'ensemble des transcrits Ensembl qu'il chevauche (**Figure : **\@ref(fig:figvepcsq)) (**Table : **\@ref(tab:tabvepcsq)). Ensite, nous ajoutons récuperons pour chaque gène son expression tissulaire en nous basant sur le projet Illumina BodyMap [TODO ref] qui recanse les données RNAseq des gènes humains pour 16 tissus différents. Suite à cela nous ajoutons, lorsque celle-ci est disponible, la fréquence du variant dans les bases de données ExAC [@Lek2016], ESP600 [TODO] et 1000Genomes [TODO] donnant ainsi une estimation de sa fréquence dans la population générale. De même, la particularité de ce pipeline est qu'elle conserve l'ensemble des variants identifiés dans les études effectuées précédemment permettant d'ajouter aux annotations la fréquence d'un variant chez les individus déjà séquencé et donc la fréquence d'un variant dans chaque phénotype étudié créant ainsi une base de données interne qui pourra servir de contrôle dans les études ultérieur.    

```{r figvepcsq, fig.cap=fig_info,fig.scap=fig.name, out.extra="scale=.9"}


fig.name <- "Listes des différentes conséquences prédites par VEP et leur positionnement sur le transcrit"
fig_description <- ""
fig.from <- "[VEP site](http://www.ensembl.org/info/genome/variation/consequences.jpg)"
fig_info <- paste0(fig.name," d'après ",fig.from)

include_graphics(path = "figure/vep_csq.jpg")


```

4. **Le filtrage des variants** : L'étape de filtrage est extrêmement importante si l'on souhaite analyser de manière efficace les données provenant de WES. C'est pourquoi elle occupe une place importante dans notre pipeline. L'intégralité des paramètres de cette étape peuvent être modifier par l'utilisateur de sorte à faire correspondre les critères de filtre aux besoins de l'étude. Afin de rendre son utilisation le plus efficace possible, nous avons souhaité définir des paramètres par défauts pertinent dans la plupart des études de séquençage exomique de sorte que à moins que le contraire ne soit spécifié, seul les variants impactant les transcrits codant pour une protéine sont conservés. De même les variants synonymes ou affectant les séquences UTRs sont filtrés ainsi que les variants ayant une fréquence $\ge$ 1% dans les bases dans l'une des bases données (ExAC, ESP6500 ou 1KH). Aussi, pour un phénotype donné, l'ensemble des variants observés chez les individus étudiés présentant un phénotype différent sont de même enlevés de la liste finale.   

\newpage
\blandscape

```{r tabvepcsq}


df_vep_csq <-  fread("data/vep_csq_modif.csv", sep = "\t", header = TRUE, showProgress = FALSE, data.table = FALSE, verbose = FALSE) %>%
  select(`VEP consequence` = `Display term`,
         `VEP impact` = IMPACT,
         Description = `SO description`)

pander::pander(df_vep_csq,
               justify = 'left',
               split.cells = c(.5,1,50),
               caption = "(\\#tab:tabvepcsq) Liste simplifiée des conséquences prédites par VEP avec leur description et impact associée")


```

\elandscape

\newpage

### Utilisation du pipeline dans des cas familiaux :  

#### Description des familles 

```{r recapfam}

df_seq <- data_frame(FAM = c("AZ","FF","MMAF1","MMAF2","MMAF3","MMAF4"),
                     CONSANGUINITY = c("Yes","Yes","No","Yes","No","No"),
                     NB = c(2,2,2,2,2,3),
                     INDIV = c("AZ1, AZ2","FF1, FF2", "MMAF1.1, MMAF1.2", "MMAF2.1, MMAF2.2", "MMAF3.1, MMAF3.2", "MMAF4.1, MMAF4.2, MMAF4.3"),
                     PHENOTYPE = c("Azoospermia","Fertilization failure","MMAF","MMAF","MMAF","MMAF"),
                     YEAR = c(2012,2014,2014,2014,2014,2014),
                     # PLATFORM = c("Illumina HiSeq2000","Illumina HiSeq2000","Illumina HiSeq2000","Illumina HiSeq2000","Illumina HiSeq2000","Illumina HiSeq2000"),
                     PLACE = c("Mount Sinai Institut","Genoscope (Evry)","Genoscope (Evry)","Genoscope (Evry)","Genoscope (Evry)","Genoscope (Evry)")) 

n_fam <- df_seq %>% summarise(N_FAM = n_distinct(FAM)) %>% collect() %>% .[["N_FAM"]] 
n_min_fam <- df_seq %>% collect() %>% .[["NB"]] %>% min 
n_max_fam <- df_seq %>% collect() %>% .[["NB"]] %>% max 
n_consanguinity_fam <- df_seq %>% filter(CONSANGUINITY == "Yes") %>% nrow
n_not_consanguinity_fam <- n_fam - n_consanguinity_fam

nb_pheno <- df_seq %>% summarise(N_PHENO = n_distinct(PHENOTYPE)) %>% collect() %>% .[["N_PHENO"]] 

```

Dans cette partie, je me concentre sur l'analyse bioinformatique des résultats des séquençages exomiques effectués entre `r min(df_seq$YEAR)` et `r max(df_seq$YEAR)` de `r sum(df_seq$NB)` individus infertiles provenant de `r n_fam` familles différentes. Parmi celles-ci, `r nb_pheno` phénotypes différents ont été observés : 

1. **[L'Azoospermie](#infquant) :** Comme nous avons pu le voir, l'azoospermie est un phénotype d'infertilité masculine caractérisé par l'absence de spermatozoïde dans l’éjaculât    
2. **Échec de fécondation :**  Ce phénotype d'infertilité se caractérise par l'incapacité des spermatozoïdes à féconder l'ovocyte.  
3. **MMAF** :  Le syndrome MMAF (*multiple morphological abnormalities of the sperm flagella*) caractérise comme son nom l'indique les patients présentant une majorité de spermatozoïdes atteins par une mosaïque d'anomalie morphologique du flagelle.  

Parmi ces `r n_fam` chacune composée de `r n_min_fam` à  `r n_max_fam` frères, `r n_consanguinity_fam` d'entre elles présentent un historique de consanguinité, les parents étant soit cousins germains, pour les familles ... et ..., soit cousins au second degré, pour la famille ... . La consanguinité favorisant la transmission de variants à l'état homozygote, nous avons décidé, dans un premiers temps de concentrer nos analyses uniquement sur les variants (SNVs et indels) homozygotes pour l'ensemble des familles. Pour les `r n_not_consanguinity_fam` familles n'ayant pas d'historique de consanguinité, ce choix nous permet de réduire la liste des variants candidats de sorte à faciliter les analyses. L'études des variants hétérozygotes sera effectuée *a posteriori* pour les familles dont la cause génétique du phénotype n'a pas pu être identifiée en se limitant aux variants homozygotes. Un récapitulatif des familles et de leur phénotype est disponible dans la table \@ref(tab:tabrecapfam).    


\newpage
\blandscape


```{r tabrecapfam}

tab.name <- "Tableau récapitulatif des familles séquencées et de leur phénotype"

kable(df_seq %>% select(-NB),
      col.names = c("Family","Consanguinity", "Individuals","Phenotype","Year","Place"),
      caption = tab.name,
      longtable = TRUE,
      booktabs = TRUE)

```

\elandscape
\newpage  

#### Résultats des exomes  

##### Résultat de l'alignement  

```{r runstrandness, warning=FALSE, cache=TRUE}

df_read_fate_nb <- fread("data/magic_results/All_Exomes.read_fate.txt", sep = "\t", data.table = FALSE, header = TRUE, drop = c(1,3:5,7:23)) %>% 
    select(-contains("entropy"), -contains("but"), -contains("insert")) %>% 
  rename(RUN = `# Run`,
         `Map to 1 site` = `% reads, mapping uniquely to 1 genomic site and maximum 1 gene`,
         S2 = `% reads, mapping to 2 to 9 sites`,
         S10 = `% Rejected because they map to 10 or more`) %>% 
  filter(RUN != "All runs") %>%
  mutate(`Map to 2 or more sites`  = S2 + S10) %>% 
  select(-S2, -S10) %>% 
  filter(RUN %in% run_all_fam) %>% 
  gather(QUALITY, NB_OF_READS, `Raw reads`:`Map to 2 or more sites`) 

pair_stat <- fread("data/magic_results/All_Exomes.pair_stats.txt", sep = "\t", data.table = FALSE, skip = 42, header = FALSE) %>% transpose() 
names(pair_stat) <- pair_stat[1,] 

pair_stat <- pair_stat %>%
  filter(Run %in% run_all_fam) %>%
  select(RUN = Run, Compatible_pairs, Non_compatible_pairs, `Orphans Any`) %>% 
  rename(`Compatible` = Compatible_pairs,
         `Non compatible` = Non_compatible_pairs,
         Orphans = `Orphans Any`) %>%
  gather(QUALITY, NB_OF_READS, Compatible:Orphans) %>%
  mutate(NB_OF_READS = as.numeric(NB_OF_READS)) 

df_reads_summary <- rbind(df_read_fate_nb, pair_stat) %>% 
  mutate(IS_RETAINED = if_else((QUALITY == "Raw reads" |
                                   QUALITY == "% Well mapped" |
                                   QUALITY == "Compatible" |
                                   QUALITY == "Map to 1 site"), "Yes", "No" ),
         NB_OF_READS = if_else(QUALITY == "Raw reads", NB_OF_READS, NB_OF_READS / 100))

```

```{r}

raw_reads_median <- df_reads_summary %>% filter(QUALITY == "Raw reads") %>% collect() %>% .[["NB_OF_READS"]] %>% median %>% as.integer
unmap_reads_min <- df_reads_summary %>% filter(QUALITY == "% Unmapped") %>% collect() %>% .[["NB_OF_READS"]] %>% min %>% round(3) * 100
unmap_reads_max <- df_reads_summary %>% filter(QUALITY == "% Unmapped") %>% collect() %>% .[["NB_OF_READS"]] %>% max %>% round(3) * 100

max_site_1 <- df_reads_summary %>% filter(QUALITY == "Map to 1 site") %>% collect() %>% .[["NB_OF_READS"]] %>% max %>% round(3) * 100
min_site_1 <- df_reads_summary %>% filter(QUALITY == "Map to 1 site") %>% collect() %>% .[["NB_OF_READS"]] %>% min %>% round(3) * 100


comp_reads_median <- df_reads_summary %>% filter(QUALITY == "Compatible") %>% collect() %>% .[["NB_OF_READS"]] %>% median %>% round(3) * 100

```


Pour rappel, l'[alignement]({#lalignement}) consiste à repositionner l'ensemble des *reads* générés au cours de l'étape de séquençage le long d'un génome de référence. 

La quantité de *reads* composant les exomes de chaque individu peut varier en fonction de plusieurs paramètres et n'est donc pas égale pour chaque patient bien que l'ordre de grandeur reste le même avec une médiane de `r raw_reads_median` *reads*. Seuls les deux frères AZ1 et AZ2 se distinguent avec près de 3 fois plus de *reads* que les autres patients. Cette différence peut être expliqué car ces deux patients sont les deux seuls à voir été séquencé au Mount Sinaï Institut or leur protocole d'amplification précédent le séquençage contient un nombre de cycles de PCR supérieur à ceux appliqué au Génopole d'Évry où ont été séquencé les autres patients. Il faut noter que ce nombre plus important de *reads* n'est en rien le reflet d'une meilleure qualité. En effet, ce nombre important de *reads* est causé par une grande quantité de *reads* dupliqués qui seront pour la plupart filtrés au cours des analyses ulterieure (**Table :**  \@ref(tab:tabrecapfam), **Figure : **\@ref(fig:readsselection) - **A**).  

L'ensemble de nos exomes ayant été réalisés en *paired-end*, les deux extrémités de chaque fragment sont séquencées. Chaque *end* d'un même *read* peut donc être considéré comme un *read* à part entière qui sont alignées **indépendamment** le long du génome de référence. L'information fournit par le *paired-end* n'étant utilisé qu'à *posteriori* en tant que critère qualité. La première étape du contrôle qualité des *reads* consiste filtrer les *reads* ne s'étant pas aligné sur le génome. Ces *reads* sont extrêmement minoritaires puisqu'ils ne représentent qu'entre `r unmap_reads_min` et `r unmap_reads_max` % des *reads* de nos individus (**Figure : **\@ref(fig:readsselection) - **B**).  

Une fois cela fait, nous vérifions la "compatibilité" des deux *ends* composant chacun des *reads* s'étant correctement alignés. Un *reads* est dit compatible lorsque les deux *ends* qui le composent s'alignent face à face (une sur le *strand* + et l'autre sur le *strand* -) et couvrent une zone ne faisant pas plus de 3 fois la taille médiane de l'insert. Les *reads* dont les deux *ends* se sont alignées mais ne remplissant pas ces conditions seront dit "Non compatible", ceux dont une seule des deux *ends* s'est alignés seront appelés "orphelins". Dans nos analyses, seuls les *reads* compatibles sont conservés, c'est à dire environs `r comp_reads_median` % des *reads* s'étant correctement alignés.  (**Figure : **\@ref(fig:readsselection) - **C**).  

La dernière étape de ce contrôle-qualité consiste à analyser le nombre de site auxquels se sont alignés les *reads*. En effet, certaine zone du génome étant dupliqué, l'une des problématiques des *short-reads* est qu'il est possible que ceux-ci s'alignent à plusieurs régions différentes du génome. Afin d'éviter toute ambiguïté, seul ceux s'étant aligné sur un site unique sont conservés pour la suite des analyses. Ces *reads* représente entre `r min_site_1` et `r max_site_1` % des *reads* ayant passé les précédents filtres (**Figure : **\@ref(fig:readsselection) - **C**).  

Les *reads* ayant passé l'ensemble des critères qualité mentionnés précédemment seront ensuite utilisés pour effectuer l'appel des variants.     

\newpage

```{r readsselection, fig.cap=fig_info,fig.scap=fig_name,fig.width=6.3, fig.height=6.9, cache=TRUE}

fig_name <- "Processus simplifié du contrôle qualité des *reads*"
fig_description_all <- "Pour chacun des graphiques, les *reads* représentés en vert sont conservés tandis que ceux en rouge sont filtrés"
fig_description_A <- "**A** : Quantité de *reads* bruts générés pour chaque patient au cours de l'étape de séquençage. La médiane des *reads* est représentée en bleue"
fig_description_B <- "**B** : Pourcentage pour chaque individu de *reads* s'étant aligné correctement et ne s'étant pas alignés sur le génome de référence"
fig_description_C <- "**C** : Distribution pour chaque patient des *reads* compatibles (Comp), non compatibles (Non comp) et orphelins (Orphans)"
fig_description_D <- "**D** : Présentation pour chaque *reads* du nombre de site auxquels ils s'alignent"
fig_description <- paste(fig_description_all, fig_description_A,fig_description_B,fig_description_C, fig_description_D, sep = ". ")

fig_info <- paste0(fig_name, " : ", fig_description)

pA <- ggplot(df_reads_summary %>% filter(QUALITY == "Raw reads"), aes(RUN, NB_OF_READS)) + 
  geom_bar(stat = "identity", aes(fill = IS_RETAINED)) + 
  xlab("") + 
  ylab("Nb of raw reads") + 
  # scale_x_discrete(labels = c("AZ1","AZ2","FF1","FF2","MMAF1.1","MMAF1.2","MMAF2.1","MMAF2.2","MMAF3.1","MMAF3.2","MMAF3.3")) + 
  scale_fill_manual(values = c("chartreuse3", "#E41A1C"), guide = "none") +
  geom_hline(col = "blue", aes(yintercept = raw_reads_median)) + 
  geom_text(data=data.frame(x=0,y=median(df_reads_summary$NB_OF_READS)), col = "blue", x = 12.5, y = 110000000, label = raw_reads_median)
  

pB <- ggplot(df_reads_summary %>% 
               filter(QUALITY == "% Well mapped" | 
                        QUALITY == "% Unmapped"), aes(QUALITY, NB_OF_READS)) + 
  geom_boxplot(outlier.size = -1, aes(fill = IS_RETAINED)) + 
  geom_jitter(position=position_jitter(0.3)) +
  facet_wrap(~factor(QUALITY, levels = c("% Well mapped", "% Unmapped")), scales = "free", nrow = 1) + 
  ylab("% of reads") +
  scale_y_continuous(labels = percent) + 
  xlab("") + 
  scale_fill_manual(values = c("#E41A1C", "chartreuse3"), guide = "none") + 
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

pC <- ggplot(df_reads_summary %>% 
         filter(QUALITY == "Compatible" | 
                  QUALITY == "Non compatible" |
                  QUALITY == "Orphans") %>%
           mutate(QUALITY = if_else(QUALITY == "Compatible", "Comp",
                                    if_else(QUALITY == "Non compatible", "Non comp", QUALITY))), aes(QUALITY, NB_OF_READS)) + 
         geom_boxplot(outlier.size = -1, aes(fill = IS_RETAINED)) + 
         geom_jitter(position=position_jitter(0.3)) +
  facet_wrap(~QUALITY, scales = "free", nrow = 1) + 
  ylab("% of reads") +
  scale_y_continuous(labels = percent) + 
  xlab("") + 
  scale_fill_manual(values = c("#E41A1C", "chartreuse3"), guide = "none") + 
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y = element_blank())

pD <- ggplot(df_reads_summary %>% 
               filter(QUALITY == "Map to 1 site" | 
                        QUALITY == "Map to 2 or more sites"), aes(QUALITY, NB_OF_READS)) + 
  geom_boxplot(outlier.size = -1, aes(fill = IS_RETAINED)) + 
  geom_jitter(position=position_jitter(0.3)) +
  facet_wrap(~QUALITY, scales = "free", nrow = 1) + 
  scale_fill_manual(name = "Retained read ?", values = c("#E41A1C", "chartreuse3")) +
  ylab("% of reads") +
  xlab("") + 
  scale_y_continuous(labels = percent) + 
  theme(axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        legend.position="bottom") +
  coord_flip()


row1 <- plot_grid(pA, labels = c("A"))
row2 <- plot_grid(pB,pC, ncol = 2,labels = c("B","C"))

plot_grid(row1,row2, pD, ncol = 1, labels = c("","","D"), rel_heights = c(1,.7,.7, .7))

```

\newpage

##### Résultat de l'appel des variants  

```{r varcall, cache=TRUE} 

call_file <- "results/all_call.rds"

if (!file.exists(call_file)) {
  
  
call <- function(file, fam, run) {

fread(file, sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, data.table = FALSE) %>% 
    gather(RUN, CALL, starts_with("Ghs")) %>% 
  filter(CALL != "*",
         CALL != "a",
         CALL != 1) %>% 
  mutate(RUN = run,
         FAM = fam, 
         TYPE = if_else(stri_length(REF) == stri_length(ALT), "SNV", "Indel"), 
         STRAND = if_else(CALL %in% c(2:9), "DS", 
                          if_else(CALL == 0, "NS", "SS")),
         CALL = if_else(CALL %in% c(2,"b"),"Heterozygous",
                        if_else(CALL %in% c(3,"c"), "Homozygous",
                                if_else(CALL %in% c(4:7,"d","e","f","g","h","i"),"Ambigous call",
                                                if_else(CALL %in% c(8,9), "Discordant call",
                                                        if_else(CALL == 0, "NA", paste0("ERROR !!!: ",CALL)))))))
  
}

df_call_az1 <- call(file = "data/call_results/call_az1.csv", fam = "AZ", run = "AZ1")
df_call_az2 <- call(file = "data/call_results/call_az2.csv", fam = "AZ", run = "AZ2")
df_call_ff1 <- call(file = "data/call_results/call_ff1.csv", fam = "FF", run = "FF1")
df_call_ff2 <- call(file = "data/call_results/call_ff2.csv", fam = "FF", run = "FF2")
df_call_mmaf1_1 <- call(file = "data/call_results/call_mmaf1_1.csv", fam = "MMAF1", run = "MMAF1.1")
df_call_mmaf1_2 <- call(file = "data/call_results/call_mmaf1_2.csv", fam = "MMAF1", run = "MMAF1.2")
df_call_mmaf2_1 <- call(file = "data/call_results/call_mmaf2_1.csv", fam = "MMAF2", run = "MMAF2.1")
df_call_mmaf2_2 <- call(file = "data/call_results/call_mmaf2_2.csv", fam = "MMAF2", run = "MMAF2.2")
df_call_mmaf3_1 <- call(file = "data/call_results/call_mmaf3_1.csv", fam = "MMAF3", run = "MMAF3.1")
df_call_mmaf3_2 <- call(file = "data/call_results/call_mmaf3_2.csv", fam = "MMAF3", run = "MMAF3.2")
df_call_mmaf4_1 <- call(file = "data/call_results/call_mmaf4_1.csv", fam = "MMAF4", run = "MMAF4.1")
df_call_mmaf4_2 <- call(file = "data/call_results/call_mmaf4_2.csv", fam = "MMAF4", run = "MMAF4.2")
df_call_mmaf4_3 <- call(file = "data/call_results/call_mmaf4_3.csv", fam = "MMAF4", run = "MMAF4.3")

df_call_fam <- rbind(df_call_az1, 
                       df_call_az2,
                       df_call_ff1, 
                       df_call_ff2,
                       df_call_mmaf1_1,
                       df_call_mmaf1_2,
                       df_call_mmaf2_1,
                       df_call_mmaf2_2,
                       df_call_mmaf3_1,
                       df_call_mmaf3_2,
                       df_call_mmaf4_1,
                       df_call_mmaf4_2,
                       df_call_mmaf4_3)

rm(df_call_az1,
   df_call_az2,
   df_call_ff1, 
   df_call_ff2,
   df_call_mmaf1_1,
   df_call_mmaf1_2,
   df_call_mmaf2_1,
   df_call_mmaf2_2,
   df_call_mmaf3_1,
   df_call_mmaf3_2,
   df_call_mmaf4_1,
   df_call_mmaf4_2,
   df_call_mmaf4_3)
gc()


saveRDS(df_call_fam,call_file)

} else {
  
  df_call_fam <- readRDS(call_file)
  
}

df_strand_all <-  df_call_fam %>%
  select(RUN, STRAND) %>% 
  group_by(RUN, STRAND) %>%
  summarise(N = n()) %>%
  group_by(RUN) %>%
  mutate(P = N / sum(N),
         IS_RETAINED = if_else(STRAND == "NS","No",
                               if_else(STRAND == "DS", "Yes", "Yes but low quality")))
     
df_concordance_all <- df_call_fam %>%
  select(RUN, CALL, STRAND) %>%
  filter(STRAND == "DS") %>% 
  mutate(CALL = if_else(grepl("zygous", CALL), "Concordant call", CALL)) %>%
  group_by(RUN, CALL) %>%
  summarise(N = n()) %>%
  group_by(RUN) %>%
  mutate(P = N / sum(N),
         IS_RETAINED = if_else(CALL == "Concordant call","Yes","No"))

df_geno_all <- df_call_fam %>%
  select(RUN, CALL, TYPE) %>%
  filter(grepl("zygous", CALL)) %>% 
  group_by(RUN, CALL, TYPE) %>%
  summarise(N = n()) %>% 
  group_by(RUN) %>%
  mutate(P = N / sum(N),
         IS_RETAINED = if_else(grepl("zygous", CALL),"Yes","No")) %>%
  bind_rows(data_frame(RUN = "AZ1", CALL = "Heterozygous", TYPE = "Indel", N = 0, P = 0, IS_RETAINED = "No")) %>% # it permits to have the "no" field in the legend of the barplot
  bind_rows(data_frame(RUN = "AZ1", CALL = "Heterozygous", TYPE = "Indel", N = 0, P = 0, IS_RETAINED = "Yes but low quality")) 

```


```{r}

median_percent_ss <- df_strand_all %>% filter(STRAND == "SS") %>% collect() %>% .[["P"]] %>% median %>% round(3) * 100 
median_percent_ds <- df_strand_all %>% filter(STRAND == "DS") %>% collect() %>% .[["P"]] %>% median %>% round(3) * 100 

min_percent_ns <- df_strand_all %>% filter(STRAND == "NS") %>% collect() %>% .[["P"]] %>% min %>% round(3) * 100
max_percent_ns <- df_strand_all %>% filter(STRAND == "NS") %>% collect() %>% .[["P"]] %>% max %>% round(3) * 100


concordant_median <- df_concordance_all %>% ungroup() %>% filter(CALL == "Concordant call") %>% collect() %>% .[["P"]] %>% median %>% round(3) * 100
wrong_median <- 100 - concordant_median

median_het_snv <- df_geno_all %>% filter(TYPE == "SNV" & CALL == "Heterozygous") %>% collect() %>% .[["N"]] %>% median %>% as.integer
median_het_indel <- df_geno_all %>% filter(TYPE == "Indel" & CALL == "Heterozygous") %>% collect() %>% .[["N"]] %>% median %>% as.integer

median_homo_snv <- df_geno_all %>% filter(TYPE == "SNV" & CALL == "Homozygous") %>% collect() %>% .[["N"]] %>% median %>% as.integer
median_homo_indel <- df_geno_all %>% filter(TYPE == "Indel" & CALL == "Homozygous") %>% collect() %>% .[["N"]] %>% median %>% as.integer
```

Comme dit précédemment, l'appel des variants fait suite à l'alignement et consiste à comparer la séquence d'un individu avec celle d'un génome de référence afin d'en relever les différences. La particularité de notre algorithme d'appel est d'effectuer pour chaque position deux appels indépendants Le premier sera effectué en utilisant uniquement les *reads forward* et le second le *reads reverse*. Encore une fois, plusieurs filtres sont appliqués de sorte à conserver uniquement les variants les plus qualitatifs. 

Tout d'abord, nos appels sont classés en trois catégories : 

1. **Les appels *double strand* (DS) :**  Qualifie les positions ayant une couverture $\ge$ 10 sur **les deux** strands. Ces appels sont ceux sont ceux ayant la meilleure qualité 
2. **Les appels *single strand* (SS) :**  Ces appels définissent les positions pour lesquels **un des deux** *strands* présentent une couverture $\le$ 10. Dans ce cas, ce *strand* est ignoré et l'appel est effectué uniquement en utilisant le second *strand*.   
3. **Les appels *non strand* (NS) :** Les positions NS sont celles pour lesquelles la couverture est $\le$ 10 sur **les deux** strands. Aucun appel n'est effectué à ces positions.  

Dans nos données, les appels SS sont majoritaires et représentent environ `r median_percent_ss` % de nos appels (contre `r median_percent_ds` % d'appels DS). Au vus de l'importance de ces appels, nous avons fait le choix de les conserver afin de ne pas filtrer une quantité trop importante de données. Ces appels seront cependant considérés comme étant de faible qualité, de fait, leurs analyses et interprétation seront plus précautionneuses En revanche, au vus de la trop grande incertitude de l'appel des variants NS, ceux-ci sont systématiquement filtrés éliminant ainsi entre `r min_percent_ns` et `r max_percent_ns` % des positions appelées (**Figure : **\@ref(fig:plotvarcall) - **A**).  

Un second filtre est appliqué aux variants ayant été précédemment appelés DS. Celui-ci consiste à comparer les appels effectués indépendamment sur chacune des deux *ends* et à vérifier leur concordance, c'est à dire que les deux appels soit identique. Les appels discordant et ambigus sont filtrés, soit environ `r concordant_median` % des variants DS. Il est intéressant de noter que bien que les variants *single strand* (SS) soient conservés, on peut s'attendre à ce qu'environ `r wrong_median` % de ceux-ci soient aberrants, ceux-ci n'ayant pu subir le même contrôle que les SS (**Figure : **\@ref(fig:plotvarcall) - **B**). 

 <!-- TODO : mettre figure avec % reads et coverage pour expliquer notre algo d'appel  -->

Pour l'ensemble des variants ayant passé les filtres énoncés ci-dessus, c'est à dire les variants SS et les variants DS avec appels concordants, le génotype est déterminé en fonction du pourcentage de *reads* portant le variant à cette position. Par exemple, si à une position donnée, 0% des *reads* portent un variant, l'individu sera appelé "Homozygote référence", si 50% des *reads* sont porteurs d'un variant, l'appel sera "hétérozygote" et si 100% des *reads* portent un variant, l'appel sera "Homozygote variant". Ainsi, pour chaque individu nous avons pu établir une liste de SNVs et d'indels avec leur génotype associé. Pour chacun de nos `r n_run_fam` patients les ordres de grandeur du nombre de variants appelés sont identique. Ainsi pour chaque patient nous avons appelés environ `r median_het_snv + median_het_indel` variants hétérozygotes (`r median_het_snv` SNVs et `r median_het_indel` indels) et `r median_homo_snv + median_homo_snv` variants homozygotes (`r median_homo_snv` SNVs et `r median_homo_indel` indels) (**Figure : **\@ref(fig:plotvarcall) - **C**).    

\newpage

```{r plotvarcall, dependson="varcall", fig.cap=fig_info,fig.scap=fig_name,fig.width=7, fig.height=7, cache=TRUE}

fig_name <- "Contrôle qualité des variants appelés"
fig_description_all <- "Pour chacun des graphiques, les variants représentés en vert et en orange sont conservés tandis que ceux en rouge sont filtrés"
fig_description_A <- "**A** : Distribution du *stranding* des appels pour chaque patient"
fig_description_B <- "**B** : Comparaison des appels entre les deux *ends* des variants appelés DS"
fig_description_C <- "**C** : Distribution des SNVs et indels en fonction de leur génotype pour chaque patients (représentés par une barre"
fig_description <- paste(fig_description_all, fig_description_A,fig_description_B,fig_description_C, sep = ". ")
fig_info <- paste0(fig_name, " : ", fig_description)

pA <- ggplot(df_strand_all, aes(STRAND, P)) +
  geom_boxplot(outlier.size = -1, aes(fill = IS_RETAINED)) + 
  geom_jitter(size = 2, position=position_jitter(0.3)) +
  ylab("% of called variant") +
  xlab("") +
    facet_wrap(~factor(STRAND, levels = c("DS", "SS", "NS")), scales = "free") +
  scale_fill_manual(guide = "none", values = c("#E41A1C", "chartreuse3", "#FF7F00")) +
  scale_y_continuous(labels = percent) + 
  theme(axis.title.x = element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

pB <- ggplot(df_concordance_all, aes(CALL, P)) +
  geom_boxplot(aes(fill = IS_RETAINED), outlier.size = -1) + 
  geom_jitter(size = 2, position=position_jitter(0.3)) +
  ylab("% of called variant") +
  xlab("") +
  facet_wrap(~factor(CALL, levels = c("Concordant call", "Ambigous call", "Discordant call")), scales = "free") +
  scale_fill_manual(guide = "none", values = c("#E41A1C", "chartreuse3")) + 
  scale_y_continuous(labels = percent) + 
  theme(axis.title.x = element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

pC <- ggplot(df_geno_all,aes(RUN, N)) + 
  geom_bar(stat = "identity", aes(fill = IS_RETAINED)) +
  facet_grid(TYPE~CALL, scales = "free") +
  ylab("Nb of variant") + 
  scale_fill_manual(name = "Is the variant retained?", values = c("#E41A1C", "chartreuse3", "#FF7F00"), breaks = c("Yes","Yes but low quality", "No")) +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        legend.position = "bottom")

row1 <- plot_grid(pA, labels = c("A"))
plot_grid(row1, pB, pC,labels = c("","B","C"), rel_heights = c(.6,.8,1), ncol = 1)

```

\newpage

##### Résultats de l'annotation  

```{r retrieveannotation, cache=TRUE} 

annotate_file <- "results/annotate_variants.rds"

if (!file.exists(annotate_file)) {

  df_annotate <- df_call_fam %>%
    filter(grepl("zygous", CALL)) %>% 
    select(-STRAND) %>%
    variant_join(fread("data/all_variants_vep81.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE), mode = "left") %>% 
    select(-Allele, -Gene, -Feature_type, -(BIOTYPE:HGNC_ID), -(CADD_RAW:ExAC_AF_OTH), -(ExAC_AF_AMR:ExAC_AF_SAS)) %>%
    mutate(PHENO = if_else(FAM == "AZ","Azoo",
                           if_else(FAM == "FF", "Fert_fail", "MMAF"))) %>% 
    group_by(RUN) %>% 
    mutate(N_VAR_PER_RUN = n_distinct(CHR,POSITION,REF,ALT)) 
  
  saveRDS(df_annotate, annotate_file)
  
} else {
  
  df_annotate <- readRDS(annotate_file)
  
}

```

```{r cleancall2, include=FALSE, warning=FALSE}

rm(df_call_fam)
gc()

```

```{r varannotation, dependson="retrieveannotation", cache=TRUE}

nb_feature_file <- "results/annotation_nb_feature.rds"
nb_impact_geno_file <- "results/annotation_impact_geno.rds"

if (!file.exists(nb_feature_file)) {

df_nb_feature <- df_annotate %>%
  group_by(RUN) %>%
  summarise(TRANSCRIPT = n_distinct(Feature),
            GENE = n_distinct(SYMBOL)) %>%
  gather(FEATURE, NB, TRANSCRIPT:GENE) 

  saveRDS(df_nb_feature, nb_feature_file)


} else {
  
    df_nb_feature <- readRDS(nb_feature_file)

}

if (!file.exists(nb_impact_geno_file)) {


df_impact <- df_annotate %>% 
  group_by(RUN,CALL, IMPACT) %>%
  summarise(N = n()) %>%
  group_by(RUN) %>%
  mutate(P = N / sum(N))

  saveRDS(df_impact, nb_impact_geno_file)
  
} else {
  
      df_impact <- readRDS(nb_impact_geno_file)
}


df_freq <- df_annotate %>%
  group_by(RUN, ExAC_AF, `1KG`, ESP) %>% 
  distinct(CHR,POSITION,REF,ALT, N_VAR_PER_RUN) %>% 
  group_by(RUN) %>%
  rename(ExAC = ExAC_AF) %>%
  gather(DB,FREQ,ExAC:ESP) %>% 
  filter(!is.na(FREQ)) 

df_freq2 <- df_freq %>%
  ungroup() %>% 
  distinct(CHR,POSITION,REF,ALT,DB,FREQ) %>% 
  select(-(CHR:ALT)) 

df_freq_stat <- df_freq %>%
    select(-(CHR:ALT)) %>% 
  group_by(RUN, DB) %>% 
  summarise(N_PER_RUN_PER_DB = n(),
            P_PER_RUN_PER_DB = n() / mean(N_VAR_PER_RUN))

```

```{r}

mean_transcript <- df_nb_feature %>% ungroup() %>% filter(FEATURE == "TRANSCRIPT") %>% summarise(MEAN = mean(NB)) %>% collect() %>% .[["MEAN"]] %>% round(0)


mean_gene <- df_nb_feature  %>% filter(FEATURE == "GENE") %>% collect() %>% .[["NB"]] %>% mean %>% round(0) %>% as.integer
mean_transcript <- df_nb_feature  %>% filter(FEATURE == "TRANSCRIPT") %>% collect() %>% .[["NB"]] %>% mean %>% round(0) %>% as.integer



rate_tr_gene = (mean_transcript / mean_gene) %>% round(0)

mean_percent_high <- df_impact %>% filter(IMPACT == "HIGH") %>% group_by(RUN) %>% summarise(SP = sum(P)) %>% collect() %>% .[["SP"]] %>% mean %>% round(4) * 100
mean_nb_het_high <- df_impact %>% filter(IMPACT == "HIGH" & CALL == "Heterozygous") %>% group_by(RUN) %>% summarise(SN = sum(N)) %>% collect() %>% .[["SN"]] %>% mean %>% round(0) 
mean_nb_homo_high <- df_impact %>% filter(IMPACT == "HIGH" & CALL == "Homozygous") %>% group_by(RUN) %>% summarise(SN = sum(N)) %>% collect() %>% .[["SN"]] %>% mean %>% round(0) 


min_percent_exac <- df_freq_stat %>% filter(DB == "ExAC") %>% collect() %>% .[["P_PER_RUN_PER_DB"]] %>% min %>% median %>% round(3) * 100
max_percent_exac <- df_freq_stat %>% filter(DB == "ExAC") %>% collect() %>% .[["P_PER_RUN_PER_DB"]] %>% max %>% median %>% round(3) * 100

min_percent_esp <- df_freq_stat %>% filter(DB == "ESP") %>% collect() %>% .[["P_PER_RUN_PER_DB"]] %>% min %>% median %>% round(3) * 100
max_percent_esp <- df_freq_stat %>% filter(DB == "ESP") %>% collect() %>% .[["P_PER_RUN_PER_DB"]] %>% max %>% median %>% round(3) * 100

median_percent_1kg <- df_freq_stat %>% filter(DB == "1KG") %>% collect() %>% .[["P_PER_RUN_PER_DB"]] %>% median %>% round(3) * 100

```

L'annotation des variants appelés consiste à ajouter un maximum d'informations sur les variants. Ces informations seront ensuite utilisées afin de filtrer et / ou prioriser les variants. Dans ces analyses nous avons utilisé le logiciel *Variant Effect Predictor* (VEP) [@McLaren2016] qui va à la fois prédire l'effet qu'auront ces variants sur l'ensemble des transcrits (et gènes) qu'ils chevauchent, ajouter, lorsqu'elle est disponible, la fréquence de chacun de ces variants dans les bases de données ExAC, 1000Genomes (1KG) et ESP6500. Pour finir VEP nous permettra de connaitre les prédictions de pathogénicités fournies par SIFT et PolyPhen pour les variants faux-sens.

Après avoir annoté nos variants par VEP, nous avons pu constater que pour chaque patient `r mean_gene` gènes sont en moyenne affecté par au moins un variant pour en moyenne `r mean_transcript` transcrits (soit environ `r rate_tr_gene` transcrits par gènes). Il faut noter que parmi ces gènes se trouvent à la fois des gènes codant pour des protéine **et** d'autres non codant (**Figure : **\@ref(fig:plotvarannotation) - **A**).  

Chaque variant affectera l'ensemble des transcrits qu'il chevauche, ainsi un même variant pourra impacter plusieurs transcrits. Ces impacts sont ensuite classés par VEP en quatre catégories qui sont, de la plus délétère à la moins délétère : HIGH, MODERATE, LOW, MODIFIER (**Table :**\@ref(tab:tabvepcsq)). Comme attendu, les variants ayant un impact tronquant se retrouvent être les moins fréquent chez chacun de nos patients. Ceci est d'autant plus flagrant pour l'impact HIGH qui regroupe, entre autres, les variants créant un codon stop ou encore ceux causant un décalage du cadre de lecture (**Table :**\@ref(tab:tabvepcsq)), se retrouvent en quantité extrêmement faible puisqu'ils ne représentent en moyenne que `r mean_percent_high` % des variants, soit une moyenne de `r mean_nb_het_high` hétérozygotes et `r mean_nb_homo_high` homozygotes par patient) (**Figure : **\@ref(fig:plotvarannotation) - **B**).  

Parmi ces variants, certains étaient déjà recensés dans une des trois base donnée (ExAC, ESP et 1KG). Ainsi, on peut observer qu'entre `r min_percent_exac` et `r max_percent_exac` % de nos variant étaient listés dans ExAC et entre `r min_percent_esp` et `r max_percent_esp` % dans ESP. En revanche environ `r median_percent_1kg` % d'entre eux sont recensés dans 1KG (**Figure : **\@ref(fig:plotvarannotation) - **C**) (À discuter !!!!!).  

(À discuter !!!!!) (**Figure : **\@ref(fig:plotvarannotation) - **D**)

LES FIGURES SUR LA FRÉQUENCE SONT À DISCUTER CAR LEUR INTERPRÉTATION ME LAISSE PERPLEX (SURTOUT LA PROPORTION DE NOS VARIANTS PRÉSENTS DANS 1KG)

\newpage

```{r plotvarannotation, fig.cap=fig_info,fig.scap=fig_name,fig.width=6.5, fig.height=7, cache=TRUE}

fig_name <- "Annotation des variants par VEP"
fig_description_A <- "**A** : Quantification du nombre de gènes (en bleu) / transcrits (en rose) impactés par au moins un variant pour chaque patient chacun représentés par une barre"
fig_description_B <- "**B** : Distribution des impacts HIGH MODERATE LOW et MODIFIER en fonction des patients et du génotype du variant"
fig_description_C <- "**C** : Pourcentage des variants retrouvés au sein des trois bases de données : ExAC, ESP et 1KG"
fig_description_D <- "**D** : Distribution des fréquences de nos variants au sein des trois bases de données : ExAC, ESP et 1KG"

fig_description <- paste(fig_description_A,fig_description_B, fig_description_C, fig_description_D, sep = ". ")
fig_info <- paste0(fig_name, " : ", fig_description)


pA <- ggplot(df_nb_feature, aes(RUN, NB)) + 
  geom_bar(stat = "identity", position = position_nudge(),  aes(fill = FEATURE)) + 
  # scale_fill_discrete(name = "Feature", labels = c("Gene", "Transcript")) + 
  xlab("Patient") + 
  ylab("Nb of feature impacted") +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank()) + 
  scale_fill_brewer(palette = "Set1", name = "Feature", labels = c("Gene", "Transcript")) 


pB <- ggplot(df_impact, aes("", P)) +
  geom_boxplot(aes(fill = CALL), alpha = .3, outlier.size = -1) + 
  geom_jitter(aes(col = CALL), size = 1, position = position_jitterdodge(0.2)) +
  facet_wrap(~factor(IMPACT, levels = c("HIGH", "MODERATE", "LOW", "MODIFIER")), scales = "free", nrow = 1) +
  scale_y_continuous(labels = percent_format()) + 
  scale_color_brewer(palette = "Set1", name = "Call") +
  scale_fill_brewer(palette = "Set1", name = "Call") + 
  theme(axis.title = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

pC <- ggplot(df_freq_stat, aes("", P_PER_RUN_PER_DB)) + 
  geom_boxplot(outlier.size = -1, aes(fill = DB)) + 
  geom_jitter(size = 1, position = position_jitter(0.2)) +
  facet_wrap(~DB, scales = "free") + 
  ylab("% of variant found within a DB") + 
  xlab("") +
  scale_x_discrete(labels = c("1KG","ESP6500","ExAC")) +
  scale_y_continuous(labels = percent) +
   scale_fill_brewer(palette = "Set1", guide = "none") +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
        
pD <- ggplot(df_freq2, aes(FREQ)) + 
  geom_line(aes(col = DB), stat = "bin", bins = 150) +
   scale_color_brewer(palette = "Set1", name = "Data base", labels = c("1KG","ESP6500","ExAC")) + 
  xlab("Variant frequency") +
  ylab("Nb of variants") + 
  scale_x_continuous(labels = percent)

row1 <- plot_grid(pA, pB, labels = c("A","B"), ncol = 1)
row2 <- plot_grid(pC, pD, labels = c("C","D"), ncol = 2)

plot_grid(row1,row2, ncol = 1, labels = c("","",""), rel_heights = c(1,.5))

```

```{r cleanfreq, include=FALSE, warning=FALSE}

rm(df_freq, df_freq2, df_freq_stat)
gc()


```

\newpage

##### Résultats du filtrage {#filterdescription}

```{r ctrldata, include=FALSE, cache=TRUE}

ctrl_file <- "results/all_ctrl.rds"
sample_ctrl_file <- "results/sample_ctrl.rds" 

if(!file.exists(ctrl_file)) {

  df_ctrl_az <- open_ctrl("data/genotype_not_azoo.csv", pheno = "Azoo")
  df_ctrl_ff <- open_ctrl("data/genotype_not_fert_fail.csv", pheno = "Fert_fail")
  df_ctrl_mmaf <- open_ctrl("data/genotype_not_MMAF.csv", pheno = "MMAF")
  
  nb_ctrl_az <-df_ctrl_az %>% collect() %>% .[["N_CTRL"]] %>% mean 
  nb_ctrl_ff <-df_ctrl_ff %>% collect() %>% .[["N_CTRL"]] %>% mean 
  nb_ctrl_mmaf <-df_ctrl_mmaf %>% collect() %>% .[["N_CTRL"]] %>% mean 
  
  fam_lab <- c("Az", "FF", "MMAF1", "MMAF2", "MMAF3", "MMAF4")
  
  nb_ctrl <- c(nb_ctrl_az,
               nb_ctrl_ff,
               nb_ctrl_mmaf,
               nb_ctrl_mmaf,
               nb_ctrl_mmaf,
               nb_ctrl_mmaf)
  
  df_sample_ctrl <- data_frame(FAM = fam_lab,
                               NB = nb_ctrl)
  
  df_ctrl_all <- rbind(df_ctrl_az,
                       df_ctrl_ff,
                       df_ctrl_mmaf)
  
  saveRDS(df_ctrl_all,ctrl_file)
  saveRDS(df_sample_ctrl,sample_ctrl_file)
  
  rm(df_ctrl_az, df_ctrl_ff, df_ctrl_mmaf)
  gc()
  
} else {
  
  df_ctrl_all <- readRDS(ctrl_file)
  df_sample_ctrl <- readRDS(sample_ctrl_file)
}

```

```{r filterallfam, cache=TRUE}

maf_cutoff <- .01

df_filter_fam <- df_annotate %>% 
  ungroup() %>%
  filter_genotype(het = FALSE) %>%
  filter_frequence(cutoff = maf_cutoff) %>%
  variant_join(df_ctrl_all, add_by = "PHENO", mode = "anti") %>% 
  filter(Consequence != "synonymous_variant",
         IMPACT != "MODIFIER",
         !(grepl("tolerated", SIFT) & grepl("benign", PolyPhen)),
         !grepl("NMD_transcript_variant",Consequence),
         !grepl("non_coding_transcript_variant", Consequence)) %>%
  group_by(FAM) %>%
  mutate(NB_FAM = n_distinct(RUN)) %>% 
  group_by(CHR, POSITION, REF, ALT, FAM, Feature) %>% 
  filter(n() == mean(NB_FAM))

```

```{r filternonpertinanttr, include=FALSE, warning=FALSE, cache=TRUE}

df_tmp <- df_annotate %>%
  ungroup() %>%
  select(CHR, POSITION, REF, ALT, RUN, Feature, Consequence) %>%
  mutate(IS_FILTERED = grepl("NMD_transcript_variant", Consequence) | grepl("non_coding_transcript_variant", Consequence)) %>%
  select(-Consequence) %>%
  group_by(RUN, IS_FILTERED) %>%
  mutate(N_TRANSCRIT_PER_ISNMD = n_distinct(Feature))

df_filtered_tr <- df_tmp %>%
  summarise(N = n_distinct(Feature),
            TYPE = "Transcript")  

df_filtered_tr_vr <- df_tmp %>%
  group_by(CHR, POSITION, REF, ALT, RUN) %>% 
  mutate(IS_FILTERED = if_else(n_distinct(IS_FILTERED) == 1 & IS_FILTERED == TRUE, TRUE, FALSE)) %>%
  group_by(RUN, IS_FILTERED) %>%
  summarise(N = n_distinct(CHR,POSITION,REF,ALT),
            TYPE = "Variants") %>% 
  bind_rows(df_filtered_tr)


rm(df_tmp)
gc()

max_tr <- ungroup(df_filtered_tr_vr) %>% filter(TYPE == "Transcript" & IS_FILTERED == TRUE) %>% collect() %>% .[["N"]] %>% max
min_tr <- ungroup(df_filtered_tr_vr) %>% filter(TYPE == "Transcript" & IS_FILTERED == TRUE) %>% collect() %>% .[["N"]] %>% min
mean_variant <- ungroup(df_filtered_tr_vr) %>% filter(TYPE == "Variants" & IS_FILTERED == TRUE) %>% collect() %>% .[["N"]] %>% mean %>% round(0)

```


Les étapes précédentes nous ont permis de mettre en évidence pour chaque patient une liste de variants passant l'ensemble de nos critères qualités. Ces variants ont dès lors pu être annotés nous permettant notamment d'avoir connaissance de leurs impacts sur les différents transcrits qu'ils chevauchent ou encore leur fréquence dans la population générale. Désormais, afin de ne conserver que les variants ayant la plus forte probabilité d'être responsable du phénotype de ces patients, nous avons appliqué successivement six filtres basés à la fois sur les différentes annotations que nous avons ajoutées mais aussi sur nos connaissances du mode de transmission du phénotype :  

1. **Filtre 1 : L'union des variants :** Dans ces différentes études, nous avons à chaque fois séquencé des frères (deux ou trois) présentant phénotype. Ainsi nous avons pu formuler l'hypothèse d'une cause génétique commune entre les différents patients d'une même famille et donc filtrer l'ensemble des variants qui ne sont pas partagés les deux ou trois frères atteints testés.     
2. **Filtre 2 : Génotype des variants :**  Dans ces études, nous avons émis l'hypothèse d'une transmission récessive du phénotype. Ainsi, seuls les variants homozygotes ont été conservés. (**Figure : **\@ref(fig:resvarcall), \@ref(fig:comparefilter)).    
3. **Filtre 3 : Impact du variant :** Afin de ne conserver que les variants ayant un effet potentiellement délétère sur la protéine, nous avons filtré les variants intronique et ceux tombant dans les séquences UTRs. De même les variants synonymes ne sont pas conservés (exceptés ceux se trouvant proches des régions d'épissage) car ceux-ci n'ont aucun effet sur la séquence protéique. Pour les variants faux sens (changement d'un seul aa de la séquence protéique) il est plus difficile de se trancher, nous avons donc utilisé les logiciels SIFT [@Kumar2009] et Polyphen [@Adzhubei2010] et filtré l'ensemble des faux-sens prédits comme *tolerated* par SIFT et *benign* par Polyphen.  
4. **Filtre 4 : Les transcrits "non pertinents" :** Au cours de nos analyses nous nous sommes concentré uniquement sur les transcrits codant pour une protéine. Ainsi, l'ensemble des transcrits annotés comme étant non codant furent filtrés. De même le mécanisme NMD (*nonsense-mediated decay*) a pour but de contrôler la qualité des ARNm cellulaires chez les eucaryotes [@Chang2007] en éliminant les ARNm qui comportent un codon stop prématuré [@Baker2004], pouvant être le résultat d'une erreur de transcription, d'une mutation ou encore d'une erreur d'épissage. Il est donc peu probable que les variants présents sur des transcrits annotés NMD soient responsables du phénotype. Dès lors, ces transcrits ont été également filtrés. Ainsi, nous avons pu retirer de nos listes de variants l'ensemble des mutations impactant **uniquement** des transcrits non codant et / ou annoté NMD. Cette étape de filtre permet à elle seule de filtrer systématiquement entre `r min_tr` et `r max_tr` transcrits différents par patients, soit une moyenne de `r mean_variant` variants par individus (**Figure : **\@ref(fig:plotfilternonpertinanttr)).    

```{r plotfilternonpertinanttr, fig.cap=fig_info,fig.scap=fig.name,fig.width=6.3, fig.height=3.5, cache=TRUE}

fig.name <- "Filtrage des transcrits jugés \"non pertinents\" et des variants les chevauchant"
fig_description <- "Pour chaque patients nous avons filtrer les transcrits jugés \"non pertinents\" pour l'analyse, c'est à dire ceux ne codant pas pour une protéine et ceux annoté NMD. Dès lors, l'intégralité des variants chevauchant uniquement des transcrits non pertinents ont put systématiquement être filtrés (boites rouges). les autres furent conservés (boites vertes)"
fig_info <- paste0(fig.name, " : ", fig_description)

ggplot(df_filtered_tr_vr, aes(IS_FILTERED, N)) + 
  geom_boxplot(aes(fill = IS_FILTERED), outlier.size = -1) + 
  geom_jitter(size = 2, position=position_jitter(0.3)) +
  scale_fill_manual(name = "Retained?", values = c("chartreuse3", "#E41A1C"), labels = c("Yes","No")) +
  facet_wrap(~TYPE, scales = "free") +
  ylab("Nb of transcripts / variants") + 
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

```
5. **Fréquence des variants :**  La fréquence d'un variant dans la population générale est un moyen rapide d'avoir une prédiction fiable de l'effet délétère ou non de celui-ci. En effet, il est peu probable qu'un variant retrouvé fréquemment dans la population générale soit causal d'une pathologie sévère. Ainsi nous avons filtré pour l'ensemble de nos patients l'ensemble des variants ayant une fréquence $\ge$ `r maf_cutoff` dans l'une des trois bases de données que sont ExAC, ESP et 1KG.    
6. **Présence des variants dans la cohorte contrôle :**  Au cours de nos différentes études, nous avons été amenés à séquencé un total de `r n_tot_runs` un des `r n_pheno_tot` phénotypes étudiés au cours de nos différentes études (**Table : **\@ref(tab:TODO)). Ces phénotypes étant très différent, on peut émettre l'hypothèse que leurs causes génétiques soient également différentes. De même, les variants recherchés étant rares, il est peu probable qu'un individu porte les variants de deux phénotypes différents. Ainsi, pour chacune des `r n_fam` familles, nous avons pu constituer une cohorte contrôle composée dans l'ensemble des patients précédemment analysés et ne présentant pas le même phénotype que celui étudié dans la famille (**Figure :** \@ref(fig:plotsamplectrl)). Dès lors, nous avons pu filtrer l'ensemble des variants retrouvés à la fois chez nos patients et observés à l'état homozygote dans la cohorte contrôle. Cette cohorte contrôle présente ainsi le même rôle que les bases de données publiques. Sont intéret principale par rapport à celles-ci est que les individus qui la composent ont pour la plupart la même origine ethnico-géographique que nos patients. De plus ceux-ci ont été séquencés en même temps dans les mêmes centres permettant ainsi d'identifier les artefacts dûs aux protocols de séquençage.                                                                              

```{r plotsamplectrl, fig.cap=fig_info,fig.scap=fig.name, fig.height=4, cache=TRUE}
     
fig.name <- "Nombre d'individus composant la cohorte contrôle de chaque famille"
fig_description <- "Ici, chaque barre représente une famille et sa hauteur est déterminée par le nombre d'individus composant la cohorte contrôle à laquelle elle a été confronté. Chaque individu de la cohorte contrôle a été séquencés en WES par notre équipe. Afin d'être considéré comme \"contrôle\" et intégrer cette cohorte, un individu doit être sain ou présenter un phénotype d'infertilité différent de la famille étudiée. Par exemple, un individus MMAF pourra servir de contrôle aux familles AZ et FF mais pas aux familles MMAF1-4"
fig_info <- paste0(fig.name, " : ", fig_description)
                         
ggplot(df_sample_ctrl, aes(FAM, NB, fill = FAM)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = NB), position = position_dodge(width = .9), vjust = -.25) +
  ylab("Number of control individuals") +
   scale_fill_brewer(palette = "Set1", guide = "none") +
  xlab("Family")


```

\newpage

```{r comparefilters, include=FALSE, cache=TRUE}

filter_file <- "results/filter.rds"
filter_spe_file <- "results/filter_spe.rds"

if (!file.exists(filter_file) | 
    !file.exists(filter_spe_file)) {

df_filtered_by_geno <- df_annotate %>% 
  filter_genotype(homo = FALSE) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN) %>%
  mutate(FILTER = "Genotype", 
         N_FILTERED = n_distinct(CHR,POSITION,REF,ALT),
         P_FILTERED = N_FILTERED / N_VAR_PER_RUN)

df_filtered_by_freq <- df_annotate %>%
  filter(!is.na(ExAC_AF) & ExAC_AF >= maf_cutoff,
         !is.na(ESP) & ESP >= maf_cutoff,
         !is.na(`1KG`) & `1KG` >= maf_cutoff) %>%
  mutate(FILTER = "Frequence", 
         N_FILTERED = n_distinct(CHR,POSITION,REF,ALT),
         P_FILTERED = N_FILTERED / N_VAR_PER_RUN)
  
df_fitered_by_impact <- df_annotate %>% 
  group_by(RUN) %>% 
  mutate(IS_FILTERED = if_else(Consequence != "synonymous_variant" &
                               IMPACT != "MODIFIER" &
                               (!(grepl("tolerated", SIFT) & grepl("benign", PolyPhen))), FALSE, TRUE)) %>%
  distinct(CHR, POSITION, REF, ALT, IS_FILTERED, N_VAR_PER_RUN) %>%
  group_by(CHR, POSITION, REF, ALT, RUN) %>% 
  mutate(N = n()) %>%
  filter(N == 1,
         IS_FILTERED == TRUE) %>%
  group_by(RUN) %>% 
  mutate(FILTER = "Variant impact", 
         N_FILTERED = n(),
         P_FILTERED = N_FILTERED / N_VAR_PER_RUN)

df_filtered_by_union <- df_annotate %>% 
  distinct(CHR, POSITION, REF, ALT, FAM, N_VAR_PER_RUN) %>% 
  group_by(FAM) %>%
  mutate(NB_FAM = n_distinct(RUN)) %>%
  group_by(CHR, POSITION, REF, ALT, FAM) %>% 
  filter(n() < NB_FAM) %>% 
  group_by(RUN) %>%
  mutate(FILTER = "Union", 
         N_FILTERED = n_distinct(CHR,POSITION,REF,ALT),
         P_FILTERED = N_FILTERED / N_VAR_PER_RUN)

df_fitered_by_transcript <- df_annotate %>%
  mutate(IS_FILTERED = if_else(grepl("NMD_transcript_variant", Consequence) | grepl("non_coding_transcript_variant", Consequence), TRUE, FALSE)) %>% 
    distinct(CHR, POSITION, REF, ALT, IS_FILTERED, N_VAR_PER_RUN) %>%
  group_by(CHR, POSITION, REF, ALT, RUN) %>% 
  mutate(N = n()) %>%
  filter(N == 1,
         IS_FILTERED == TRUE) %>%
  group_by(RUN) %>% 
  mutate(FILTER = "Transcript relevance", 
         N_FILTERED = n(),
         P_FILTERED = N_FILTERED / N_VAR_PER_RUN)
  
df_filter_ctrl <- df_annotate %>% 
  variant_join(df_ctrl_all, add_by = "PHENO", mode = "inner") %>%
  mutate(FILTER = "Ctrl", 
            N_FILTERED = n_distinct(CHR,POSITION,REF,ALT),
            P_FILTERED = N_FILTERED / N_VAR_PER_RUN)


resume_filter <- function(df) {
  
  df %>% group_by(RUN, FILTER) %>% select(RUN, FILTER, N_FILTERED, P_FILTERED) %>% summarise(N = mean(N_FILTERED), P = mean(P_FILTERED))
  
}

filter_stat <- rbind(resume_filter(df_filtered_by_geno),
                     resume_filter(df_filtered_by_freq),
                     resume_filter(df_fitered_by_impact),
                     resume_filter(df_filtered_by_union),
                     resume_filter(df_filter_ctrl),
                     resume_filter(df_fitered_by_transcript))

saveRDS(filter_stat, filter_file)

} else {
  filter_stat <- readRDS(filter_file)
}


```

```{r filterspe, cache=TRUE}


if (!file.exists(filter_spe_file)) {

spe_geno <- df_filtered_by_geno %>% 
  group_by(RUN) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN, FILTER, N_FILTERED, P_FILTERED) %>% 
  variant_join(df_filtered_by_freq, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_fitered_by_impact, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_filtered_by_union, add_by = "RUN", mode = "anti") %>%
  variant_join(df_filter_ctrl, add_by = "RUN", mode = "anti") %>%
  variant_join(df_fitered_by_transcript, add_by = "RUN", mode = "anti") 

spe_freq <- df_filtered_by_freq %>% 
  group_by(RUN) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN, FILTER, N_FILTERED, P_FILTERED) %>% 
  variant_join(df_filtered_by_geno, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_fitered_by_impact, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_filtered_by_union, add_by = "RUN", mode = "anti") %>%
  variant_join(df_filter_ctrl, add_by = "RUN", mode = "anti") %>%
  variant_join(df_fitered_by_transcript, add_by = "RUN", mode = "anti") 

spe_impact <- df_fitered_by_impact %>% 
  group_by(RUN) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN, FILTER, N_FILTERED, P_FILTERED) %>% 
  variant_join(df_filtered_by_freq, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_filtered_by_geno, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_filtered_by_union, add_by = "RUN", mode = "anti") %>%
  variant_join(df_filter_ctrl, add_by = "RUN", mode = "anti") %>%
  variant_join(df_fitered_by_transcript, add_by = "RUN", mode = "anti") 

spe_union <- df_filtered_by_union %>% 
  group_by(RUN) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN, FILTER, N_FILTERED, P_FILTERED) %>% 
  variant_join(df_filtered_by_freq, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_fitered_by_impact, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_filtered_by_geno, add_by = "RUN", mode = "anti") %>%
  variant_join(df_filter_ctrl, add_by = "RUN", mode = "anti") %>%
  variant_join(df_fitered_by_transcript, add_by = "RUN", mode = "anti") 

spe_ctrl <- df_filter_ctrl %>% 
  group_by(RUN) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN, FILTER, N_FILTERED, P_FILTERED) %>% 
  variant_join(df_filtered_by_freq, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_fitered_by_impact, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_filtered_by_union, add_by = "RUN", mode = "anti") %>%
  variant_join(df_filtered_by_geno, add_by = "RUN", mode = "anti") %>%
  variant_join(df_fitered_by_transcript, add_by = "RUN", mode = "anti") 

spe_tr <- df_fitered_by_transcript %>% 
  group_by(RUN) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN, FILTER, N_FILTERED, P_FILTERED) %>% 
  variant_join(df_filtered_by_freq, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_fitered_by_impact, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_filtered_by_union, add_by = "RUN", mode = "anti") %>%
  variant_join(df_filter_ctrl, add_by = "RUN", mode = "anti") %>%
  variant_join(df_filtered_by_geno, add_by = "RUN", mode = "anti") 

spe_all <- rbind(spe_geno,
                 spe_freq,
                 spe_impact,
                 spe_union,
                 spe_ctrl,
                 spe_tr) %>% 
  group_by(RUN, FILTER) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN, N_FILTERED, P_FILTERED) %>% 
  summarise(N_FILTERED_SPE = n_distinct(CHR, POSITION, REF, ALT),
            P_FILTERED_SPE = N_FILTERED_SPE / mean(N_VAR_PER_RUN))

saveRDS(spe_all, spe_filter_file)

} else {
  spe_all <- readRDS(filter_spe_file)
}


```

\newpage

```{r}

mean_filter_tr <- filter_stat %>% filter(FILTER == "Transcript relevance") %>% collect() %>% .[["P"]] %>% mean %>% round(3) * 100
max_filter_impact <- filter_stat %>% filter(FILTER == "Variant impact") %>% collect() %>% .[["P"]] %>% max %>% round(3) * 100
min_filter_ctrl <- filter_stat %>% filter(FILTER == "Ctrl") %>% collect() %>% .[["P"]] %>% min %>% round(3) * 100
max_filter_ctrl <- filter_stat %>% filter(FILTER == "Ctrl") %>% collect() %>% .[["P"]] %>% max %>% round(3) * 100

mean_filter_spe_impact <- spe_all %>% filter(FILTER == "Variant impact") %>% collect() %>% .[["N_FILTERED_SPE"]] %>% mean %>% round(0) 
mean_filter_spe_geno <- spe_all %>% filter(FILTER == "Genotype") %>% collect() %>% .[["N_FILTERED_SPE"]] %>% mean %>% round(0) 
mean_filter_spe_ctrl <- spe_all %>% filter(FILTER == "Ctrl") %>% collect() %>% .[["N_FILTERED_SPE"]] %>% mean %>% round(0) 
max_filter_spe_ctrl <- spe_all %>% filter(FILTER == "Ctrl") %>% collect() %>% .[["N_FILTERED_SPE"]] %>% max
min_filter_spe_ctrl <- spe_all %>% filter(FILTER == "Ctrl") %>% collect() %>% .[["N_FILTERED_SPE"]] %>% min

max_filter_spe_other <- spe_all %>% filter(FILTER == "Transcript relevance" | FILTER == "Union" | FILTER ==  "Frequence") %>% collect() %>% .[["N_FILTERED_SPE"]] %>% max


```

Comme on pouvait s'y attendre, ces six filtres ont un pouvoir discriminant extrêmement différent (**Figure :** \@ref(fig:plotcomparefilter)). En effet, tandis que le filtre "Transcript relevance" (filtre n°4) éliminer en moyenne `r mean_filter_tr` % des variants de chaque individu tandis que le filtre "Variant impact" (filtre n° 3) élimine jusqu'à `r max_filter_impact` % de ces mêmes variants (**Figure :** \@ref(fig:plotcomparefilter) - **A**). Cette différence n'est pas surprenante. En effet, comme nous l'avions vu plus tôt, les variants de la catégorie VEP MODIFIER  qui regroupe entre autres les variants chevauchant les séquences UTRs et introniques (**Table :** \@ref(fig:tabvepcsq)) représentent en moyenne ... % des variants de nos patients (**Figure :** \@ref(fig:plotvarannotation) - **A**). Ceux-ci étant tous filtrés, on s'attendait donc à une valeur aussi élevée. On peut également constater l'importance de la cohorte contrôle qui, je le rappelle, permet de filtrer l'ensemble des variants homozygotes observés en son sein, puisque ce filtre permet retirer entre `r min_filter_ctrl` et `r max_filter_ctrl`% des variants de chaque individus (**Figure :** \@ref(fig:plotvarannotation) - **A**).      

Cependant, regarder uniquement le pourcentage de variants filtrés par chaque filtre révèle une information partielle. En effet, dans ce cas de figure, on observe la quantité de variant éliminé par chaque filtre indépendamment les uns des autres. Ainsi, un même variant peut donc être filtré par plusieurs filtres. Dès lors, il faut également analyser la quantité de variants filtrés **spécifiquement** par chaque filtre. Ainsi, on peut constater que le classement des filtres en fonctions de leur stringance reste quasiment identique (**Figure :** \@ref(fig:plotcomparefilter) - **B**) il est tout de même intéressant de noter que désormais le filtre "Variant impact" apparait moins efficace que les filtres "Ctrl" et "Genotype" en filtrant spécifiquement une moyenne de `r mean_filter_spe_impact` variants par individu contre `r mean_filter_spe_geno` pour le filtre génotype et `r mean_filter_spe_ctrl` pour le filtre "Ctrl". Ainsi, ce dernier devient celui filtrant spécifiquement le plus de variants avec entre `r min_filter_spe_ctrl` et `r max_filter_spe_ctrl` variants spécifiquement filtrés par patients confirmant ainsi l'importance de ce filtre dans nos analyses. Aussi, les filtres "Transcript relevance", "Union" et "Frequency" apparaissent désormais comme étant anecdotiques en comparaison aux trois autres filtres puisqu'ils filtrent au maximum `r max_filter_spe_other` variants spécifiques (**Figure :** \@ref(fig:plotcomparefilter) - **B**).  

\newpage

```{r plotcomparefilter, fig.cap=fig_info,fig.scap=fig_name, fig.height=7, cache=TRUE}

fig_name <- "Comparaison de l'efficacité de chacun des six filtres utilisés"
fig_description_A <- "**A** : Comparaison du pourcentage de variants filtrés par chacun des six filtres indépendamment les uns des autres pour chaque patient (représenté par les points. Dès lors, un même variant peut être filtré par plusieurs filtres"
fig_description_B <- "**B** : Comparaison du nombre de variant filtrés spécifiquement par chacun des filtres. Ici, un variant ne peut-être filtré que par un seul filtre"
fig_description <- paste(fig_description_A, fig_description_B, sep = ". ")
fig_info <- paste0(fig_name, " : ", fig_description)

pA <- ggplot(filter_stat, aes(FILTER, P)) + 
  geom_boxplot(fill = "#E41A1C", outlier.size = -1) + 
  scale_x_discrete(limits = c("Transcript relevance","Union","Frequence","Genotype","Ctrl","Variant impact")) + 
  geom_jitter(position=position_jitter(0.3)) +
  ylab("% of filtered variants") + 
  xlab("") +
  scale_y_continuous(labels = percent) 

pB <- ggplot(spe_all, aes(FILTER, N_FILTERED_SPE)) + 
  geom_boxplot(fill = "#E41A1C", outlier.size = -1) + 
  geom_jitter(position=position_jitter(0.3)) +
  ylab("Nb of filtered variants") + 
  xlab("") +
  scale_x_discrete(limits = c("Transcript relevance","Union","Frequence","Genotype","Ctrl","Variant impact")) 
  # facet_wrap(~factor(FILTER, levels = c("Transcript relevance","Union","Frequence","Genotype","Ctrl","Variant impact")), scales = "free")

plot_grid(pA,pB, labels = c("A","B"), ncol = 1)

```

\newpage

```{r remaininggense}

df_remaining_gene <- df_filter_fam %>% 
  
  group_by(FAM) %>%
  mutate(SIFT = gsub("_", " ", str_extract(SIFT, "\\w+")),
         SIFT = if_else(grepl("low confidence", SIFT), 
                        str_split(SIFT, "low confidence")[[1]],
                        SIFT),
         PolyPhen = gsub("_", " ", str_extract(PolyPhen, "\\w+")),
         PolyPhen = if_else(grepl("damaging", PolyPhen), 
                            "damaging",
                            PolyPhen),
         Consequence = gsub("_", " ", sapply(strsplit(Consequence, "_variant", fixed = TRUE),"[[",1))) %>%
  
  distinct(SYMBOL, Consequence, SIFT, PolyPhen) %>%
  
mutate(CAUSAL = if_else(FAM == "AZ", "SPINK2", 
                          if_else(FAM == "FF","PLCZ1",
                                  if_else(FAM == "MMAF2","DNAH1", 
                                          if_else(FAM == "MMAF4", "TGIF2?", "???")))),
         FIND_CAUSAL = if_else(CAUSAL == "???","No",
                               if_else(grepl("[?]", perl = TRUE, CAUSAL),"Maybe","Yes"))) %>%
  rename(Family = FAM) 
    
gene_mmaf1 <- df_remaining_gene %>% filter(Family == "MMAF1")
n_gene_az <- df_remaining_gene %>% filter(Family == "AZ") %>% nrow
n_gene_mmaf1 <- df_remaining_gene %>% filter(Family == "MMAF1") %>% nrow
n_gene_mmaf2 <- df_remaining_gene %>% filter(Family == "MMAF2") %>% nrow
n_gene_mmaf3 <- df_remaining_gene %>% filter(Family == "MMAF3") %>% nrow


```

Après avoir appliqué l'ensemble de ces filtres, seuls quelques variants subsistent nous permettant d'obtenir une liste de gènes restreinte pour chaque famille (**Table : **\@ref(tab:tablegene)) et ainsi de tirer des conclusions quant au variant responsable du phénotype. 

1. **Famille AZ** : Parmi les `r n_gene_az` gènes restant pour cette famille, *SPINK2* est apparu comme étant un candidat évident. Notamment son expression étant spécifique au testicule tandis que celle de *GUF1* est ubiquitaire (**Figure : **\@ref(fig:plotexpspink2guf1)). De plus, des mutations du gène *Spink2* chez la souris avait déjà été identifiée comme induisant des défauts de la spermatogenèse [@Lee2011].  

```{r plotexpspink2guf1, fig.cap=fig_info,fig.scap=fig_name, cache=TRUE}

fig_name <- "Expression tissulaire des gènes *SPINK2* et *GUF1*"
fig_description <- "Données provenant du projet de transcriptome Illumina bodyMap"
fig_info <- paste0(fig_name, " : ", fig_description)

plot_expression(c("spink2", "guf1"), flip = TRUE, mode = "percent") + 
  xlab("") +
  theme(legend.position = c(1, 0),
        legend.justification = c(1,0))


```
2. **Famille FF** : Pour cette famille, le gène *PLC*$\zeta 1$ a passé l'ensemble des filtres. Nos connaissances sur la fonction de se gène et notamment son rôle dans l'activation ovocytaire (TODO: REF) ainsi que sa forte expression testiculaire ont fait de ce gène le candidat idéal pour expliquer le phénotype de ces deux frères (**Figure : **\@ref(fig:plotexpplcz1)). 

```{r plotexpplcz1, fig.cap=fig_info,fig.scap=fig_name, cache=TRUE}

fig_name <- "Expression tissulaire du gène *PLCZ1*"
fig_info <- paste0(fig_name, " : D'après les données du Illumina BodyMap")

plot_expression("plcz1", "percent", TRUE) +
  xlab("") + 
  theme(legend.position = c(1,.5),
        legend.justification = c(1,.5))

```

3. **Famille MMAF1** : L'analyse bibliographique des `r n_gene_mmaf1` gènes ayant passé l'ensemble des filtres n'a pas pu nous permettre de d'affirmer que l'un de ces gènes étaient responsable du phénotype MMAF de ces 2 frères.  
4. **Famille MMAF2** : À l'issue des filtres, `r n_gene_mmaf2` gènes ressortaient chez ces deux frères : *MYH11* et *DNAH1*. Or, notre équipe ayant déjà établit le lien entre des mutations du gène *DNAH1* et le syndrome MMAF [@BenKhelifa2014] ce gène s'est révélé être un candidat idéal pour expliquer le phénotype de ces 2 frères. De plus, l'implication de *MYH11* dans le phénotype de dissection aortique [@Imai2015] l'ont écarté des candidats pour le phénotype MMAF.    
5. **Famille MMAF3** : Comme pour les gènes de la famille MMAF2, l'analyse bibliographique des `r n_gene_mmaf3` gènes ayant ici passé les filtres de même que l'étude de leurs expressions ne nous a pas permis de conclure que l'un d'entre eux étaient responsable du phénotype MMAF de ces 2 frères. 
```{r expmmaf3}

genes_mmaf3 <- df_remaining_gene %>% filter(Family == "MMAF3") %>% collect() %>% .[["SYMBOL"]]

```

```{r plotexpmmaf3, fig.cap=fig_info,fig.scap=fig_name, cache=TRUE}


fig_name <- "Expression tissulaire des gènes retenus pour la famille MMAF3"
fig_description <- "Données provenant du projet de transcriptome Illumina bodyMap"

fig_info <- paste0(fig_name, " : ", fig_description)

plot_expression(genes_mmaf3,"percent",TRUE) + 
  xlab("") +
  theme(legend.position = c(1, 0),
        legend.justification=c(1,0))

```

6. **Famille MMAF4** : Seul le gène *TGIF2* a passé l'ensemble des filtres pour la famille MMAF4. L'expression ubiquitaire de ce gène n'en font pas un candidat idéal. Cependant une étude de 2011 effectuée sur le wallaby décrit que la protéine TGIF2 est localisée spécifiquement dans le cytoplasme du spermatide, ainsi que dans le corps résiduel et la pièce intermédiaire du flagelle du spermatozoïde mature [@Hu2011]. Ces données pourraient corréler avec le phénotype MMAF de ces 3 frères bien que l'expression de ce gène soit ubiquitaire (**Figure : **\@ref(fig:plotexptgif2)).    

\newpage 

```{r plotexptgif2, fig.cap=fig_info,fig.scap=fig_name, cache=TRUE}

fig_name <- "Expression tissulaire du gène *TGIF2*"
fig_info <- paste0(fig_name, " : D'après les données du Illumina BodyMap")

plot_expression("tgif2", "percent", TRUE) +
  xlab("") + 
  theme(legend.position = c(1,.5),
        legend.justification = c(1,.5))

```

\newpage

#### Discussion  

```{r}

df_causal <- group_by(df_remaining_gene, Family, FIND_CAUSAL, CAUSAL) %>%
  summarise(N = n())

n_fam <- df_causal %>% nrow
nb_found <- df_causal %>% filter(!grepl("[?]", CAUSAL)) %>% nrow
nb_maybe <- df_causal %>% filter(CAUSAL != "???" & grepl("[?]", CAUSAL)) %>% nrow
nb_not_found <- df_causal %>% filter(CAUSAL == "???") %>% nrow
percent_found <- (nb_found / n_fam) %>% round(3) * 100


```

L'analyse de ces `r n_fam` familles nous a permis de mettre en évidence l'efficacité de notre pipeline d'analyse puisque pour `r nb_found`  d'entre elles (soit `r percent_found`%) le variant causal a pu être identifié avec certitude (**Figure : **\@ref(fig:plotremaininggenes)) et les résultats publiés dans trois revus dont je suis co-auteur :  

1. **Famille AZ** : [**SPINK2 deficiency causes infertility by inducing sperm defects in heterozygotes and azoospermia in homozygotes**](#spink2) : Dans cet article j'ai effectué non seulement l'intégralité des analyses bioinformatiques des données d'exomes de deux frères infertiles présentant un phénotype d'azoospermie mais j'ai aussi séquencé en Sanger les séquences codantes du gène *SPINK2* pour une partie des 611 individus analysés ainsi que contribué à l'extraction de l'ARN testiculaire des souris pour l'analyse fonctionnelle du gène *Spink2* sur le modèle murin.  
2. **Famille FF** : [**Homozygous mutation of PLCZ1 leads to defective human oocyte activation and infertility that is not rescued by the WW-binding protein PAWP**](#plcz) : Dans cet article j'ai, effectué l'intégralité des analyses bioinformatiques des données d'exomes effectuées sur deux frères infertiles présentant des échecs de fécondation.    
3. **Famille MMAF2** : [**Whole-exome sequencing of familial cases of multiple morphological abnormalities of the sperm flagella (MMAF) reveals new DNAH1 mutations**](#famdnah1) : Dans cet article j'ai, comme précédemment, effectué l'ensemble des analyses bioinformatiques des données d'exomes effectuées sur deux frères infertiles présentant des échecs de fécondation.  

Pour une d'entre elle, un candidat potentiel a pu être mis en évidence avec le gène *TGIF2* et notre équipe travaille actuellement sur la caractérisation de ce gène afin de savoir s'il peut effectivement expliquer le phénotype MMAF de cette famille (**Figure : **\@ref(fig:plotremaininggenes)).     

TODO : Il faut aller plus loin dans l'analyse et les arguments pour convaincre qu'il s'agit d'un bon candidat : quel type de mutation, ce gène est-il bien conservé, son expression n'est pas spécifique au testicule et ce gène serait impliqué dans un phénotype d'holoproencephaly...

Pour les `r nb_not_found` familles restantes, aucun variant n'a pu pour l'instant expliquer leur phénotype. L'explication la plus vraisemblable est que le variant ait été filtré par l'un de nos six filtres, probablement celui consistant à filtrer l'ensemble des variants hétérozygotes. En effet, l'hypothèse d'un variant causal homozygote était extrêmement crédible pour les familles AZ, FF et MMAF2 étant donné l'historique consanguin de ces `r nb_found` familles dont les parents sont à chaque fois apparentés. En revanche rien ne laisse supposer une telle chose pour les familles restantes. Cependant, le filtre des variants hétérozygotes pour l'ensemble des patients de ces `r nb_not_found + nb_maybe` familles a été maintenu en première intention afin de faciliter les analyses en réduisant au maximum le nombre de variant. Au vus des résultats il apparait clair que les variants responsables de leur phénotype aient été filtrés pour au moins `r nb_not_found` de ces familles. Dès lors, l'ensemble des analyses effectuées lors de l'étape de filtrage doivent être refaites en changeant les paramètres de filtrage. Cette fois-ci, les variants hétérozygotes seront conservés et les gènes sur lesquels au moins deux variants hétérozygotes seront recensés seront analysés en priorité. En effet, bien que les analyses exomiques nous fournissent en l'état pas d'informations suffisante pour savoir si ces deux variants sont présent sur le même allèle ou bien sur deux allèles différents, cela pourrait-être la signature de variants hétérozygotes composites. C'est donc sur ces analyses que se concentre actuellement notre équipe.    


```{r tablegene, cache=TRUE}

df_genes <- df_remaining_gene %>% select(Family, SYMBOL) %>% 
  mutate(ind = row_number()) %>%
  spread(Family, SYMBOL, fill = " ") %>% 
  select(-ind)

az_recap_tab <- df_remaining_gene %>% select(Family, Gene = SYMBOL, Impact = Consequence) %>% filter(Family == "AZ")
ff_recap_tab <- df_remaining_gene %>% select(Family, Gene = SYMBOL, Impact = Consequence) %>% filter(Family == "FF")
mmaf1_recap_tab <- df_remaining_gene %>% select(Family, Gene = SYMBOL, Impact = Consequence) %>% filter(Family == "MMAF1")
mmaf2_recap_tab <- df_remaining_gene %>% select(Family, Gene = SYMBOL, Impact = Consequence) %>% filter(Family == "MMAF2")
mmaf3_recap_tab <- df_remaining_gene %>% select(Family, Gene = SYMBOL, Impact = Consequence) %>% filter(Family == "MMAF3")
mmaf4_recap_tab <- df_remaining_gene %>% select(Family, Gene = SYMBOL, Impact = Consequence) %>% filter(Family == "MMAF4")

kable(df_remaining_gene %>% select(Family, Gene = SYMBOL, Impact = Consequence),
      booktabs = TRUE,
      longtable = TRUE,
      caption = "Récapitulatif des variants ayant passé l'ensemble des filtres pour chaque famille")

# pander::pander(df_genes,
#                justify = 'left',
#                caption = "(\\#tab:tablegene) Liste des gènes ayant passé l'ensemble des filtres pour chaque famille")


```

```{r plotremaininggenes, fig.cap=fig_info,fig.scap=fig_name, cache=TRUE}

fig_name <- "Nombre de gènes passant l'ensemble des filtres par famille"
fig_description <- "Chaque barre représente une des familles analysées. La hauteur de cette barre correspond au nombre de gènes ayant passé l'ensemble des filtres pour chaque famille. Les barres vertes caractérisent les familles pour lesquelles le gène responsable de la pathologie a été identifié parmi la liste de gène (dans ce cas le symbole du gène est écrit au-dessus de la barre). La barre orange caractérise la famille pour laquelle un candidat potentiel a été identifié (le symbole du gène est écrit au-dessus suivit d'un \"?\"). Les barres rouges indiquent qu'aucun des gènes ayant passé les filtres pour ne semble expliquer le phénotype (dans ce cas il est écrit \"???\" au-dessus de la barre)"
fig_info <- paste(fig_name, " : ", fig_description)

ggplot(df_causal, aes(Family, N)) +
  geom_bar(stat = "identity", aes(fill = FIND_CAUSAL)) +
  scale_y_continuous(limits = c(0,max(df_causal$N) + 1), breaks = seq(0,max(df_causal$N) + 1,2)) +
  geom_text(aes(label = CAUSAL), position = position_dodge(width = .9), vjust = -.25) +
  ylab("Nb of remaining genes after all filtering") +
  theme(axis.title.x=element_blank()) +
  scale_fill_manual(name = "Is the causal variant found?", limits = c("Yes", "Maybe", "No"), values = c("chartreuse3", "#FF7F00", "#E41A1C")) + 
  theme(legend.position = "bottom")

```

```{r cleanpart1, include=FALSE, warning=FALSE}

rm(df_annotate, df_ctrl_all)
gc()

```


\newpage


### Etude d’une large cohorte de patients MMAF  {#cohortemmah}  

#### Description de la cohorte  

```{r cohort, cache=TRUE}

run_mmaf_fam <- c("Ghs56","Ghs58","Ghs62","Ghs130","Ghs63","Ghs119","Ghs59","Ghs60","Ghs61")

df_runs_mmaf <- fread("data/exome_runs.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, drop = c(2,3,4,10:16), data.table = FALSE) %>%
  rename(RUN = `Magic ID`, PHENOTYPE = Pathologie, DATE = Date) %>%
  mutate(PHENOTYPE = if_else(PHENOTYPE == "Flag", "MMAF", PHENOTYPE),
         YEAR = as.numeric(str_sub(DATE, start= -4)),
         PROJECT = paste0(Project," (",YEAR,")")) %>%
  filter(!(RUN %in% run_mmaf_fam),
         PHENOTYPE == "MMAF") %>%
  select(-DATE, -PHENOTYPE)

runs_bigmmaf <- df_runs_mmaf %>% collect() %>% .[["RUN"]]

```

Historique : après avoir mis en évidence DNAH1 -> MMAF notre équipe s'est en partie spécialisé dans ce syndrome.

ainsi, entre (année) et année, notre équipe a effectué le séquençage de ... individus présentant ce phénotype afin d'en établir la cause génétique. 
parmi ces patients, la majorité provenait d'Afrique du Nord, cependant ... vfenaient de et de ...
ces séquençage ont été effectué dans ... centres diférents que sont (listes des centre de séquençage) et sur ... plateforme : liste des plateformes


```{r tabcohort}

kable(df_runs_mmaf %>% 
        select(-Model, -PROJECT) %>% 
        rename(Place = Project, Run = RUN, Year = YEAR) %>%
        group_by(Place, Year) %>% 
        summarise(`Nb of sequenced individuals` = n()) %>%
        arrange(Year),
      longtable = TRUE,
      booktabs = TRUE, 
      caption = "Liste des différents projets de séquençages effectués")

```

\newpage

#### Application de la pipeline - Résultats

```{r extradata, cache=TRUE}

df_rvis <- fread("data/RVIS_Unpublished_ExAC_May2015.txt",sep = "\t",header = TRUE,data.table = FALSE) %>%
  select(SYMBOL = CCDS_r15,SCORE = `RVIS_ExAC_0.05%(AnyPopn)`) %>%
  mutate(RVIS_PERCENTILE = percent_rank(SCORE)) %>%
  select(-SCORE) %>%
  na.omit()

df_cilliome_gene <- fread("data/ciliome.csv",sep = "\t",header = TRUE, data.table = FALSE) %>% 
  select(SYMBOL = Symbol, EVIDENCE = `Novelty category`, LOCALISATION = `Immunostaining of cilia`) %>% 
  mutate(EVIDENCE = substring(EVIDENCE, 4),
         EVIDENCE = if_else(is.na(EVIDENCE), "Not in the list",
                            if_else(grepl("Strong", EVIDENCE), "Strong",
                                    if_else(grepl("Weak", EVIDENCE), "Weak", "Novel"))),
         LOCALISATION = substring(LOCALISATION, 4))

n_cilliome_gene <- df_cilliome_gene %>% nrow

df_canonical_transcripts <- fread("results/human_canonical_transcripts_v75.fa", header = FALSE) %>% 
  rename(Feature = V1) %>%
  mutate(Feature = gsub("\\..*","", Feature))

df_ctrl_mmaf <- open_ctrl("data/genotype_not_MMAF.csv", pheno = "MMAF")



```

```{r bigmmafcall, cache=TRUE}

bigmmaf_call_file <- "results/bigmmaf_call.rds"

if (!file.exists(bigmmaf_call_file)) {
  
  df_bigmmaf_call <- fread("data/genotype_MMAF.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE) %>%
    gather(RUN, CALL, starts_with("Ghs")) %>%
    filter(CALL %in% c(0, 2, 3, "b", "c"),
           !(RUN %in% run_mmaf_fam),
           !is.na(REF)) %>%
    mutate(STRAND = if_else(CALL %in% c(2:9), "DS", 
                            if_else(CALL == 0, "NS", "SS")),
      TYPE = if_else(stri_length(REF) == stri_length(ALT), "SNV", "Indel"),
           CALL = if_else(CALL == 0, "None",
                          if_else(CALL %in% c(2, "b"), "Heterozygous", "Homozygous")))
  saveRDS(df_bigmmaf_call, bigmmaf_call_file)
  
} else {
  
  df_bigmmaf_call <- readRDS(bigmmaf_call_file)

}

df_bigmmaf_call_geno <- df_bigmmaf_call %>% 
  filter(grepl("zygous", CALL)) %>% 
  group_by(RUN, TYPE, CALL) %>% 
  distinct(CHR, POSITION, REF, ALT) %>%
  count() %>%
  left_join(df_runs_mmaf, by = "RUN") %>% 
  select(-(Project:Model))
                       
df_bigmmaf_call_strand <- df_bigmmaf_call %>%
  group_by(RUN, STRAND) %>%
  count() %>%
  group_by(RUN) %>%
  mutate(N_ALL_STRAND = sum(n),
         P_STRAND = n / N_ALL_STRAND) %>%
  left_join(df_runs_mmaf, by = "RUN")

df_distinct_call <- df_bigmmaf_call %>%  
  filter(grepl("zygous", CALL)) %>% 
  distinct(CHR, POSITION, REF, ALT, TYPE) %>%
  variant_join(fread("data/all_variants_vep81.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, drop = c(11,12,14:28,31:34,36:40)), mode = "left") %>%
  mutate(PolyPhen = gsub("_", " ", str_extract(PolyPhen, "\\w+")),
         SIFT = gsub("_", " ", str_extract(SIFT, "\\w+")),
         Consequence = sapply(strsplit(Consequence, "_variant", fixed = TRUE),"[[",1),
         Consequence = gsub("_", " ", Consequence))

```

```{r varbigmmafcall, dependson="bigmmafcall", cache=TRUE}

n_distinct_var <- df_distinct_call %>% nrow %>% as.integer
n_distinct_snv <- df_distinct_call %>% filter(TYPE == "SNV") %>% nrow %>% as.integer
n_distinct_indel <- df_distinct_call %>% filter(TYPE == "Indel") %>% nrow %>% as.integer

n_mean_var <- df_bigmmaf_call_geno %>% group_by(RUN) %>% summarise(N = sum(n)) %>% collect() %>% .[["N"]] %>% mean %>% round(0) %>% as.integer
n_mean_snv <- df_bigmmaf_call_geno %>% filter(TYPE == "SNV") %>% group_by(RUN) %>% summarise(N = sum(n)) %>% collect() %>% .[["N"]] %>% mean %>% round(0) %>% as.integer
n_mean_indel <- df_bigmmaf_call_geno %>% filter(TYPE == "Indel") %>% group_by(RUN) %>% summarise(N = sum(n)) %>% collect() %>% .[["N"]] %>% mean %>% round(0) %>% as.integer

n_mean_homo <- df_bigmmaf_call_geno %>% filter(CALL == "Homozygous") %>% group_by(RUN) %>% summarise(N = sum(n)) %>% collect() %>% .[["N"]] %>% mean %>% round(0) %>% as.integer
p_mean_homo <- (n_mean_homo / n_mean_var)  %>% round(3) * 100 

ns_geno_2015_mean <- df_bigmmaf_call_strand %>% filter(PROJECT == "Genoscope (2015)", STRAND == "NS") %>% collect() %>% .[["P_STRAND"]] %>% median %>% round(3) * 100

```

Après avoir appelé les variants de nos `r n_run_bigmmaf` patients, nous avons obtenu un total de `r n_distinct_var` variants différents comprenant `r n_distinct_snv` SNVs et `r n_distinct_indel` indels. Ces variants étant répartit entre chaque patient qui portaient environs chacun `r n_mean_snv` SNV et `r n_mean_indel` indels dont `r p_mean_homo` % étaient homozygote. Comme on peut le voir, la proportion de chaque appel est relativement homogène lorsque l'on compare les patients ayant été séquencés dans le même centre la même année. Cependant, il est possible de noter de grandes disparités lorsque l'on compare les données provenant de différents centres ou bien du même centre avec plusieurs années de différences. Ces écarts peuvent-être causés par plusieurs facteur, tel que les différents kits de capture d'exons qui on put être utilisés puisque ... (**todo lister les différents kits de capture dans une table**) en revanche nous pouvons écarter un effet dus à la plateforme de séquençage ou encore le modèle de séquenceur puisque tous ces projets ont été réalisés sur des Illumina HiSeq2000 (**Table : **\@ref(tab:tabcohort)) (**Figure : **\@ref(fig:plotbigmmafcall) - **A**).  

Le même constat peut être effectué lorsque l'on compare la qualité des appels puisque plus les projets de séquençage s'avèrent être récent, plus la proportion d'appel *Single Strand* s'avère être faible tandis que la proportion d'appel *Double Strand* (DS) est élevée. Ceci est une bonne chose, car, bien que ces deux appels soient conservés dans les analyses ultérieures, les appels DS sont de meilleure qualité que les appels SS. Cette augmentation des appels DS au cours du temps pourrait s'expliquer par une amélioration des protocoles de séquençage ainsi que des kits de capture. En revanche cela est à pondérer avec le taux croissant d'appels *No-strand* (NS) au fur et à mesure des années pour atteindre environs `r ns_geno_2015_mean` % en 2015 avec un projet réalisé au Génoscope. Ces derniers appels étant systématiquement filtrés, ils n'altèreront en rien les résultats obtenus en aval hormis le fait qu'ils réduisent la quantité des données utilisées (**Figure : **\@ref(fig:plotbigmmafcall) - **B** et **C**).

\newpage

```{r plotbigmmafcall, dependson="bigmmafcall", fig.cap=fig_info,fig.scap=fig_name, fig.height=7.6, cache=TRUE}

fig_name <- "Résultats de l'appel des variants par individus et par projet de séquençage"
fig_description_general <- "Chaque couleur définit un projet de séquençage caractérisé par un centre de séquençage et une année"
fig_description_A <- "**A** : Quantification pour chaque individus (représentés par les barres) du nombre de variants (SNVs et Indels) appelés homozygotes et hétérozygotes"
fig_description_B <- "**B** : Quantification des appels *Double Strand* (DS), *Single Strand* (SS) et *No strand* (NS) pour chaque projet de séquençage"
fig_description_C <- "**C** : Même chose en pourcentage"
fig_description <- paste(fig_description_general, fig_description_A, fig_description_B, fig_description_C, sep = ". ")
fig_info <- paste0(fig_name, " : ", fig_description)

pA <- ggplot(df_bigmmaf_call_geno, aes(reorder(RUN, YEAR), n)) + 
  geom_bar(stat = "identity", aes(fill = PROJECT)) + 
  facet_grid(TYPE~CALL, scales = "free") +
  scale_fill_brewer(palette = "Set1", guide = "none") +
  ylab("Nb of called variants") + 
  theme(axis.title.x = element_blank(), 
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

pB <- ggplot(df_bigmmaf_call_strand, aes(reorder(PROJECT, YEAR), n)) + 
  geom_boxplot(outlier.size = -1, aes(fill = PROJECT)) + 
  facet_wrap(~factor(STRAND, levels = c("DS", "SS", "NS")), scales = "free") +
  ylab("Nb of call") + 
  scale_x_discrete(limits = c("Strasbourg (2012)", "MountSinai (2012)", "Genoscope (2013)", "Genoscope (2014)", "Genoscope (2015)")) +
   scale_fill_brewer(palette = "Set1", guide = "none") +
  theme(axis.title.x = element_blank(), 
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

pC <- ggplot(df_bigmmaf_call_strand, aes(reorder(PROJECT, YEAR), P_STRAND)) + 
  geom_boxplot(outlier.size = -1, aes(fill = PROJECT)) + 
  facet_wrap(~factor(STRAND, levels = c("DS", "SS", "NS")), scales = "free") +
  scale_x_discrete(limits = c("Strasbourg (2012)", "MountSinai (2012)", "Genoscope (2013)", "Genoscope (2014)", "Genoscope (2015)")) +
  scale_fill_brewer(palette = "Set1", name = "Sequencing project", 
                    breaks = c("Strasbourg (2012)", "MountSinai (2012)", "Genoscope (2013)", "Genoscope (2014)", "Genoscope (2015)")) +
  ylab("% of call") + 
  scale_y_continuous(labels = percent) +
  theme(legend.position = "bottom",
        legend.title = element_blank(),
        axis.title.x = element_blank(), 
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())


row2 <- plot_grid(pB,pC, ncol = 1, rel_heights = c(.43,.57), labels = c("B","C"))

plot_grid(pA,row2, ncol = 1, rel_heights = c(.45,.55), labels = c("A",""))

```

\newpage

#### Analyse des listes de gènes  

```{r filterbigmmaf, dependson=c("bigmmafcall","extradata"), cache=TRUE}

maf_cutoff <- .01

df_distinct_filter <- df_distinct_call %>%   
  filter_frequence(cutoff = maf_cutoff) %>%
  variant_join(df_ctrl_mmaf, mode = "anti") %>%
  filter(Consequence != "synonymous",
         IMPACT != "MODIFIER",
         !(grepl("tolerated", SIFT) & grepl("benign", PolyPhen)),
         !grepl("NMD transcript", Consequence),
         !grepl("non coding transcript", Consequence)) %>%
  left_join(df_rvis, by = "SYMBOL") %>%
  left_join(df_cilliome_gene, by = "SYMBOL")

df_bigmmaf_filter <- df_bigmmaf_call %>%  
  select(-STRAND) %>%
  filter_genotype(het = FALSE) %>% 
  variant_join(df_distinct_filter, mode = "inner") %>% 
  select(-Allele) %>% 
  mutate(SYMBOL = if_else(SYMBOL == "WDR52", "CFAP44", 
                          if_else(SYMBOL == "WDR96", "CFAP43", SYMBOL))) %>%
  ungroup()
  

df_bigmmaf_filter_stat <- df_bigmmaf_filter %>% 
  group_by(RUN) %>%
  mutate(N_GENE = n_distinct(SYMBOL)) %>%
  group_by(RUN, TYPE, N_GENE) %>%
  distinct(CHR, POSITION, REF, ALT) %>%
  summarise(N_VAR_PER_TYPE = n()) %>%
  group_by(RUN) %>%
  mutate(N_VAR_TOT = sum(N_VAR_PER_TYPE)) %>%
  right_join(df_runs_mmaf, by = "RUN") 
  

df_bigmmaf_genes <- df_bigmmaf_filter %>% group_by(SYMBOL, EVIDENCE, LOCALISATION) %>% distinct(RUN) %>% mutate(N_RUN = n()) 
df_bigmmaf_genes_distinct <- df_bigmmaf_genes %>% distinct(N_RUN)
df_bigmmaf_genes_resume <- df_bigmmaf_genes_distinct %>% distinct(N_RUN) %>% group_by(N_RUN) %>% summarise(N_GENE = n()) 

```

```{r filterhetbigmmaf, dependson="bigmmafcall", cache=TRUE}

df_bigmmaf_filter_het <- df_bigmmaf_call %>% 
  select(-STRAND) %>% 
  filter_genotype(homo = FALSE) %>% 
  variant_join(df_distinct_filter, mode = "inner") %>% 
  select(-Allele) %>%
  group_by(RUN, SYMBOL, Feature) %>%
  mutate(N_VAR_PER_RUN_PER_GENE = n()) %>% 
  filter(N_VAR_PER_RUN_PER_GENE > 1) %>% 
  group_by(SYMBOL) %>%
  mutate(N_RUN_PER_GENE = n_distinct(RUN)) %>%
  ungroup() %>%
  mutate(SYMBOL = if_else(SYMBOL == "WDR52", "CFAP44", 
                          if_else(SYMBOL == "WDR96", "CFAP43", SYMBOL)))

```


```{r}
# Pierre Ray 

# bind_rows(df_runs %>% select(RUN = `Magic ID`, Patient) %>% filter(Patient == "12") %>% inner_join(df_bigmmaf_filter),
#           df_runs %>% select(RUN = `Magic ID`, Patient) %>% filter(Patient == "12") %>% inner_join(df_bigmmaf_filter_het)) %>% 
#   
#   inner_join(df_canonical_transcripts) %>% 
#   select(-N_VAR_PER_RUN_PER_GENE, -N_RUN_PER_GENE) %>% 
#   add_exp() %>% 
#   write.table("~/Bureau/canonical_variants_homo_het_16IF93.csv", sep = "\t", row.names = FALSE)


```

```{r cleanbigmmafcall, include=FALSE, warning=FALSE}

rm(df_distinct_call, df_distinct_filter)
# rm(df_distinct_call)
rm(df_bigmmaf_call)
gc()

```

```{r varfilterbigmmaf, dependson="filterbigmmaf", cache=TRUE}

n_distinct_var <- df_bigmmaf_filter %>% ungroup() %>% distinct(CHR, POSITION, REF, ALT) %>% nrow
n_distinct_snv <- df_bigmmaf_filter %>% ungroup() %>% filter(TYPE == "SNV") %>% distinct(CHR, POSITION, REF, ALT) %>% nrow
n_distinct_indel <- df_bigmmaf_filter %>% ungroup() %>% filter(TYPE == "Indel") %>% ungroup() %>% distinct(CHR, POSITION, REF, ALT) %>% nrow
n_distinct_gene <- df_bigmmaf_filter %>% ungroup() %>% distinct(SYMBOL) %>% nrow

n_min_var <- df_bigmmaf_filter_stat %>% collect() %>% .[["N_VAR_TOT"]] %>% min
n_max_var <- df_bigmmaf_filter_stat %>% collect() %>% .[["N_VAR_TOT"]] %>% max

n_mean_indel <- df_bigmmaf_filter_stat %>% filter(TYPE == "Indel") %>% collect() %>% .[["N_VAR_PER_TYPE"]] %>% mean %>% round(0)
n_mean_snv <- df_bigmmaf_filter_stat %>% filter(TYPE == "SNV") %>% collect() %>% .[["N_VAR_PER_TYPE"]] %>% mean %>% round(0)

n_min_gene <- df_bigmmaf_filter_stat %>% collect() %>% .[["N_GENE"]] %>% min
n_max_gene <- df_bigmmaf_filter_stat %>% collect() %>% .[["N_GENE"]] %>% max

```

Après avoir appliqué les mêmes filtres que ceux décrit précédemment à l'exception du filtre n°1 ["Union"](#filterdescription) puisqu'ici nous avons uniquement des individus non apparentés, nous avons pu obtenir une liste de `r n_distinct_var` variants différents composés de `r n_distinct_snv` SNVs et `r n_distinct_indel` indels et impactant un total de `r n_distinct_gene` gènes distincts. Ces variants étant répartis sur l'ensemble de nos `r n_run_bigmmaf` patients ceux-ci portaient en moyenne `r n_mean_snv` SNVS et `r n_mean_indel` indels, de sorte que chacun d'entre eux avaient entre `r n_min_gene` et `r n_max_gene` gènes impactés par au moins un variants homozygote (**Figure : **\@ref(fig:plotfilterbigmmaf) - **A** et **B**).  


```{r plotfilterbigmmaf, dependson="filterbigmmaf", fig.cap=fig_info,fig.scap=fig_name, fig.height=5, cache=TRUE}

fig_name <- "Résultats de l'étape de filtrage"
fig_description_general <- "Chaque couleur définit un projet de séquençage caractérisé par un centre de séquençage et une année"
fig_description_A <- "**A** : Quantification du nombre de SNVs et indels ayant passé l'ensemble des filtres pour chaque patient"
fig_description_B <- "**B** : Nombre de gènes impactés par au moins un variant ayant passé les filtres pour chaque individu représenté par les barres"
fig_description_C <- "**C** : Présentation "

fig_description <- paste(fig_description_A, fig_description_B, fig_description_C, sep = ". ")
fig_info <- paste0(fig_name, " : ", fig_description)

pA <- ggplot(df_bigmmaf_filter_stat, aes("", N_VAR_PER_TYPE)) +
  geom_boxplot(outlier.size = -1, alpha = .8, aes(fill = TYPE)) + 
  geom_jitter(position=position_jitter(0.3)) +
  scale_fill_brewer(guide = "none", palette = "Set1") +
  facet_wrap(~factor(TYPE, levels = c("SNV", "Indel")), scales = "free") + 
  ylab("Nb of remaining variants after filters") + 
  xlab("") + 
  coord_flip() + 
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank())

pB <- ggplot(df_bigmmaf_filter_stat %>% group_by(RUN) %>% summarise(N_GENE = mean(N_GENE)), aes(reorder(RUN, -N_GENE), N_GENE)) + 
  geom_bar(stat = "identity", fill = "#999999") + 
  ylab("Nb of remaining genes") +
  xlab("Runs") + 
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank()) 

plot_grid(pA,pB, rel_heights = c(.33,.67), ncol = 1, labels = c("A","B"))

# plot_grid(row1, pC, ncol = 1, rel_heights = c(.55,.45), labels = c("","C"))

```

\newpage


Afin de déterminer parmi cette ensemble de gènes ceux responsables du phénotype de nos patients, nous avons procédés en trois étapes : 

1. **Étape n°1** : Cette étape consiste à séléctionner uniquement les variants ayant un effet tronquant sur la protéine comme un décalage du cadre de lecture, l'apparition d'un codon stop prématuré ou encore une perturbation des sites accepteurs / donneur d'épissage. Une analyse de l'expression testiculaire des gènes retenus ainsi qu'une étude bibliographique nous permet ensuite de séléctionner tout ou partie de ceux-ci. Du fait des effets extremement délétères de ces variants, les patients ressortant de cette première étape sont considérés comme de confience élevée (*High trust*).   
2. **Étape n°2** : Pour l'ensemble des gènes retenus dans l'étape n°1, nous recherchons ensuite des patients portant, toujours à l'état homozygote, des variant aux effet non tronquant tel que des variants faux-sens ou encore des variants intronique situés proches des sites d'épissage. Dans le cas des variants faux-sens, les logiciels SIFT et PolyPhen sont ensuite utilisés afin de nous orienter quant à l'effet délétère du variant, bien que comme nous l'avons déjà vu, ces logiciels son contredisent regulièrement [TODO : ref!!!]. Au vus de la difficulté à déterminer l'effet délétère de ces variants, les patients identifiés au cours de cette étape sont marqués comme de confience modérée (*Moderate trust*).    
3. **Étape n°3** : Cette étape consiste à recherchere des patients éventuellement hétérozygotes composites, c'est à dire des patients portant deux variants hétérozygotes différents sur chacun des deux allèles d'un même gène. Malheuresement, dans le cadre de séquençage WES WGS, il est impossible de connaitre le "phasage" des variants, c'est à dire que l'on ne peut déterminer si deux variants hétérozygotes sont situés sur le même allèles ou sur deux allèles différents. Pour cela, des analyses de biologie moléculaire sont nécéssaire. C'est pour cette raison que les patients identifier au cours de cette étape sont labellisés comme étant de faible confience (*Low trust*).  
4. **Étape n°4** : Les données des patients pour lesquels les étapes 1 à 3 ont permis d'identifier un ou plusieurs variants causaux **avec certitude** sont ensuite retirées pour les analyses ulterieures, allegeant ainsi le nombre de variant et donc de gène à analyser.  

\newpage  

##### *DNAH1*, un acteur primordial dans le phénotype MMAF   

```{r dnah1, dependson=c("localfunction","filterbigmmaf"), cache=TRUE}


df_bigmmaf_filter_homo_het <- df_bigmmaf_filter_het %>%
  bind_rows(df_bigmmaf_filter) %>%
  mutate(ONE_HOMO = if_else(CALL == "Homozygous", 1, 0)) %>%
  group_by(SYMBOL, Feature) %>%
  filter(sum(ONE_HOMO) > 0) %>%
  ungroup()

```

```{r dfdnah1high}

df_dnah1_high <- df_bigmmaf_filter %>% 
  filter(SYMBOL == "DNAH1",
         IMPACT == "HIGH") %>%
  ungroup()

```

```{r vardnah1high}

run_dnah1_high <- df_dnah1_high %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
n_run_dnah1_high <- run_dnah1_high %>% length

```

```{r dfdnah1moderate}

df_dnah1_moderate <-  df_bigmmaf_filter %>% 
  filter(SYMBOL == "DNAH1",
         IMPACT != "HIGH")

```

```{r vardnah1moderate}

run_dnah1_moderate <- df_dnah1_moderate %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
n_run_dnah1_moderate <- run_dnah1_moderate %>% length

p_run_dnah1_homo <- ((n_run_dnah1_high + n_run_dnah1_moderate) / n_run_bigmmaf) %>% round(2) * 100


```

```{r dfdnah1low}

df_dnah1_low <-  df_bigmmaf_filter_het %>% 
  filter(SYMBOL == "DNAH1",
         N_VAR_PER_RUN_PER_GENE > 1)

```

```{r vardnah1low}


run_dnah1_low <- df_dnah1_low %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
n_run_dnah1_low <- run_dnah1_low %>% length

p_run_dnah1_tot <- ((n_run_dnah1_high + n_run_dnah1_moderate + n_run_dnah1_low) / n_run_bigmmaf) %>% round(2) * 100


```


```{r resumednah1, cache=TRUE}


df_resume_dnah1 <- bind_rows(df_dnah1_high %>% group_by(RUN, SYMBOL) %>% summarise(TRUST = "High"),
                             df_dnah1_moderate %>% group_by(RUN, SYMBOL) %>% summarise(TRUST = "Moderate"),
                             df_dnah1_low %>% group_by(RUN, SYMBOL) %>% summarise(TRUST = "Low")) %>% 
  group_by(TRUST, SYMBOL) %>%
  summarise(N_RUN = n_distinct(RUN)) %>% 
  select(SYMBOL, N_RUN, TRUST) %>%
  group_by(SYMBOL) %>% 
  mutate(TOT = sum(N_RUN)) %>% 
  spread(TRUST, N_RUN) %>%
  mutate(Moderate = na.replace(Moderate, 0),
         Low = na.replace(Low, 0)) 

```


```{r removednah1, dependson="filterbigmmaf", cache=TRUE}

run_found <- c(run_dnah1_high, run_dnah1_moderate)

df_bigmmaf_filter2 <- df_bigmmaf_filter %>% 
  filter(!(RUN %in% run_found)) 
  
df_bigmmaf_filter_het2 <- df_bigmmaf_filter_het %>% 
  filter(!(RUN %in% run_found))  

df_bigmmaf_genes_distinct2 <- df_bigmmaf_filter2  %>% 
  group_by(SYMBOL, EVIDENCE, LOCALISATION) %>% 
  distinct(RUN) %>%
  mutate(N_RUN = n()) %>% 
  distinct(N_RUN) 

df_bigmmaf_genes_resume2 <- df_bigmmaf_genes_distinct2 %>% 
  distinct(N_RUN) %>% 
  group_by(N_RUN, EVIDENCE, LOCALISATION) %>% 
  summarise(N_GENE = n()) %>% 
  filter(N_RUN > 1) 

```

```{r varremovednah1, cache=TRUE}

n_found <- run_found %>% length
n_distinct_var2 <- df_bigmmaf_filter2 %>% distinct(CHR, POSITION, REF, ALT) %>% nrow
n_distinct_gene2 <- df_bigmmaf_genes_distinct2 %>% nrow

```

Au moment de nos analyses, le gène *DNAH1* était encore le seul décrit comme responsable du phénotype MMAF faisant de lui un candidat évident pour expliquer le phénotype MMAF de nos patients malgrés on expression non spécifique au testicule (**Figure : **\@ref(fig:plotdnah1) - **A**). C'est pourquoi nous avons appliquer les 3 étapes précédement décrites en ciblant spécifiquement les patients ayant des variants chevauchant les gène *DNAH1*.  

Ainsi, nous avons pu identifier `r n_run_dnah1_high + n_run_dnah1_moderate` de nos patients portant au moins un variant homozygote sur le gène *DNAH1* dont `r n_run_dnah1_high` portant un indel entrainant un décalage du cadre de lecture ayant ainsi un effet tronquant sur la protéine. Pour les `r n_run_dnah1_moderate` autres, le patient Ghs90 porte 3 variants successifs induisant 3 variation faux-sens, le patient Ghs95 porte lui un seul variant entrainant lui aussi un faux-sens. On peut noter que SIFT ne propose aucune prédiction pour aucun de ces trois faux-sens faux-sens tandis que PolyPhen les prédit tous comme *benign*. Cependant, l'implication déjà bien connue de ce gène dans le phénotype MMAF (**Table : **\@ref(tab:tabdnah1)).  

La recherche d'hétérozygotes composites nous a permis d'identifier `r n_run_dnah1_low` autres patients. Parmis ceux-ci, on peut noter le patients Ghs36 portant à la fois un faux-sens prédit comme *probably damaging* par PolyPhen (pas de prédiction pour SIFT) ainsi qu'un second entrainant la formation d'un codon stop prématuré. Pour les `r n_run_dnah1_low - 1` autres, les variant entrainent pour la plupart des mutations faux-sens (**Table : **\@ref(tab:tabdnah1)).  

Ainsi, cette première analyse nous a permis de révéler que `r n_run_dnah1_high + n_run_dnah1_moderate + n_run_dnah1_low` des `r n_run_bigmmaf` patients de notre cohorte portaient au moins 1 variant sur le gène *DNAH1* et que pour `r n_run_dnah1_high + n_run_dnah1_moderate` d'entre eux ce(s) variants étaient présents à l'état homozygote. Ainsi, les mutations du gène *DNAH1* seraient ainsi responsables du phénotype MMAF de `r p_run_dnah1_homo` % si l'on ne considère que les patients portant un variant homozygote à `r p_run_dnah1_tot` % si l'on compte égallement les patients potentiellement héérozygotes composites (**Figure : **\@ref(fig:plotdnah1) - **B**).  

Bien que ce pourcentage soit en deçà des 40% (TODO: à confirmer!) observés dans notre étude précédente [@BenKhelifa2014], ces résultats confirment néanmoins le rôle primordial de la protéine DNAH1 dans la structure du flagelle et l'implication majeure du gène *DNAH1* dans le phénotype MMAF.   
La cause génétique expliquant le phénotype MMAF ayant été identifié avec certitude chez au moins `r n_run_dnah1_high + n_run_dnah1_moderate` des patients (ceux portant un variant homozygotes), l'intégralité de leurs variants spécifiques (retrouvés chez aucun autre patients) fut retirée de notre liste réduisant celle-ci à `r n_distinct_var2` variants impactant `r n_distinct_gene2` gènes différents.  

\newpage

```{r plotdnah1, fig.cap=fig_info, fig.height=8, fig.scap=fig_name, cache=TRUE}

fig_name <- "Analyse du gène *DNAH1*"



fig_description_A <- "Expression tissulaire du gène *DNAH1* d'après les données du projet Illumina BodyMap"
fig_description_B <- "Quantification du nombre de patients portant au moins un variant sur le gène *DNAH1* pour chacun des 3 niveau de confiance"

fig_description <- paste(fig_description_A, fig_description_B, fig_description_C, sep = ". ")
fig_info <- paste0(fig_name, " : ", fig_description)

pA <- plot_expression("dnah1", "percent", TRUE) +
  xlab("") + 
  theme(legend.position = c(1,.5),
        legend.justification = c(1,.5))


pB <- ggplot(df_resume_dnah1 %>% 
               gather(TRUST,NB,High:Moderate) %>%
               mutate(TRUST = factor(TRUST, levels = c("High","Moderate","Low"))),
             aes(TRUST, NB)) +
  geom_col(aes(fill = TRUST)) + 
  scale_fill_manual(guide = "none", values = c("#4DAF4A","#FF7F00","#E41A1C")) + 
facet_wrap(~SYMBOL) + 
  ylab("Nb of individuals") + 
  xlab("")

plot_grid(pA,pB, labels = c("A","B"), ncol = 1)


```

\newpage

```{r tabdnah1, cache=TRUE}


kable(bind_rows(df_dnah1_high %>% mutate(TRUST = "High"),
                df_dnah1_moderate %>% mutate(TRUST = "Moderate"),
                df_dnah1_low %>% mutate(TRUST = "Low")) %>% 
        inner_join(df_canonical_transcripts, by = "Feature") %>% 
        mutate(SIFT = na.replace(SIFT, "No prediction"), 
               PolyPhen = na.replace(PolyPhen, "No prediction"),
               TRUST = factor(TRUST, levels = c("High","Moderate","Low"))) %>% 
        arrange(TRUST, RUN) %>%
        select(Patient = RUN, Trust = TRUST, Consequence, Genotype = CALL, SIFT, PolyPhen),
      booktabs = TRUE,
      longtable = TRUE,
      caption = "Liste des patients portant un variant non troquant homozygote sur un des gènes suivant : TODOOOOOO")

```

\newpage

##### Les nouveaux acteurs  

```{r, dependson="removednah1"}

n_gene_more1 <- df_bigmmaf_genes_distinct2 %>% filter(N_RUN > 1) %>% nrow
n_gene_2 <- df_bigmmaf_genes_distinct2 %>% filter(N_RUN == 2) %>% nrow
p_gene_2 <- (n_gene_2 / n_gene_more1) %>% round(2) * 100

```

```{r, dependson="removednah1", cache=TRUE}

df_bigmmaf_genes_cil <- df_bigmmaf_genes_distinct2 %>% 
         filter(EVIDENCE != "Not in the list")


n_gene_cil <- df_bigmmaf_genes_cil %>% nrow
n_gene_cil_strong <- df_bigmmaf_genes_cil %>% filter(EVIDENCE == "Strong") %>% nrow

```

```{r newcandidats, dependson=c("localfunction","removednah1"), cache=TRUE}

df_bigmmaf_filter_homo_het2 <- df_bigmmaf_filter_het2 %>%
  bind_rows(df_bigmmaf_filter2) %>%
  mutate(ONE_HOMO = if_else(CALL == "Homozygous", 1, 0)) %>%
  group_by(SYMBOL, Feature) %>%
  filter(sum(ONE_HOMO) > 0) %>%
  ungroup()

c(tabwdr96, run_homo_wdr96, run_het_wdr96, n_run_homo_wdr96, n_run_het_wdr96) %tin% (df_bigmmaf_filter_homo_het2 %>% tab_gene("WDR96"))
c(tabwdr52, run_homo_wdr52, run_het_wdr52, n_run_homo_wdr52, n_run_het_wdr52) %tin% (df_bigmmaf_filter_homo_het2 %>% tab_gene("WDR52"))
c(tabfsip2, run_homo_fsip2, run_het_fsip2, n_run_homo_fsip2, n_run_het_fsip2) %tin% (df_bigmmaf_filter_homo_het2 %>% tab_gene("FSIP2"))
c(tabccdc146, run_homo_ccdc146, run_het_ccdc146, n_run_homo_ccdc146, n_run_het_ccdc146) %tin% (df_bigmmaf_filter_homo_het2 %>% tab_gene("CCDC146"))
c(tabttc29, run_homo_ttc29, run_het_ttc29, n_run_homo_ttc29, n_run_het_ttc29) %tin% (df_bigmmaf_filter_homo_het2 %>% tab_gene("TTC29"))
c(tabefcab6, run_homo_efcab6, run_het_efcab6, n_run_homo_efcab6, n_run_het_efcab6) %tin% (df_bigmmaf_filter_homo_het2 %>% tab_gene("EFCAB6"))
c(tablrrc43, run_homo_lrrc43, run_het_lrrc43, n_run_homo_lrrc43, n_run_het_lrrc43) %tin% (df_bigmmaf_filter_homo_het2 %>% tab_gene("LRRC43"))
c(tabarmc2, run_homo_armc2, run_het_armc2, n_run_homo_armc2, n_run_het_armc2) %tin% (df_bigmmaf_filter_homo_het2 %>% tab_gene("ARMC2"))
c(tabankrd20a3, run_homo_ankrd20a3, run_het_ankrd20a3, n_run_homo_ankrd20a3, n_run_het_ankrd20a3) %tin% (df_bigmmaf_filter_homo_het2 %>% tab_gene("ANKRD20A3"))

```

Ensuite, afin de nous orienter dans nos recherches, nous nous sommes basés sur une étude de 2012 qui établissait une liste des gènes humains pouvant être impliqués dans cilliome, c'est à dire (todo def cilliome) [@Ivliev2012]. La constitution de cette liste se basait à la fois sur les données de CilDB [ref ? ] et de MEDLINE [ ref ? ] mais aussi des analyse *in silico* permettant d'effectuer des prédiction. Ainsi, chaque gène était classé dans l'une des ... catégories suivantes en fonction des preuves déjà existante (au moment de l'étude) permettant de lier un gène au cilliome humain : **Strong evidence from previous studies** (Strong), **Weak evidence from previous studies** (Weak) et **No evidence from previous studies** (Novel). L'utilisation de cette liste afin d'ajouter une nouvelle annotation à nos gènes est pertinente puisque le spermatozoïde humain est une cellule ciliée, et le flagelle en est le cil. Nous pouvons donc attendre à ce qu'une partie des gènes responsables du phénotype MMAF soit présents dans cette liste recensant `r n_cilliome_gene` gènes classés dans trois catégories en fonction de la qualité de la preuve permettant de définir le gène comme appartenant au cilliome : 

Ainsi, `r n_gene_cil` de nos `r n_distinct_gene2` gènes retenus faisaient partis de cette liste dont `r n_gene_cil_strong` présentaient des preuves fortes de leur appartenance au cilliome. Il faut tout de même noter que bien que cette liste soit un bon outil pour orienter les recherches et prioriser certains gènes, elle ne peut constituer un critère suffisant pour filtrer les gènes n'en faisant pas partie. Par exemple le gène *DNAH1*, de par son expression ubiquitaire n'a pas été intégré à cette liste (**Figure : **\@ref(fig:expdnah1), or on connait désormais son implication dans le phénotype MMAF (**Figure : **\@ref(fig:plotfilterbigmmaf2) - **A**).  

Suite à cela, afin de nous concentrer en priorité sur les gènes entrainant un phénotype MMAF chez le plus grand nombre d'individus, nous avons sélectionnés ceux sur lesquels plusieurs patients portaient au moins un variant ayant passé l'ensemble des filtres nous permettant alors d'obtenir une liste de `r n_gene_more1` gènes dont `r n_gene_2` (soit `r p_gene_2` %) étaient retrouvés variants chez uniquement 2 patients (**Figure : **\@ref(fig:plotfilterbigmmaf2) - **B**). 


\newpage

```{r dfgrp1high, dependson="removednah1", cache=TRUE}

df_bigmmaf_high <- df_bigmmaf_filter2 %>% 
  filter(IMPACT == "HIGH") %>%
  group_by(SYMBOL, Feature) %>%
  mutate(N_RUN = n_distinct(RUN)) %>% 
  filter(N_RUN > 1) %>% 
  group_by(SYMBOL) %>% 
  mutate(N_RUN = max(N_RUN)) %>% 
  group_by(RUN, SYMBOL) %>%
  distinct(Consequence, N_RUN, EVIDENCE)

df_distinct_high <- df_bigmmaf_high %>% 
  ungroup() %>% 
  distinct(SYMBOL, EVIDENCE, N_RUN)

df_distinct_cil_high <- df_distinct_high %>% 
  filter(EVIDENCE != "Not in the list") 

```

```{r vargrp1high, dependson="dfgrp1high", cache=TRUE}

n_gene_high <- df_distinct_high %>% nrow
gene_cil_high <- df_distinct_cil_high %>% distinct(SYMBOL) %>% collect() %>% .[["SYMBOL"]]

run_cil_high <- df_bigmmaf_high %>% filter(EVIDENCE != "Not in the list") %>% ungroup() %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
n_run_cil_high <- df_distinct_cil_high %>% summarise(N_TOT = sum(N_RUN)) %>% collect() %>% .[["N_TOT"]] 
n_gene_cil_high <- df_distinct_cil_high %>% nrow

```

```{r dfgrp1moderate, dependson="removednah1", cache=TRUE}

df_grp1_moderate <- df_bigmmaf_filter2 %>% 
  filter(SYMBOL %in% gene_cil_high,
         IMPACT != "HIGH") %>%
  group_by(SYMBOL, Feature) %>%
  mutate(N_RUN = n_distinct(RUN)) %>% 
  ungroup()

```

```{r vargrp1moderate, dependson="dfgrp1moderate", cache=TRUE}

n_gene_grp1 <- df_grp1_moderate %>% ungroup() %>% distinct(SYMBOL) %>% nrow
run_grp1 <- df_grp1_moderate %>% ungroup() %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
n_run_grp1 <- run_grp1 %>% length 

```

```{r dfgrp1low, cache=TRUE}

df_grp1_low <- df_bigmmaf_filter_het2 %>% 
  filter(SYMBOL %in% gene_cil_high,
           N_VAR_PER_RUN_PER_GENE > 1) %>% 
         group_by(SYMBOL, Feature) %>%
  mutate(N_RUN = n_distinct(RUN)) %>% 
  group_by(SYMBOL) %>% 
  mutate(N_RUN = max(N_RUN)) %>% 
  group_by(RUN, SYMBOL) 

```

```{r dfresumegrp1, dependson=c("dfgrp1high","dfgrp1moderate","dfgrp1low"), cache=TRUE}

df_resume_grp1 <- bind_rows(df_distinct_cil_high %>%
                                      select(-EVIDENCE) %>%
                                      mutate(TRUST = "High"),
                                    
                                    df_grp1_moderate %>%
                                      select(-EVIDENCE) %>%
                                      group_by(SYMBOL) %>%
                                      summarise(N_RUN = n_distinct(RUN), TRUST = "Moderate"),
                                    
                                    df_grp1_low %>%
                                      select(-EVIDENCE) %>%
                                      group_by(SYMBOL) %>%
                                      summarise(N_RUN = n_distinct(RUN), TRUST = "Low")) %>%
  select(SYMBOL, N_RUN, TRUST) %>%
  group_by(SYMBOL) %>%
  mutate(TOT = sum(N_RUN)) %>%
  spread(TRUST, N_RUN) %>%
  mutate(Moderate = na.replace(Moderate, char = 0))

```

```{r varresumegrp1, dependson="dfresumegrp1", cache=TRUE}

p_run_high_evidence <- df_resume_grp1 %>% ungroup() %>% summarise(P = sum(High)/ sum(TOT)) %>% collect() %>% .[["P"]] * 100

```


Afin de nous concentrer dans un premier temps sur les gènes ayant le plus de risque d'être responsable du phénotype, nous avons tout d'abord séléctionner ceux présent dans la liste des gènes du ciliome sur lesquels au moins 2 patients portaient une mutation homozygote ayant un effet tronquant sur la protéine. Nous sommes ainsi arrivé à une liste de `r n_gene_cil_high` gènes différents : `r gene_cil_high` présentant tous une forte expression testiculaire (**Table : **\@ref(tab:tabcilhigh), **Figure : **\@ref(fig:plotgrp1high)).

Parmi ces gènes, on peut noter que *CCDC146* codant pour la protéine CCDC146 avait déjà été décrit comme composant du centrosome spermatique, un organite ayant un rôle dans l'orientation des cellules et étant à l'origine des cils et des flagelles [@Firat-Karalar2014] reforçant ainsi les arguments de l'implication de ce gène dans le phénotype MMAF. L'analyse bibliographique des `r n_gene_cil_high - 1`  autres gènes n'a cependant rien révélés ceux-ci étant jusqu'à présent peu étudié.  

Après avoir identifié ces gènes, nous avons étendu notre champs de recherche en cherchant si d'autre patients portaient des variants homozygotes sur l'un d'eux en ne se limitant pas cette fois-ci aux variants tronquant. Nous avons ainsi pu identifier `r n_run_grp1` nouveaux patients présentant tout deux des variants faux-sens homozygote, l'un sur le gène *ARMC2*, l'autre sur *CFAP44*. On peut noter que ces deux variants faux-sens sont prédit comme délétère par au moins 1 des deux logiciels de prédiction utilisés (SIFT et PolyPhen).

Pour finir avec ce premier lot de gènes, nous avons comme précédemment cherché des patients potentiellement hétérozygotes composites, c'est à dire portant au moins deux variants hétérozygotes, tronquant ou non. Cependant, aucun de nos patients restant ne remplissaient ces critères

Pour résumer, cette première analyse nous a permis de mettre en évidence `r n_gene_grp1` gènes dont différents plusieurs preuves laissent supposer leur implication dans le phénotype MMAF de `r n_run_cil_high + n_run_grp1` de nos patients. Pamis ceux-ci, p_run_high_evidence % portent un variant tronquant à l'état homozygote nous donnant ainsi une grande confiance dans le fait que le variant soit effectivement à l'origine du phénotype. Pour l'ensemble des (100 - p_run_high_evidence) % restant, les variants faux-sens portés par ces patients laisse planer un doute, cependant, le fait que ...........

La cause génétique responsable du phénotype de ces `r n_run_cil_high + n_run_grp1` patients ayant été identifiés, nous avons comme précédemment avec les patients *DNAH1* retirer l'intégralité de leurs variants des analyses ulterieures afin de réduire à nouveau la liste des variants et des gènes à analyser facilitant ainsi les analyses. Ainsi, ... variants sur ... gènes.     

\newpage


```{r plotgrp1high, dependson="vargrp1", fig.cap=fig_info,fig.scap=fig_name, cache=TRUE}

fig_name <- 'Expression tissulaire des gènes retenus'
fig_description <- "Ici les gènes retenus sont les gènes présents dans la liste ciliome sur lesquels au moins deux patients portent un variant tronquant à l'état homozygote"


fig_info <- paste0(fig_name, " : ", fig_description)

plot_expression(gene_cil_high, mode = "percent", flip = TRUE) + 
  xlab("") + 
  theme(legend.position = c(1,.5),
        legend.justification = c(1,.5))


```

\newpage

```{r tabgrp1high, dependson="dfgrp1high", cache=TRUE}

kable(df_bigmmaf_high %>% 
        filter(EVIDENCE != "Not in the list") %>% arrange(SYMBOL) %>%
        select(Gene = SYMBOL, Patient = RUN, Consequence, Ciliome = EVIDENCE),
      booktabs = TRUE,
      longtable = TRUE,
      caption = "List des gènes sur lesquels au moins deux patients portent une mutation tronquante présents dans la liste ciliome ")

```

```{r tabgrp1, dependson="bigmmafgrp1", cache=TRUE}

kable(df_grp1_moderate %>% inner_join(df_canonical_transcripts, by = "Feature") %>% 
        arrange(SYMBOL) %>%
        select(Gene = SYMBOL, Patient = RUN, Consequence, SIFT, PolyPhen),
      booktabs = TRUE,
      longtable = TRUE,
      caption = "Liste des patients portant un variant non troquant homozygote sur un des gènes suivant : TODOOOOOO")

```

```{r, dependson="dfresumegrp1", cache=TRUE}

kable(df_resume_grp1 %>%
        select(Gene = SYMBOL, `High evidence` = High, `Moderate evidence` = Moderate, Total = TOT),
      booktabs = TRUE,
      longtable = TRUE,
      caption = "Résumé des gènes identifiés dans cette analyse")


```

\newpage

```{r removegrp1, cache=TRUE}

run_found <- c(run_found, run_cil_high, run_grp1)

df_bigmmaf_filter3 <- df_bigmmaf_filter2 %>% 
  filter(!(RUN %in% run_found))
   
df_bigmmaf_filter_het3 <- df_bigmmaf_filter_het2 %>% 
  filter(!(RUN %in% run_found))


```

```{r dfgrp2high, dependson="removegrp1", cache=TRUE}


df_grp2_high <- df_bigmmaf_filter3 %>% 
  filter(IMPACT == "HIGH") %>%
  group_by(SYMBOL, Feature) %>%
  mutate(N_RUN = n_distinct(RUN)) %>% 
  filter(N_RUN > 1) %>% 
  filter(SYMBOL != "hsa-mir-150") %>% 
  ungroup()


df_distinct_gene_grp2_high <- df_grp2_high %>%
  distinct(SYMBOL, N_RUN)



```

```{r vargrp2high, dependson="dfgrp2high", cache=TRUE}

gene_grp2 <- df_grp2_high %>% ungroup() %>% distinct(SYMBOL) %>% collect() %>% .[["SYMBOL"]]
n_gene_grp2 <- gene_grp2 %>% length


run_grp2 <- df_grp2_high %>% ungroup() %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
n_run_grp2 <- run_grp2 %>% length

n_run_max_grp2 <- df_distinct_gene_grp2_high %>% collect() %>% .[["N_RUN"]] %>% max

n_run_cfap43 <- df_grp2_high %>% filter(SYMBOL == "CFAP43") %>% nrow
n_run_fsip2 <- df_grp2_high %>% filter(SYMBOL == "FSIP2") %>% nrow
n_run_ccdc129 <- df_grp2_high %>% filter(SYMBOL == "CCDC129") %>% nrow

```

```{r dfgrp2reduce, dependson="dfgrp2high", cache=TRUE}

gene_grp2_reduce <- c("CFAP43", "CCDC129","FSIP2")

df_grp2_high_reduce <- df_grp2_high %>%
  filter(SYMBOL %in% gene_grp2_reduce)

```

```{r vargrp2reduce, cache=TRUE, dependson="dfgrp2reduce"}

run_grp2_reduce <- df_grp2_high_reduce %>% ungroup %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
n_run_grp2_reduce <- run_grp2_reduce %>% length 
n_gene_grp2_reduce <- gene_grp2_reduce %>% length

```

```{r dfgrp2moderate, dependson="dfgrp2high",cache=TRUE}

df_grp2_moderate <- df_bigmmaf_filter3 %>% 
  filter(IMPACT != "HIGH",
         SYMBOL %in% gene_grp2_reduce) %>%
  group_by(SYMBOL) %>%
  mutate(N_RUN = n_distinct(RUN))

```

```{r vargrp2moderate, dependson="dfgrp2moderate", cache=TRUE}

n_run_grp2_moderate <- df_grp2_moderate %>% ungroup() %>% distinct(RUN) %>% nrow

```

```{r dfgrp2low, cache=TRUE}

df_grp2_low <- df_bigmmaf_filter_het3 %>% 
  filter(SYMBOL %in% gene_grp2_reduce,
    N_VAR_PER_RUN_PER_GENE > 1) %>% 
         group_by(SYMBOL, Feature) %>% 
  mutate(N_RUN = n_distinct(RUN)) %>% 
  ungroup()

```

```{r vargrp2low, dependson="dfgrp2low", cache=TRUE}

n_run_grp2_low <- df_grp2_low %>% ungroup() %>% distinct(RUN) %>% nrow


```


```{r dfresumegrp2, dependson=c("dfgrp2highreduce","dfgrp2moderate","dfgrp2low"), cache=TRUE}

df_resume_grp2 <- bind_rows(df_grp2_high_reduce %>% group_by(RUN, SYMBOL) %>% summarise(TRUST = "High"),
                                    df_grp2_moderate %>% group_by(RUN, SYMBOL) %>% summarise(TRUST = "Moderate"),
                                    df_grp2_low %>% group_by(RUN, SYMBOL) %>% summarise(TRUST = "Low")) %>% 
  group_by(TRUST, SYMBOL) %>%
  summarise(N_RUN = n_distinct(RUN)) %>% 
  select(SYMBOL, N_RUN, TRUST) %>%
  group_by(SYMBOL) %>% 
  mutate(TOT = sum(N_RUN)) %>% 
  spread(TRUST, N_RUN) %>%
  mutate(Moderate = na.replace(Moderate, 0),
         Low = na.replace(Low, 0))

```


```{r removegrp2}


run_found <- c(run_found, run_grp2_reduce)

df_bigmmaf_filter4 <- df_bigmmaf_filter3 %>% 
  filter(!(RUN %in% run_found))
   
df_bigmmaf_filter_het4 <- df_bigmmaf_filter_het3 %>% 
  filter(!(RUN %in% run_found))

```

```{r varremovegrp2}

n_var_after_grp2 <- df_bigmmaf_filter4 %>% ungroup() %>% distinct(CHR, POSITION, REF, ALT) %>% nrow()
n_gene_after_grp2 <- df_bigmmaf_filter4 %>% ungroup() %>% distinct(SYMBOL) %>% nrow()
n_run_after_grp2 <- df_bigmmaf_filter4 %>% ungroup() %>% distinct(RUN) %>% nrow()


```


Suite à cela, nous avons procéder de la même manière avec les patients restant, cette fois-ci sans nous limiter au gènes présent dans la liste ciliome. Nous avons ainsi pu identifier `r n_gene_grp2` gènes sur lesquels au moins 2 de nos patients restant et jusqu'à `r n_run_max_grp2` portaient un variant homozygote ayant un effet tronquant sur la protéine. Cela nous a permis d'obtenir une liste de `r n_run_grp2` nouveaux patients avec un candidat potentiel (**Table :** \@ref(tab:tabgrp2), **Figure :** \@ref(fig:plotgrp2) - **A**).  

Parmis les gènes identifié, 3 se démarquent avec une forte expression testiculaire : *CFAP43*, *FSIP2* et *CCDC129* respectivement retrouvés mutés chez `r  n_run_cfap43`, `r n_run_fsip2`, et `r n_run_ccdc129` des `r n_run_grp2` patients séléctionnés. C'est pourquoi nous avons focalisé nos analyses sur ceux-ci. (**Table : **\@ref(tab:tabgrp2high), **Figure :** \@ref(fig:plotgrp2) - **B**).   

L'analyse bibliographique du gène *FSIP2* révèle qu'une équipe a démontré en 2003 l'implication de ce gène dans la structure de la gaine fibreuse su flagelle spermatique confirmant que ce gène est un bon candidat pour expliquer le phénotype MMAF des `r n_run_fsip2` patients portant un variant homozygote sur celui-ci [@Brown2003]. 

Ensuite, comme précédemment, nous avons rechercher les patients portant des variants non tronquant sur ces 3 gènes ainsi que ceux portant au moins deux variants hétérozygotes tronquant ou non. Cela nous a ainsi permis d'identifier `r n_run_grp2_moderate + n_run_grp2_low` nouveaux patients. Il faut cependant noter que parmis ceux-ci, certains portent de variant pour lesquels il est difficile d'affirmer avec certitude qu'ils sont responsable du phénotype. Le patients Ghs25 par exemple porte un variant homozygote chevauchant le gènes *CFAP43*. Cependant, le variant est un variant intronique situé dans la région d'épissage (et non sur un site donneur ou accepteur). Bien que ce type de variants puissent effectivement avoir un impact sur l'epissage, il pourrait egallement être sans effet, or, il est difficile de le prédire à ce stade. De même pour le patient Ghs131, dont le variant faux-sens chevauchant le gène *FSIP2* qu'il porte est prédit comme *benign* par PolyPhen alors que SIFT ne fournit aucune prédiction pour celui-ci. Pour les patients Ghs40, Ghs92 et Ghs101, au delà du fait qu'il nous est impossible de savoir à ce stade si les deux variants hétérozygotes qu'ils portent impacte le même allèle ou bien deux allèles différents, tous portent des variant faux-sens sur le gène *FSIP2* là encore prédit pour la plupart comme sans effet par SIFT et / ou PolyPhen. Le patient Ghs132 en revanche semble plus intéréssant, en effet celui-ci porte deux variant hétérozygotes sur le gène *CFAP43* parmis lesquels un est un indel entrainant un décalege du cadre de lecture tandis que l'autre est un faux-sens prédit comme *possibly damaging* par Polyphen, bien qu'il soit annoté *tolerated* par SIFT (**Tables : **\@ref(tab:tabgrp2moderate) et \@ref(tab:tabgrp2low)).

En séléctionnant les gènes sur lesquels au moins deux patients portaient au moins un variant tronquant homozygote nous avons identifié `r n_gene_grp2` gènes différents. En nous limitant à ceux ayant une forte expreesion testiculaire nous avons conservé de cette liste seulement `r n_gene_grp2_reduce` d'entre eux retrouvés mutés chez `r n_run_grp2_reduce` de nos patients. En élargissant ensuite nos recherches aux patients portant des variants homozygotes non tronquant et au moins deux hétérozygote tronquant ou non sur au moins un de ces `r n_gene_grp2_reduce` gène, nous avons pu identifier `r n_run_grp2_moderate + n_run_grp2_low` nouveaux patients. Cependant, au vus de l'insertitude du lien  entre les variants de ces `r n_run_grp2_moderate + n_run_grp2_low` derniers patients et leur phénotype, des analyses complémentaires sont nécéssaires (**Table : **\@ref(tab:tabresumegrp2)).

La cause génétique du phénotype MMAF ayant cependant été déterminée pour `r n_run_grp2_reduce` des patiens grâce à ce `r n_gene_grp2_reduce` gènes, leurs données aussi furent retirée des analyses ulterieure réduisant ainsi notre liste à `r n_var_after_grp2` variants différents chevauchant `r n_gene_after_grp2` gènes chez `r n_run_after_grp2` patients. Les données des `r n_run_grp2_moderate + n_run_grp2_low` patients pour lesquels la cause est incertaine furent conservés afin de voir si un meilleur candidat pouvait ressortir par la suite.


\newpage  


```{r plotgrp2, fig.cap=fig_info,fig.scap=fig_name, fig.height=7.5, dependson="dfgrp2", cache=TRUE}

fig_name <- 'TODOOOOOOOOOOOOOOOOOO'
fig_description_general <- "Dans ces deux graphiques, chaque couleur représente un gène"
fig_description_A <- "**A** : Quantification du nombre d'individus présentant un variant homozygote ayant un effet tronquant pour chacun des gènes retrouvés présent dans la liste des gènes du ciliome et retouvés avec un variant tronquant homozygote chez au moins deux patients"
fig_description_B <- "**B** : Expression tissulaire des gènes précédents d'après les données du projet de transcriptome Illumina bodyMap"
fig_description <- paste(fig_description_general, fig_description_A, fig_description_B, sep = ". ")

fig_info <- paste0(fig_name, " : ", fig_description)

pA <- ggplot(df_distinct_gene_grp2_high, aes(reorder(SYMBOL, -N_RUN), N_RUN)) + 
  geom_col(aes(fill = SYMBOL)) + 
  theme(axis.title.x = element_blank()) +
  scale_fill_brewer(palette = "Set1", guide = "none") + 
  ylab("Nb of individuals")

pB <- plot_expression(gene_grp2,"percent",TRUE) + 
  xlab("") +
  theme(legend.position = c(1,0),
        legend.justification = c(1,0))

plot_grid(pA,pB, rel_heights = c(.4,.6), labels = c("A","B"), ncol = 1)
```

\newpage  

```{r tabgrp2high, dependson="dfgrp2", cache=TRUE}

kable(df_grp2_high %>% 
        arrange(SYMBOL) %>%
        select(Gene = SYMBOL, Patient = RUN, Consequence),
      booktabs = TRUE,
      longtable = TRUE,
      caption = "List des gènes sur lesquels au moins deux patients portent une mutation tronquante non présents dans la liste ciliome ")

```

```{r tabgrp2moderate, dependson="dfgrp2moderate", cache=TRUE}

kable(df_grp2_moderate %>% 
        inner_join(df_canonical_transcripts, by = "Feature") %>%
        select(Gene = SYMBOL, Patient = RUN, Consequence, SIFT, PolyPhen) %>%
        mutate(SIFT = na.replace(SIFT, "No prediction"),
               PolyPhen = na.replace(PolyPhen, "No prediction")),
      booktabs = TRUE,
      longtable = TRUE,
      caption = "Liste des patients portant un variant non troquant homozygote sur un des gènes suivant : TODOOOOOO")


```

\newpage

```{r tabgrp2low, dependson="dfgrp2low", cache=TRUE}

kable(df_grp2_low %>% 
        inner_join(df_canonical_transcripts, by = "Feature") %>%
        select(Gene = SYMBOL, Patient = RUN, Consequence, SIFT, PolyPhen) %>%
        mutate(SIFT = na.replace(SIFT, "No prediction"),
               PolyPhen = na.replace(PolyPhen, "No prediction")),
      booktabs = TRUE,
      longtable = TRUE,
      caption = "Liste des patients portantau moins deux variants hétérozygotes sur un des gènes suivant : TODOOOOOO")


```

```{r tabresumegrp2, dependson="dfresumegrp2", cache=TRUE}

kable(df_resume_grp2 %>%
        select(Gene = SYMBOL, `High evidence` = High, `Moderate evidence` = Moderate,`Low Evidence` = Low, Total = TOT),
      booktabs = TRUE,
      longtable = TRUE,
      caption = "Résumé des gènes identifiés dans cette analyse")


```

\newpage



```{r dfgrp3high, cache=TRUE}


df_grp3_high <- df_bigmmaf_filter4 %>% 
  group_by(SYMBOL, Feature) %>%
  mutate(N_RUN = n_distinct(RUN)) %>% 
  filter(N_RUN == 1) %>% 
  filter(IMPACT == "HIGH",
         !is.na(EVIDENCE)) %>% 
  ungroup()

```

```{r vargrp3high}

gene_grp3 <- df_grp3_high %>% distinct(SYMBOL) %>% collect() %>% .[["SYMBOL"]]
n_gene_grp3 <- gene_grp3 %>% length

run_grp3_high <- df_grp3_high %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
n_run_grp3_high <- run_grp3_high %>% length

```

```{r dfgrp3reduce, dependson="dfgrp3high", cache=TRUE}

gene_grp3_reduce <- c("CCDC65", "C6orf118")

df_grp3_high_reduce <- df_grp3_high %>%
  filter(SYMBOL %in% gene_grp3_reduce)

```

```{r vargrp3reduce}

n_gene_grp3_reduce <- gene_grp3_reduce %>% length
run_grp3_reduce <- df_grp3_high_reduce %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
n_run_grp3_reduce <- run_grp3_reduce %>% length


```

```{r dfgrp3moderate, cache=TRUE}


df_grp3_moderate <- df_bigmmaf_filter4 %>% 
  filter(IMPACT != "HIGH",
    SYMBOL %in% gene_grp3_reduce) %>% 
  ungroup()

```

```{r vargrp3moderate}

n_run_grp3_moderate <- df_grp3_moderate %>% distinct(RUN) %>% nrow


```


```{r dfgrp3low, cache=TRUE}


df_grp3_low <- df_bigmmaf_filter_het4 %>% 
  filter(N_VAR_PER_RUN_PER_GENE > 1,
         SYMBOL %in% gene_grp3_reduce) %>% 
  ungroup()

```

```{r vargrp3low, cache=TRUE}

n_run_grp3_low <- df_grp3_low %>% distinct(RUN) %>% nrow
gene_grp3_low <- df_grp3_low %>% distinct(SYMBOL) %>% collect() %>% .[["SYMBOL"]] 



```

```{r dfresumegrp3, dependson=c("dfgrp3highreduce","dfgrp3moderate","dfgrp3low"), cache=TRUE}

df_resume_grp3 <- bind_rows(df_grp3_high_reduce %>% group_by(RUN, SYMBOL) %>% summarise(TRUST = "High"),
                            df_grp3_moderate %>% group_by(RUN, SYMBOL) %>% summarise(TRUST = "Moderate"),
                            df_grp3_low %>% group_by(RUN, SYMBOL) %>% summarise(TRUST = "Low")) %>% 
  group_by(TRUST, SYMBOL) %>%
  summarise(N_RUN = n_distinct(RUN)) %>% 
  select(SYMBOL, N_RUN, TRUST) %>%
  group_by(SYMBOL) %>% 
  mutate(TOT = sum(N_RUN)) %>% 
  spread(TRUST, N_RUN) %>%
  mutate(Low = na.replace(Low, 0))

```

```{r removegrp3}

run_found <- c(run_found, run_grp3_reduce)

df_bigmmaf_filter5 <- df_bigmmaf_filter4 %>% 
  filter(!(RUN %in% run_found))
   
df_bigmmaf_filter_het5 <- df_bigmmaf_filter_het4 %>% 
  filter(!(RUN %in% run_found))

```

```{r varremovegrp3}

n_var_after_grp3 <- df_bigmmaf_filter5 %>% ungroup() %>% distinct(CHR, POSITION, REF, ALT) %>% nrow()
n_gene_after_grp3 <- df_bigmmaf_filter5 %>% ungroup() %>% distinct(SYMBOL) %>% nrow()
n_run_after_grp3 <- df_bigmmaf_filter5 %>% ungroup() %>% distinct(RUN) %>% nrow()


```

En procédent de la même manière que les fois précédente, nous avons cette fois isolé les gènes présent dans la base de données ciliome sur lesquels *un seul* patient portait une mutation homozygote tronquante. Nous avons ainsi identifié `r n_run_grp3_high` patients tous porteurs d'un variant homozygote tronquant sur un des `r n_gene_grp3` gène suivant : `r gene_grp3`.  Cependant, l'analyse de l'expression testiculaire de ces gènes nous a insiter à n'en garder que `r gene_grp3_reduce` d'entre eux : `r gene_grp3_reduce` (**Table :** \@ref(tab:tabgrp3high), **Figure :** \@ref(fig:plotgrp3)).

En effet, *CCDC65* présente une forte et quasi exclusive expression testiculaire de plus, la protéine NYD-SP28 (ancien nom de CCDC65) avait déjà caractérisé comme faisant partie du flagelle spermatique [@Zheng2006]. En revanche *C6orf118* présente une forte expression à la fois dans le testicule mais égallement dans le poumoun de plus, ce gène a récemment été décrit comme étant associé au phénotype de tuberculose pulmonaire [@Hong2017]. Cependant cela n'est en rien contradictoire avec le phénotype MMAF du patient, le poumon comprenant de nombreuse cellules ciliées, notamment au niveau de l'épithélium respiratoire, il n'est donc pas surprenant que des gènes du flagelle aient égallement une fonction au sein d'autres organes ciliés.

Nous avons ensuite cherché si des patients présentaient des variants homozygotes non tronquants sur au moins 1 de ces `r n_gene_grp3_reduce` gènes cependant aucun ne remplissait ces critères. En revanche, `r n_run_grp3_low` de nos patients portait deux variants sur le gene *C6orf118* à l'état hétérozygote. Ces deux variants étant des faux-sens, le premier étant prédit *probably damaging* par PolyPhen et *tolerated low confidence
* par SIFT tandis que le second est prédit *possibly damaging* et *tolerated*, il est dificile de se prononcer quant à l'effet délétère de ces deux variants (**Table :** \@ref(tab:tabgrp3low)). 

Analyser les gènes de la liste ciliome sur lesquels *un seul* patient portait un variant tronquant à l'état homozygote nous a permis d'identifié `r n_gene_grp3` parmis lesquels `r n_gene_grp3_reduce` présentaient une forte expression testiculaire. L'analyse de ces `r n_gene_grp3_reduce` derniers gènes nous a permis d'identifier `r n_run_grp3_reduce` patients chacun portant un variant tronquant homozygote sur l'un de ces `r n_gene_grp3_reduce` gènes. Étendre notre recherche à la fois aux variants tronquant ainsi qu'aux hétérozygote composites nous a permis d'identifier `r n_run_grp3_moderate + n_run_grp3_low` patient pour qui deux faux-sens hétérozygotes sur le gène *C6orf118* pourraient expliquer le phénotype. Cependent, compte tenu de l'insertitude de ....., les données de ce patient ont été gardées dans les analyses ulterieures contrairement à celles des `r n_gene_grp3_reduce` patients ayant des variants homozygotes tronquant.  

\newpage  


```{r plotgrp3, fig.cap=fig_info,fig.scap=fig_name, fig.height=7.5, dependson="dfgrp2", cache=TRUE}

fig_name <- 'Epression tissulaire des gènes : TODO'
fig_description <- "D'après les données du projet de transcriptome Illumina bodyMap"

fig_info <- paste0(fig_name, " : ", fig_description)
plot_expression(gene_grp3,"percent",TRUE) +
  xlab("") +
  theme(legend.position = c(1,0),
        legend.justification = c(1,0))



```

\newpage

```{r tabgrp3high, dependson="dfgrp3", cache=TRUE}

kable(df_grp3_high %>% 
        arrange(SYMBOL) %>%
        inner_join(df_canonical_transcripts, by = "Feature") %>%
        select(Gene = SYMBOL, Patient = RUN, Consequence),
      booktabs = TRUE,
      longtable = TRUE,
      caption = "List des gènes sur lesquels au moins deux patients portent une mutation tronquante non présents dans la liste ciliome ")

```

```{r tabgrp3low, dependson="dfgrp3low", cache=TRUE}

kable(df_grp3_low %>% 
        inner_join(df_canonical_transcripts, by = "Feature") %>%
        select(Gene = SYMBOL, Patient = RUN, Consequence, SIFT, PolyPhen) %>%
        mutate(SIFT = na.replace(SIFT, "No prediction"),
               PolyPhen = na.replace(PolyPhen, "No prediction")),
      booktabs = TRUE,
      longtable = TRUE,
      caption = "Liste des patients portantau moins deux variants hétérozygotes sur un des gènes suivant : TODOOOOOO")


```

```{r tabresumegrp3, dependson="dfresumegrp3", cache=TRUE}

kable(df_resume_grp3 %>%
        select(Gene = SYMBOL, `High evidence` = High, `Low Evidence` = Low, Total = TOT),
      booktabs = TRUE,
      longtable = TRUE,
      caption = "Résumé des gènes identifiés dans cette analyse")


```

\newpage

```{r dfgrp4high, cache=TRUE}


df_grp4_high <- df_bigmmaf_filter5 %>% 
    group_by(SYMBOL, Feature) %>%
  mutate(N_RUN = n_distinct(RUN)) %>% 
  filter(N_RUN == 1,
    IMPACT == "HIGH",
         is.na(EVIDENCE)) %>% 
  ungroup()

```

```{r vargrp4high}

gene_grp4 <- df_grp4_high %>% distinct(SYMBOL) %>% collect() %>% .[["SYMBOL"]]
n_gene_grp4 <- gene_grp4 %>% length

run_grp4_high <- df_grp4_high %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
n_run_grp4_high <- run_grp4_high %>% length

```

```{r dfgrp4reduce, dependson="dfgrp3high", cache=TRUE}
# 
# gene_grp_reduce <- c("CCDC65", "C6orf118")
# 
# df_grp3_high_reduce <- df_grp3_high %>%
#   filter(SYMBOL %in% gene_grp3_reduce)

```

```{r vargrp4reduce}
# 
# n_gene_grp3_reduce <- gene_grp3_reduce %>% length
# run_grp3_reduce <- df_grp3_high_reduce %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
# n_run_grp3_reduce <- run_grp3_reduce %>% length
# 

```

\newpage

```{r plotfilterbigmmaf2, warning=FALSE, fig.height=7, fig.cap=fig_info,fig.scap=fig_name, cache=TRUE}

fig_name <- 'TODOOOOOOOOOOOOOOOOOO'
fig_description_general <- "Chaque couleur définit une classe de la liste des gènes du cilliome décrit dans [@Ivliev2012]. Vert = *Strong evidence from previous studies* (*Strong*), Orange = *Weak evidence from previous studies* (*Weak*), rouge = *No evidence from previous studies* (*Novel*), bleu = Non présent dans la liste"
fig_description_A <- "**A** : Quantification du nombre de gène ayant passé les filtres au sein des 3 classes de la liste des gènes du cilliome"
fig_description_B <- "**B** : TODOOOOOO : Besoin d'aide pour le nom de l'axe des Y !!!!!"

fig_description <- paste(fig_description_general, fig_description_A, fig_description_B, sep = ". ")


fig_info <- paste0(fig_name, " : ", fig_description)

# color from Set1 palette : 
# #4DAF4A = Green
# #FF7F00 = Orange
# #E41A1C = Red
# #377EB8 = Blue

fill_A <- c("#4DAF4A", "#FF7F00", "#E41A1C")
order_A <- c("Strong", "Weak", "Novel")

fill_B <- c("#4DAF4A", "#FF7F00", "#E41A1C", "#377EB8")
order_B <- c("Strong", "Weak", "Novel", "Not in the list")

pA <- ggplot(df_bigmmaf_genes_distinct2, aes(EVIDENCE)) +
  geom_bar(aes(fill = EVIDENCE)) +
  geom_text(stat='count',aes(label= ..count..), size = 5, vjust = -.25) + 
  scale_x_discrete(limits = order_A) + 
  ylab("Nb of gene") + 
  xlab("Evidence") + 
  scale_fill_manual(guide = "none", limits = order_A, values = fill_A, breaks = order_A)  +
  theme(axis.title.x = element_blank())

pB <- ggplot(df_bigmmaf_genes_resume2, aes(N_RUN, N_GENE)) + 
  geom_col(aes(fill = factor(EVIDENCE, levels = (order_B)))) +
  scale_x_reverse(breaks = c(2:15)) + 
  ylab("Nb of gene") + 
  coord_flip() + 
  scale_fill_manual(name = "Evidence", limits = order_B, values = fill_B, breaks = order_B) + 
  theme(legend.position = "bottom")

# plot_grid(pA, pB, labels = c("A","B"), ncol = 1)

```

\newpage

Cette approche nous a permis de rapidement identifier ... nouveaux acteurs potentiels pour le phénotype MMAF impliquant ... de nos patients qui portaient tous au moins une mutation homozygote sur l'un de ces gènes. Comme précédemment nous avons ensuite cherché des éventuels hétérozygotes composites nous permettant ainsi mettant ainsi en évidence ... patients portant au moins deux variants hétérozygotes différents sur un de ces gènes. 

1. **_WDR52_** : Ce gène (récemment renommé *CFAP44*) a été le premier à être identifié. En effet, malgrès une expression ubiquitaire (**Figure : **\@ref(figb:plotexpcandidat)),  ce gène fait partie des gènes prédit avec des preuves fortes comme étant impliqué dans le cilliome humain. De plus, `r n_run_homo_wdr52` de nos patients portaient des variants homozygotes sur ce gène, tous ayant un effet tronquant sur la protéine. La recherche d'hétérozygotes composites sur ce gène s'est cependant révélées négatives puisqu'aucun de nos patients ne correspondaient aux critères (**Table : **\@ref(tab:tabwdr52)).  

```{r tabwdr52, dependson="newcandidats"}

# kable(tabwdr52,
#       booktabs = TRUE,
#       longtable = TRUE,
#       col.names = c("Run ID","Variant coordinates", "Genotype", "Consequence", "Gene symbol"),
#       caption = "liste des variants passant les filtres et chevauchant le gène *WDR52*")

```

2. **_EFCAB6_**, **_TTC29_**, **_CCDC146_** :  Ces trois gènes ont ensuite été identifié simultanément puisque pour tous trois deux patients sont retrouvés avec un variant homozygote. Pour *TTC29* les deux patients portent la même variation impactant un site donneur d'épissage pouvant donc altérer l'épissage du transcrit induisant à la production d'une protéine aberrante. Les deux patients *CCDC146* portent chacun un variant induisant respectivement un codon stop prématuré et un décalage du cadre de lecture. Ces deux entrainant la production d'une protéine tronquée. Et enfin, deux variants faux-sens différents sont portés par les patients *EFCAB6*. De plus ces trois gènes sont présents dans notre liste des gènes du cilliome avec de fortes preuves et les bases de données publiques indiquent que ces trois gènes ont une forte (et quasi exclusive) expression testiculaire. La recherche d'e potentiels hétérozygotes composites s'est en revanche avérées négatives pour les gènes *TTC29* et *CCDC146*. Cependant, un patient portait deux variants hétérozygotes sur *EFCAB6*, l'un induisant un décalage du cadre de lecture et l'autre un faux-sens (**Table : **\@ref(tab:tabefcab6ttc29ccdc146)).
\newpage

```{r tabefcab6ttc29ccdc146, dependson="newcandidats"}

# kable(bind_rows(tabefcab6, tabttc29, tabccdc146),
#       booktabs = TRUE,
#       longtable = TRUE,
#       col.names = c("Run ID","Variant coordinates", "Genotype", "Consequence", "Gene symbol"),
#       caption = "liste des variants passant les filtres et chevauchant les gène *EFCAB6*, *TTC26* et *CCDC146*")

```

3. **_LRRC43_** :  En poursuivant nos analyses, nous avons identifié le gène *LRRC43* sur lequel `r n_run_homo_lrrc43` portaient le même variant faux-sens à l'état homozygote. De plus, un autre patient portait ce même variant à l'état hétérozygote couplé à un second variant faux-sens hétérozygote lui aussi. Ce gène est également connu pour avoir une forte expression et exclusive testiculaire. De plus, ce gène est inclus dans notre liste de gène du cilliome bien qu'il soit classé dans la catégorie *No evidence from previous studies* (**Table : **\@ref(tab:tablrrc43)).

```{r tablrrc43, dependson="newcandidats"}

# kable(tablrrc43,
#       booktabs = TRUE,
#       longtable = TRUE,
#       col.names = c("Run ID","Variant coordinates", "Genotype", "Consequence", "Gene symbol"),
#       caption = "liste des variants passant les filtres et chevauchant le gène *LRRC43*")

```

4. **_ARMC2_** :  Comme *LRRC43*, *ARMC2* est classé dans la catégorie *No evidence from previous studies* des gènes du cilliome de notre liste. Cependant son expression testiculaire forte et exclusive font de lui un bon candidat pour expliquer le phénotype MMAF de `r n_run_homo_armc2` portant respectivement à l'état homozygote un variant faux-sens, un impactant le site d'épissage et l'autre entrainant un décalage du cadre de lecture (**Table : **\@ref(tab:tabarmc2)).

```{r tabarmc2, dependson="newcandidats"}

# kable(tabarmc2,
#       booktabs = TRUE,
#       longtable = TRUE,
#       col.names = c("Run ID","Variant coordinates", "Genotype", "Consequence", "Gene symbol"),
#       caption = "liste des variants passant les filtres et chevauchant le gène *ARMC2*")

```

5. **_ANKRD20A3_** : Ce gène sur lequel `r n_run_homo_ankrd20a3` de nos patients portent un variant homozygote (7 d'entre eux portent le même variant faux-sens) et `r n_run_het_ankrd20a3` au moins deux variants hétérozygotes ne fait pas parti de la liste des gènes du cilliome. Cependant sa forte et quasi exclusive expression testiculaire fait tout de même de ce gène un très bon candidat (**Table : **\@ref(tab:tabankrd20a3)).  

```{r tabankrd20a3, dependson="newcandidats"}

# kable(tabankrd20a3,
#       booktabs = TRUE,
#       longtable = TRUE,
#       col.names = c("Run ID","Variant coordinates", "Genotype", "Consequence", "Gene symbol"),
#       caption = "liste des variants passant les filtres et chevauchant le gène *ANKRD20A3*")

```

6. **_WDR96_** : Ce gène non plus ne fait pas parti de la liste de gène cilliome, cependant, comme  *ANKRD20A3* sa forte expression spécifique au testicule font de lui un bon candidat. Au sein de notre cohorte, `r n_run_homo_wdr96` patients ont été identifiés car ils portaient un variant homozygote sur ce gène. Parmi eux, `r n_run_homo_wdr96 - 1` portaient une mutation tronquante, le dernier portait un variant intronique proche de la zone d'épissage. En plus de ceux-ci, `r n_run_het_wdr96` portait deux variant hétérozygotes dont un causait un décalage du cadre de lecture l'autre entrainant un faux-sens (**Table : **\@ref(tab:tabwdr96)).  

\newpage


```{r tabwdr96, dependson="newcandidats"}

# kable(tabwdr96,
#       booktabs = TRUE,
#       longtable = TRUE,
#       col.names = c("Run ID","Variant coordinates", "Genotype", "Consequence", "Gene symbol"),
#       caption = "liste des variants passant les filtres et chevauchant le gène *WDR96*")

```

7. **_FSIP2_** : Bien que ce gène ne soit lui non plus pas inclus dans la liste des gène du cilliome, une équipe a démontré en 2003 l'implication de ce gène dans la structure de la gaine fibreuse su flagelle spermatique [@Brown2003] faisant également de ce gène un excellent candidat dans l'explication du phénotype MMAF de `r n_run_homo_fsip2` patients portant respectivement à l'état homozygote deux indels différents induisant un décalage du cadre de lecture et un variant faux-sens. De même, les doubles ou triples variants faux-sens retrouvés à l'état hétérozygotes chez `r n_run_het_fsip2` de nos patients pourraient aussi expliquer leur phénotype MMAF (**Table : **\@ref(tab:tabfsip2).

```{r tabfsip2, dependson="newcandidats"}

# kable(tabfsip2,
#       booktabs = TRUE,
#       longtable = TRUE,
#       col.names = c("Run ID","Variant coordinates", "Genotype", "Consequence", "Gene symbol"),
#       caption = "liste des variants passant les filtres et chevauchant le gène *FSIP2*")

```

\newpage

```{r resumebigmmaf}

resume_bigmmaf <- bind_rows(tablrrc43,tabarmc2) %>%
  bind_rows(tabankrd20a3) %>% 
  bind_rows(tabwdr52) %>% 
  bind_rows(tabwdr96) %>% 
  bind_rows(tabfsip2) %>% 
  bind_rows(tabccdc146) %>% 
  bind_rows(tabttc29) %>% 
  bind_rows(tabefcab6) %>% 
  bind_rows(tabarmc2) %>%
  right_join(df_runs_mmaf, by = "RUN") %>% 
  select(-(Project:PROJECT)) %>% 
  group_by(RUN) %>%
  mutate(N_CANDIDAT = n_distinct(SYMBOL),
         CALL = if_else(is.na(SYMBOL),"None",CALL),
         SYMBOL = if_else(is.na(SYMBOL), "No gene", SYMBOL)) %>% 
  group_by(SYMBOL) %>%
  mutate(N_RUN_PER_SYMBOL = n_distinct(RUN)) %>%
  ungroup()

n_run_bigmmaf_found <- resume_bigmmaf %>% filter(SYMBOL != "No gene") %>% distinct(RUN) %>% nrow

p_run_bigmmaf_found <- (n_run_bigmmaf_found / n_run_bigmmaf) %>% round(2) * 100

n_run_several_candidat <- resume_bigmmaf %>% filter(N_CANDIDAT > 1) %>% distinct(RUN) %>% nrow
n_run_2_candidat <- resume_bigmmaf %>% filter(N_CANDIDAT == 2) %>% distinct(RUN) %>% nrow
n_run_3_candidat <- resume_bigmmaf %>% filter(N_CANDIDAT == 3) %>% distinct(RUN) %>% nrow

candidat_gene <- resume_bigmmaf %>% 
  mutate(SYMBOL = if_else(SYMBOL == "WDR96","CFAP43",
                          if_else(SYMBOL == "WDR52", "CFAP44", SYMBOL))) %>%
  filter(!(SYMBOL %in% c("DNAH1", "No gene"))) %>% distinct(SYMBOL) %>% collect() %>% .[["SYMBOL"]] 

n_candidat_gene <- candidat_gene %>% length

```

```{r plotexpcandidat, fig.height=7.2, fig.cap=fig_info,fig.scap=fig_name}

fig_name <- "Expression tissulaire des gènes gènes candidats retenus"
fig_description <- "Données provenant du projet de transcriptome Illumina bodyMap"
fig_info <- paste0(fig_name, " : ", fig_description)

plot_expression(candidat_gene, "percent", TRUE) + 
  xlab("") +
  theme(legend.position = c(1,0),
        legend.justification = c(1,0))



```

\newpage

#### Discussion  

L'analyse de cette cohorte de `r n_run_bigmmaf` patients MMAF nous dans un premier temps permis de confirmer l'importance de l'implication du gène *DNAH1* dans ce phénotype grâce à ... patients présentant des variants sur ce gène dont ... à l'état homozygote. Elle nous a également permis d'identifier `r n_candidat_gene` nouveaux gène candidats pouvant expliquer le phénotype de `r n_run_bigmmaf_found` de nos patients soit `r p_run_bigmmaf_found` % de la cohorte. parmi ceux-ci, ... portaient au moins un variant homozygote sur un de ces gènes. Pour les autres des études sont nécessaires afin de déterminer si les différents variants hétérozygotes qu'ils portent sont situés sur leurs deux allèles différents faisant d'eux des hétérozygotes composites (**Figure : **\@ref(fig:plotresumebigmmaf) - **A**).

Parmi cet ensemble de patients, il faut noter que `r n_run_several_candidat` d'entre eux porte des variants pouvant expliquer leur phénotype sur plusieurs des gènes candidats que nous avons identifiés. En effet, `r n_run_2_candidat` de nos patients portent des variants sur deux de nos gènes candidats et `r n_run_3_candidat` sur 3 d'entre eux (**Figure : **\@ref(tab:tabresumebigmmaf) - **B**).

Cependant, parmi ces différents variants certains semblent plus probables pour expliquer le phénotype (**Table : **\@ref(tab:tabresumebigmmaf)) avec par exemple :  

1. Patient Ghs105 : Ce patient porte à la fois un variant homozygote affectant le site d'épissage du gène *WDR96* ainsi que deux variants hétérozygotes causant tous les deux un faux-sens sur le gène *EFCAB6*. Au vu du génotype homozygote et de l'effet tronquant du variant impactant *WDR96*, il parait plus probable que celui-ci soit responsable du phénotype MMAF au détriment des deux variants hétérozygotes chevauchant *EFCAB6*.  
2. Patient Ghs17 : Deux variants homozygotes ont été retenus pour ce patient. L'un causant un faux-sens sur le gène *EFCAB6* l'autre créant un codon stop prématuré sur *WDR96*. Ici aussi, au vu de l'impact délétère du variant chevauchant *WDR96*, il parait plus probable que ce soit celui-ci qui soit la cause du phénotype de ce patient.  
3. Patients Ghs32 et Ghs35 : Ces patients portent tous deux à la fois des variants sur le gène *ANKRD20A3* et sur le gène *CCDC146* cependant l'effet tronquant de leur variant impactant ce dernier nous laisse penser que ceux-ci soient la cause du phénotype MMAF de ces deux patients.   

En procédant de la même manière pour les autres patients il est, dans la grande majorité des cas, possible de dégager un gène pour lequel l'implication dans le phénotype des patients parait plus évidente bien que des analyses complémentaires soient nécessaires.  

Ainsi, cette analyse révèle l'efficacité de notre pipeline puisqu'elle a permis d'identifier au moins un gène candidat pour `r p_run_bigmmaf_found` % de nos patients. Pour les autres des analyses individuelles complémentaires sont nécessaires afin d'identifier la cause génétique responsable de leur phénotype.  

Une partie de ces différents résultats ont déjà été publiés dans deux articles dont je suis co-auteur : 

1. **Whole exome cohort study and analysis of mouse and Trypanosoma models demonstrate the importance of WDR proteins in flagellogenesis and male fertility**, *Nat Genet* (soumis) : Cette article présente nos différents résultats dans la caractérisation des gènes *WDR96* et *WDR52* ainsi que les différentes preuves de leur implication dans le phénotype MMAF.  

2. [**Whole-exome sequencing of familial cases of multiple morphological abnormalities of the sperm flagella (MMAF) reveals new DNAH1 mutations**](#famdnah1) : En plus des résultats évoqués précédemment pour la famille MMAF2, cet article inclus ceux de ... patients de cette cohorte présentant des variants sur le gène *DNAH1* 


Pour les autres, notre équipe travaille actuellement à la caractérisation des différents gènes afin de comprendre les processus moléculaires  

\newpage

```{r plotresumebigmmaf, fig.cap=fig_info,fig.scap=fig_name, fig.height=7, cache=TRUE}

fig_name <- "Conclusion des analyses WES de notre large cohorte MMAF, liste des gènes candidats"

fig_description_A <- "**A** : Quantification du nombre de patient portant un ou plusieurs variants sur un des gène candidat. La couleur des barres dépend du génotype des patients, la barre rouge indique les patients pour lesquels aucun candidat n'a été identifié"
fig_description_B <- "**B** : Nombre de candidat potentiel pour chaque patient (parmi ceux pour lesquels au moins un gène candidat a été identifié)"


fig_description <- paste(fig_description_A, fig_description_B, sep = ". ")
fig_info <- paste0(fig_name, " : ", fig_description)

# color from Set1 palette : 
# #4DAF4A = Green
# #FF7F00 = Orange
# #E41A1C = Red
# #377EB8 = Blue

pA <- ggplot(resume_bigmmaf %>% 
               distinct(SYMBOL, CALL, RUN, N_RUN_PER_SYMBOL) %>% 
               group_by(SYMBOL, CALL) %>%
               summarise(N = n_distinct(RUN),
                         N_RUN_PER_SYMBOL = mean(N_RUN_PER_SYMBOL)) , aes(reorder(SYMBOL, N_RUN_PER_SYMBOL), N)) + 
  geom_col(aes(fill = CALL)) + 
  scale_fill_manual(breaks = c("Homozygous", "Heterozygous", "None"), name = "Genotype", values = c("#FF7F00", "#4DAF4A", "#E41A1C")) + 
  ylab("Nb of individual") + 
  xlab("") +
  coord_flip() +
  theme(legend.position = "bottom")

pB <- ggplot(resume_bigmmaf %>% 
               filter(!is.na(CALL)) %>%
               group_by(N_CANDIDAT) %>% distinct(RUN) , aes(N_CANDIDAT)) + 
  geom_bar(fill = "#377EB8") +
  ylab("Nb of individual") + 
  xlab("Nb of potential candidat gene") 

plot_grid(pA, pB, labels = c("A","B"), rel_heights = c(.55,.45), ncol = 1)

```

\newpage

```{r tabresumebigmmaf, cache=TRUE}

# resume_bigmmaf %>% 
#                filter(!is.na(CALL)) %>% 
#   filter(N_CANDIDAT > 1) %>% 
#   select(RUN:SYMBOL) %>% 
#   arrange(RUN, SYMBOL, desc(CALL)) %>%
#   kable(booktabs = TRUE,
#         longtable = TRUE,
#         col.names = c("Run ID","Variant coordinates", "Genotype", "Consequence", "Gene symbol"),
#         caption = "Liste des patients pour lesquels plusieurs gènes candidats ont été identifiés")


```

\newpage 

## Conclusion  

Au cours de ces différentes études nous avons pu identifier les variants pouvant expliquer les phénotypes de ... des différents patients que nous avons analysé que ce soit au sein d'études familiales ou bien au sein de plus large cohorte composés d'individus non apparentés. Bien que ces résultats soient satisfaisant, il faut noter que pour ... patients, soit ... % d'entre eux aucun candidat n'a pu à ce jour être identifié. Pour ces patients, le WES permets désormais de nouvelles approches permettant d'identifier de larges variants structuraux (insertion ou délétions) pouvant eux aussi être responsable du phénotype qui ne sont pas détectés par les analyses classiques. Néanmoins, il semble clair que des avancés soient encore nécessaires afin d'améliorer l'efficacité de ce genre d'étude notamment en créant de nouveaux filtres permettant ainsi d'épurer les listes de variants facilitant ainsi l'identification des gènes candidats.  










\newpage  
