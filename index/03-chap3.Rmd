---
output:
  word_document: default
  html_document: default
  pdf_document: default
  classoption: landscape
---
# Mise en place d’une stratégie pour l’analyse des données exomiques – application en recherche clinique  

```{r include.packages2, include=FALSE}
# This chunk ensures that the thesisdown package is
# installed and loaded. This thesisdown package includes
# the template files for the thesis.

if(!require(devtools))
  install.packages("devtools", repos = "http://cran.rstudio.com")
if(!require(thesisdown))
  devtools::install_github("ismayc/thesisdown")

library(thesisdown)
library(knitr)
library(tidyr)
library(dplyr)
library(data.table)
library(ggplot2)
library(stringi)
library(scales)
library(cowplot)
library(stringr)

theme_set(theme_gray()) # otherwise use cowplot default theme

source("script/manage_variants.R")
source("script/variant_filtering.R")
source("script/resume_data.R")
source("script/plot_vep_results.R")

opts_knit$set(eval.after = c("fig.cap","fig.scap"))

knitr::opts_chunk$set(fig.align='center',echo=FALSE)

```

## Intro  

<!-- Comme vu précédemment, l'émergence du séquençage haut débit, avec notamment le WGS et le WES, a révolutionné les méthodes de recherche dans le cadre d'étude phénotype-génotype en permettant de manière rapide et à moindre coup le séquençage de la quasi totalité des gènes humains. Les causes de plusieurs centaines de pathologies ont pu être identifiées grâce à ces technique depuis leur premier succès pubilié en 2010 [@Ng].  Dès lors, l'analyse des données issues du séquençage est devenu la clef dans la réussite de ces études.  -->

<!-- Il existe de nombreux logiciels qui à partir des variants appelés effectuent les étapes d'annotation et de filtrage. C'est par exemple le cas d'Exomiser [TODO: insert ref and Exomiser describtion] ou encore de [TODO: insert at least one other soft]. La plupart de ces logiciels fonctionnent très bien, cependant tous prennent pour point de départ des variants appelés en amont. Ils ne contrôlent donc en aucune manière les étapes d'alignement et d'appel des variants. Or, comme il a été dit plus tôt, ces deux étapes constituent la bases de l'analyse [TODO insert ref] et les résultats -->

<!-- Ce chapitre décrit la constitution et l’utilisation d’un pipeline d’analyse des données de séquençage exomique et son utilisation dans le cadre de la recherche de mutations entrainant différents phénotypes d’infertilité. La difficulté des études génétiques visant à identifier des gènes pathogènes vient de l’abondance de variants rares chez tout un chacun et de la difficulté d’effectuer des tris efficaces et justes pour ne retenir que la ou les mutations causales. Thomas développe un pipeline se basant sur des outils existant mais permettant d’effectuer des tris successifs efficaces et pertinents   -->

\newpage

## Résultats  

```{r allruns}


df_runs <- fread("data/exome_runs.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, data.table = FALSE)

resume_pheno <- df_runs %>% 
  ungroup() %>%
  rename(Phenotype = Pathologie) %>%
  filter(Phenotype != "TVPC") %>%
  group_by(Phenotype) %>% 
  summarise(N_per_Patho = n()) %>% 
  spread(Phenotype, N_per_Patho) %>% 
  rename(Azoospermia = Azoo, 
         MMAF = Flag, 
         `Fertilization failure` = Fert_fail, 
         Globozoospermia = Globo, 
         Macrozoospermia = Macro,
         `Oocyte defect` = Ovo,
         Healthy = CTRL) %>% 
  gather(Phenotype,`Nb of individuals`, Azoospermia:`Oocyte defect`)


resume_tot <- resume_pheno %>% 
  ungroup() %>% 
  summarise(N_tot = sum(`Nb of individuals`),
            N_pheno = n_distinct(Phenotype) - 1)

n_tot_runs <- resume_tot %>% collect() %>% .[["N_tot"]]
n_pheno <- resume_tot %>% collect() %>% .[["N_pheno"]]

```


### Description de la pipeline  

Notre pipeline d'analyse effectue l'ensemble des étapes allant de l'alignement des données jusqu'au filtrage des variants  

1. **L'alignement** : L'alignement des *reads* le long du génome de référence est effectué par le logiciel MAGIC [@Su2014]. Celui-ci l'intégralité pour l'ensemble des analyses en aval l'ensemble des *reads* dupliqués et / ou s'alignant à plusieurs zones du génome. Au cours de cette étape, MAGIC va produire également quatre comptages pour chaque position couverte du génome : R+, V+, R- et V- :  
    a. **R+ et R-** : Ces deux comptages correspondent au nombre de *reads* *forward* (+) et *reverse* (-) sur lesquels est observé l'allèle de **référence** (R) à une position donnée.  
    b. **V+ et V-** : À l'inverse de R+ et R-, ces comptages correspondent au nombre de *reads* *forward* et *reverse* sur lesquels est observé un allèle de **variant** (V) à une position donnée.  
2. **L'appel des variants** : Comme nous l'avons vu plus [tôt](#varcall), il est fortement conseillé d'effectuer l'appel des variants en tenant compte de l'aligneur choisi [@Nielsen2011, @DePristo2011, @Lunter2011]. C'est pourquoi, nous avons conçu notre propre algorithme d'appel des variants spécialement conçu pour l'analyse des données de MAGIC. Ainsi, l'appel des variants sera directement basé sur les quatre comptages vus précédemment. Tout d'abord, les positions ayant une couverture < 10 sur l'un des deux *strands* sera considérée comme de faible qualité, celles ayant   une couverture < 10 sur les deux *strands* seront exclus. Ensuite pour chaque variant, des appels indépendants seront effectués pour chaque *strand*. L'appel final sera une synthèse de ces deux appels où seul les cas où ces deux appels sont concordants seront considérés comme de bonne qualité.    
3. **L'annotation** : Chaque variant retenu sera ensuite annoté tout d'abord par le logiciel *variant effect predictor* (VEP) [@McLaren2016] qui nous indiquera pour chaque variant la conséquence que celui-ci aura sur la séquence codante de l'ensemble des transcrits Ensembl qu'il chevauche (**Figure : **\@ref(fig:figvepcsq)) (**Table : **\@ref(tab:tabvepcsq)). Suite à cela nous ajoutons, lorsque celle-ci est disponible, la fréquence du variant dans les bases de données ExAC [@Lek2016], ESP600 [TODO] et 1000Genomes [TODO] donnant ainsi une estimation de sa fréquence dans la population générale. De même, la particularité de ce pipeline est qu'elle conserve l'ensemble des variants identifiés dans les études effectuées précédemment permettant d'ajouter aux annotations la fréquence d'un variant chez les individus déjà séquencé et donc la fréquence d'un variant dans chaque phénotype étudié créant ainsi une base de données interne qui pourra servir de contrôle dans les études ultérieur.    

```{r figvepcsq, fig.cap=fig_info,fig.scap=fig.name, out.extra="scale=.9"}


fig.name <- "Listes des différentes conséquences prédites par VEP et leur positionnement sur le transcrit"
fig_description <- ""
fig.from <- "[VEP site](http://www.ensembl.org/info/genome/variation/consequences.jpg)"
fig_info <- paste0(fig.name," d'après ",fig.from)

include_graphics(path = "figure/vep_csq.jpg")


```

4. **Le filtrage des variants** : L'étape de filtrage est extrêmement importante si l'on souhaite analyser de manière efficace les données provenant de WES. C'est pourquoi elle occupe une place importante dans notre pipeline. L'intégralité des paramètres de cette étape peuvent être modifier par l'utilisateur de sorte à faire correspondre les critères de filtre aux besoins de l'étude. Afin de rendre son utilisation le plus efficace possible, nous avons souhaité définir des paramètres par défauts pertinent dans la plupart des études de séquençage exomique de sorte que à moins que le contraire ne soit spécifié, seul les variants impactant les transcrits codant pour une protéine sont conservés. De même les variants synonymes ou affectant les séquences UTRs sont filtrés ainsi que les variants ayant une fréquence $\ge$ 1% dans les bases dans l'une des bases données (ExAC, ESP6500 ou 1KH). Aussi, pour un phénotype donné, l'ensemble des variants observés chez les individus étudiés présentant un phénotype différent sont de même enlevés de la liste finale.   

\newpage
\blandscape

```{r tabvepcsq}


df_vep_csq <-  fread("data/vep_csq_modif.csv", sep = "\t", header = TRUE, showProgress = FALSE, data.table = FALSE, verbose = FALSE) %>%
  select(`VEP consequence` = `Display term`,
         `VEP impact` = IMPACT,
         Description = `SO description`)

pander::pander(df_vep_csq,
               justify = 'left',
               split.cells = c(.5,1,50),
               caption = "(\\#tab:tabvepcsq) Liste simplifiée des conséquences prédites par VEP avec leur description et impact associée")


```

\elandscape

\newpage

### Utilisation du pipeline dans des cas familiaux :  

#### Description des familles 

```{r recapfam}

run_az_fam <- c("Ghs44","Ghs45")
run_ff_fam <- c("Ghs113","Ghs117")
run_mmaf_fam <- c("Ghs56","Ghs58","Ghs62","Ghs130","Ghs63","Ghs119","Ghs59","Ghs60","Ghs61")

run_all_fam <- c(run_az_fam, run_ff_fam, run_mmaf_fam)

df_seq <- data_frame(FAM = c("Az","FF","MMAF1","MMAF2","MMAF3","MMAF4"),
                     NB = c(2,2,2,2,2,3),
                     PHENOTYPE = c("Azoospermia","Fertilization failure","MMAF","MMAF","MMAF","MMAF"),
                     YEAR = c(2012,2014,2014,2014,2014,2014),
                     # PLATFORM = c("Illumina HiSeq2000","Illumina HiSeq2000","Illumina HiSeq2000","Illumina HiSeq2000","Illumina HiSeq2000","Illumina HiSeq2000"),
                     PLACE = c("Mount Sinai Institut","Genoscope (Evry)","Genoscope (Evry)","Genoscope (Evry)","Genoscope (Evry)","Genoscope (Evry)"))

nb_run <- run_all_fam %>% length
nb_fam <- df_seq %>% summarise(N_FAM = n_distinct(FAM)) %>% collect() %>% .[["N_FAM"]] 
nb_pheno <- df_seq %>% summarise(N_PHENO = n_distinct(PHENOTYPE)) %>% collect() %>% .[["N_PHENO"]] 

```

Dans cette partie, je me concentre sur l'analyse bioinformatique des résultats des séquençages exomiques effectués entre `r min(df_seq$YEAR)` et `r max(df_seq$YEAR)` de `r sum(df_seq$NB)` individus infertiles provenant de `r nb_fam` familles différentes. Parmi celles-ci, `r nb_pheno` phénotypes différents ont été observés : 

1. **[L'Azoospermie](#infquant) :** Comme nous avons pu le voir, l'azoospermie est un phénotype d'infertilité masculine caractérisé par l'absence de spermatozoïde dans l’éjaculât    
2. **Échec de fécondation :**  Ce phénotype d'infertilité se caractérise par l'incapacité des spermatozoïdes à féconder l'ovocyte.  
3. **MMAF** :  Le syndrome MMAF (*multiple morphological abnormalities of the sperm flagella*) caractérise comme son nom l'indique les patients présentant une majorité de spermatozoïdes atteins par une mosaïque d'anomalie morphologique du flagelle.  

Un récapitulatif des familles et de leur phénotype est disponible dans la table \@ref(tab:tabrecapfam).    

```{r tabrecapfam}

tab.name <- "Tableau récapitulatif des familles séquencées et de leur phénotype"

kable(df_seq,
      col.names = c("Familly","Individuals","Phenotype","Year","Place"),
      caption = tab.name,
      longtable = TRUE,
      booktabs = TRUE)

```

\newpage  
#### Resultats des exomes  

##### Résultat de l'alignement  

```{r runstrandness, warning=FALSE, cache=TRUE}

df_read_fate_nb <- fread("data/magic_results/All_Exomes.read_fate.txt", sep = "\t", data.table = FALSE, header = TRUE, drop = c(1,3:5,7:23)) %>% 
    select(-contains("entropy"), -contains("but"), -contains("insert")) %>% 
  rename(RUN = `# Run`,
         `Map to 1 site` = `% reads, mapping uniquely to 1 genomic site and maximum 1 gene`,
         S2 = `% reads, mapping to 2 to 9 sites`,
         S10 = `% Rejected because they map to 10 or more`) %>% 
  filter(RUN != "All runs") %>%
  mutate(`Map to 2 or more sites`  = S2 + S10) %>% 
  select(-S2, -S10) %>% 
  filter(RUN %in% run_all_fam) %>% 
  gather(QUALITY, NB_OF_READS, `Raw reads`:`Map to 2 or more sites`) 

pair_stat <- fread("data/magic_results/All_Exomes.pair_stats.txt", sep = "\t", data.table = FALSE, skip = 42, header = FALSE) %>% transpose()
names(pair_stat) <- pair_stat[1,] 

pair_stat <- pair_stat %>%
  filter(Run %in% run_all_fam) %>%
  select(RUN = Run, Compatible_pairs, Non_compatible_pairs, `Orphans Any`) %>% 
  rename(`Compatible` = Compatible_pairs,
         `Non compatible` = Non_compatible_pairs,
         Orphans = `Orphans Any`) %>%
  gather(QUALITY, NB_OF_READS, Compatible:Orphans) %>%
  mutate(NB_OF_READS = as.numeric(NB_OF_READS)) 

df_reads_summary <- rbind(df_read_fate_nb, pair_stat) %>% 
  mutate(IS_RETAINED = if_else((QUALITY == "Raw reads" |
                                   QUALITY == "% Well mapped" |
                                   QUALITY == "Compatible" |
                                   QUALITY == "Map to 1 site"), "Yes", "No" ),
         NB_OF_READS = if_else(QUALITY == "Raw reads", NB_OF_READS, NB_OF_READS / 100))

```

```{r}

raw_reads_median <- df_reads_summary %>% filter(QUALITY == "Raw reads") %>% collect() %>% .[["NB_OF_READS"]] %>% median %>% as.integer
unmap_reads_min <- df_reads_summary %>% filter(QUALITY == "% Unmapped") %>% collect() %>% .[["NB_OF_READS"]] %>% min %>% round(3) * 100
unmap_reads_max <- df_reads_summary %>% filter(QUALITY == "% Unmapped") %>% collect() %>% .[["NB_OF_READS"]] %>% max %>% round(3) * 100

max_site_1 <- df_reads_summary %>% filter(QUALITY == "Map to 1 site") %>% collect() %>% .[["NB_OF_READS"]] %>% max %>% round(3) * 100
min_site_1 <- df_reads_summary %>% filter(QUALITY == "Map to 1 site") %>% collect() %>% .[["NB_OF_READS"]] %>% min %>% round(3) * 100

```


Pour rappel, l'[alignement]({#lalignement}) consiste à repositionner l'ensemble des *reads* générés au cours de l'étape de séquençage le long d'un génome de référence. 

La quantité de *reads* composant les exomes de chaque individu peut varier en fonction de plusieurs paramètres et n'est donc pas égale pour chaque patient bien que l'ordre de grandeur reste le même exceptés, c'est à dire une médiane de `r raw_reads_median` *reads*. Seul les deux frères AZ1 et AZ2 se distinguent près de 3 fois plus de *reads* que pour les autres patients. Cette différence peut être expliqué car ces deux patients sont les deux seuls à voir été séquencé au Mount Sinaï Institut or leur protocole d'amplification précédent le séquençage contient un nombre de cycles de PCR supérieur à ceux appliqué au Génopole d'Évry où ont été séquencé les autres patients (**Table :**  \@ref(tab:tabrecapfam), **Figure : **\@ref(fig:readsselection) - **A**).  

L'ensemble de nos exomes ayant été réalisés en *paired-end*, les deux extrémités de chaque fragment sont séquencés chaque *end* d'un même *read* peut donc être considéré comme un *read* à part entière qui sont alignées **indépendamment** le long du génome de référence. L'information fournit par le *paired-end* n'étant utilisé qu'à *posteriori* en tant que critère qualité. La première étape du contrôle qualité des *reads* consiste filtrer les *reads* ne s'étant pas aligné sur le génome. Ces *reads* sont extrêmement minoritaires puisqu'ils représentent entre `r unmap_reads_min` et `r unmap_reads_max` % des *reads* de nos individus (**Figure : **\@ref(fig:readsselection) - **B**).  

Une fois cela fait, nous vérifions la "compatibilité" des deux *ends* composant chacun des *reads* s'étant correctement alignés. Un *reads* est dit compatible lorsque les deux *ends* qui le composent s'alignent face à face (une sur le *strand* + et l'autre sur le *strand* -) et couvrent une zone ne faisant pas plus de 3 fois la taille médiane de l'insert. Les *reads* dont les deux *ends* se sont alignées mais ne remplissant pas ces conditions seront dit "Non compatible", ceux dont une seule des deux *ends* s'est alignés seront appelés "orphelins". Dans nos analyses, seuls les *reads* compatibles sont conservés, c'est à dire environs ... % (médiane) des *reads* s'étant correctement alignés.  (**Figure : **\@ref(fig:readsselection) - **C**).  

La dernière étape de ce contrôle-qualité consiste à analyser le nombre de site auxquels se sont alignés les *reads*. En effet, certaine zone du génome étant dupliqué, l'une des problématiques des *short-reads* est qu'il est possible que ceux-ci s'alignent à plusieurs régions différentes du génome. Afin d'éviter toute ambiguïté, seul ceux s'étant aligné sur un site unique sont conservés pour la suite des analyses. Ces *reads* représente entre `r min_site_1` et `r max_site_1` % des *reads* ayant passé les précédents filtres (**Figure : **\@ref(fig:readsselection) - **C**).  

Les *reads* ayant passé l'ensemble des critères qualité mentionnés précédemment seront ensuite utilisés pour effectuer l'appel des variants.     

\newpage

```{r readsselection, fig.cap=fig_info,fig.scap=fig_name,fig.width=6.3, fig.height=6.9, cache=TRUE}

fig_name <- "Processus simplifié du contrôle qualité des *reads*"
fig_description_all <- "Pour chacun des graphiques, les *reads* représentés en vert sont conservés tandis que ceux en rouge sont filtrés"
fig_description_A <- "**A** : Quantité de *reads* bruts générés pour chaque patient au cours de l'étape de séquençage. La médiane des *reads* est représentée en bleue"
fig_description_B <- "**B** : Pourcentage pour chaque individu de *reads* s'étant aligné correctement et ne s'étant pas alignés sur le génome de référence"
fig_description_C <- "**C** : Distribution pour chaque patient des *reads* compatibles (Comp), non compatibles (Non comp) et orphelins (Orphans)"
fig_description_D <- "**D** : Présentation pour chaque *reads* du nombre de site auxquels ils s'alignent"
fig_description <- paste(fig_description_all, fig_description_A,fig_description_B,fig_description_C, fig_description_D, sep = ". ")

fig_info <- paste0(fig_name, " : ", fig_description)

pA <- ggplot(df_reads_summary %>% filter(QUALITY == "Raw reads"), aes(RUN, NB_OF_READS)) + 
  geom_bar(stat = "identity", aes(fill = IS_RETAINED)) + 
  xlab("") + 
  ylab("Nb of raw reads") + 
  # scale_x_discrete(labels = c("AZ1","AZ2","FF1","FF2","MMAF1.1","MMAF1.2","MMAF2.1","MMAF2.2","MMAF3.1","MMAF3.2","MMAF3.3")) + 
  scale_fill_manual(values = c("chartreuse3", "firebrick3"), guide = "none") +
  geom_hline(col = "blue", aes(yintercept = raw_reads_median)) + 
  geom_text(data=data.frame(x=0,y=median(df_reads_summary$NB_OF_READS)), col = "blue", x = 12.5, y = 110000000, label = raw_reads_median)
  

pB <- ggplot(df_reads_summary %>% 
               filter(QUALITY == "% Well mapped" | 
                        QUALITY == "% Unmapped"), aes(QUALITY, NB_OF_READS)) + 
  geom_boxplot(outlier.size = -1, aes(fill = IS_RETAINED)) + 
  geom_jitter(position=position_jitter(0.3)) +
  facet_wrap(~factor(QUALITY, levels = c("% Well mapped", "% Unmapped")), scales = "free", nrow = 1) + 
  ylab("% of reads") +
  scale_y_continuous(labels = percent) + 
  xlab("") + 
  scale_fill_manual(values = c("firebrick3", "chartreuse3"), guide = "none") + 
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

pC <- ggplot(df_reads_summary %>% 
         filter(QUALITY == "Compatible" | 
                  QUALITY == "Non compatible" |
                  QUALITY == "Orphans") %>%
           mutate(QUALITY = if_else(QUALITY == "Compatible", "Comp",
                                    if_else(QUALITY == "Non compatible", "Non comp", QUALITY))), aes(QUALITY, NB_OF_READS)) + 
         geom_boxplot(outlier.size = -1, aes(fill = IS_RETAINED)) + 
         geom_jitter(position=position_jitter(0.3)) +
  facet_wrap(~QUALITY, scales = "free", nrow = 1) + 
  ylab("% of reads") +
  scale_y_continuous(labels = percent) + 
  xlab("") + 
  scale_fill_manual(values = c("firebrick3", "chartreuse3"), guide = "none") + 
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y = element_blank())

pD <- ggplot(df_reads_summary %>% 
               filter(QUALITY == "Map to 1 site" | 
                        QUALITY == "Map to 2 or more sites"), aes(QUALITY, NB_OF_READS)) + 
  geom_boxplot(outlier.size = -1, aes(fill = IS_RETAINED)) + 
  geom_jitter(position=position_jitter(0.3)) +
  facet_wrap(~QUALITY, scales = "free", nrow = 1) + 
  scale_fill_manual(name = "Retained read ?", values = c("firebrick3", "chartreuse3")) +
  ylab("% of reads") +
  xlab("") + 
  scale_y_continuous(labels = percent) + 
  theme(axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        legend.position="bottom") +
  coord_flip()


row1 <- plot_grid(pA, labels = c("A"))
row2 <- plot_grid(pB,pC, ncol = 2,labels = c("B","C"))

plot_grid(row1,row2, pD, ncol = 1, labels = c("","","D"), rel_heights = c(1,.7,.7, .7))

```

\newpage

##### Résultat de l'appel des variants  

```{r varcall, cache=TRUE} 

call_file <- "results/all_call.rds"

if (!file.exists(call_file)) {
  
  
call <- function(file, fam, run) {

fread(file, sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, data.table = FALSE) %>% 
    gather(RUN, CALL, starts_with("Ghs")) %>% 
  filter(CALL != "*",
         CALL != "a",
         CALL != 1) %>% 
  mutate(RUN = run,
         FAM = fam, 
         TYPE = if_else(stri_length(REF) == stri_length(ALT), "SNV", "Indel"), 
         STRAND = if_else(CALL %in% c(2:9), "DS", 
                          if_else(CALL == 0, "NS", "SS")),
         CALL = if_else(CALL %in% c(2,"b"),"Heterozygous",
                        if_else(CALL %in% c(3,"c"), "Homozygous",
                                if_else(CALL %in% c(4:7,"d","e","f","g","h","i"),"Ambigous call",
                                                if_else(CALL %in% c(8,9), "Discordant call",
                                                        if_else(CALL == 0, "NA", paste0("ERROR !!!: ",CALL)))))))
  
}

df_call_az1 <- call(file = "data/call_results/call_az1.csv", fam = "AZ", run = "AZ1")
df_call_az2 <- call(file = "data/call_results/call_az2.csv", fam = "AZ", run = "AZ2")
df_call_ff1 <- call(file = "data/call_results/call_ff1.csv", fam = "FF", run = "FF1")
df_call_ff2 <- call(file = "data/call_results/call_ff2.csv", fam = "FF", run = "FF2")
df_call_mmaf1_1 <- call(file = "data/call_results/call_mmaf1_1.csv", fam = "MMAF1", run = "MMAF1.1")
df_call_mmaf1_2 <- call(file = "data/call_results/call_mmaf1_2.csv", fam = "MMAF1", run = "MMAF1.2")
df_call_mmaf2_1 <- call(file = "data/call_results/call_mmaf2_1.csv", fam = "MMAF2", run = "MMAF2.1")
df_call_mmaf2_2 <- call(file = "data/call_results/call_mmaf2_2.csv", fam = "MMAF2", run = "MMAF2.2")
df_call_mmaf3_1 <- call(file = "data/call_results/call_mmaf3_1.csv", fam = "MMAF3", run = "MMAF3.1")
df_call_mmaf3_2 <- call(file = "data/call_results/call_mmaf3_2.csv", fam = "MMAF3", run = "MMAF3.2")
df_call_mmaf4_1 <- call(file = "data/call_results/call_mmaf4_1.csv", fam = "MMAF4", run = "MMAF4.1")
df_call_mmaf4_2 <- call(file = "data/call_results/call_mmaf4_2.csv", fam = "MMAF4", run = "MMAF4.2")
df_call_mmaf4_3 <- call(file = "data/call_results/call_mmaf4_3.csv", fam = "MMAF4", run = "MMAF4.3")

df_call_fam <- rbind(df_call_az1, 
                       df_call_az2,
                       df_call_ff1, 
                       df_call_ff2,
                       df_call_mmaf1_1,
                       df_call_mmaf1_2,
                       df_call_mmaf2_1,
                       df_call_mmaf2_2,
                       df_call_mmaf3_1,
                       df_call_mmaf3_2,
                       df_call_mmaf4_1,
                       df_call_mmaf4_2,
                       df_call_mmaf4_3)

rm(df_call_az1,
   df_call_az2,
   df_call_ff1, 
   df_call_ff2,
   df_call_mmaf1_1,
   df_call_mmaf1_2,
   df_call_mmaf2_1,
   df_call_mmaf2_2,
   df_call_mmaf3_1,
   df_call_mmaf3_2,
   df_call_mmaf4_1,
   df_call_mmaf4_2,
   df_call_mmaf4_3)
gc()


saveRDS(df_call_fam,call_file)

} else {
  
  df_call_fam <- readRDS(call_file)
  
}

df_strand_all <-  df_call_fam %>%
  select(RUN, STRAND) %>% 
  group_by(RUN, STRAND) %>%
  summarise(N = n()) %>%
  group_by(RUN) %>%
  mutate(P = N / sum(N),
         IS_RETAINED = if_else(STRAND == "NS","No",
                               if_else(STRAND == "DS", "Yes", "Yes but low quality")))
     
df_concordance_all <- df_call_fam %>%
  select(RUN, CALL, STRAND) %>%
  filter(STRAND == "DS") %>% 
  mutate(CALL = if_else(grepl("zygous", CALL), "Concordant call", CALL)) %>%
  group_by(RUN, CALL) %>%
  summarise(N = n()) %>%
  group_by(RUN) %>%
  mutate(P = N / sum(N),
         IS_RETAINED = if_else(CALL == "Concordant call","Yes","No"))

df_geno_all <- df_call_fam %>%
  select(RUN, CALL, TYPE) %>%
  filter(grepl("zygous", CALL)) %>% 
  group_by(RUN, CALL, TYPE) %>%
  summarise(N = n()) %>% 
  group_by(RUN) %>%
  mutate(P = N / sum(N),
         IS_RETAINED = if_else(grepl("zygous", CALL),"Yes","No")) %>%
  bind_rows(data_frame(RUN = "AZ1", CALL = "Heterozygous", TYPE = "Indel", N = 0, P = 0, IS_RETAINED = "No")) %>% # it permits to have the "no" field in the legend of the barplot
  bind_rows(data_frame(RUN = "AZ1", CALL = "Heterozygous", TYPE = "Indel", N = 0, P = 0, IS_RETAINED = "Yes but low quality")) 

```


```{r}

median_percent_ss <- df_strand_all %>% filter(STRAND == "SS") %>% collect() %>% .[["P"]] %>% median %>% round(3) * 100 
median_percent_ds <- df_strand_all %>% filter(STRAND == "DS") %>% collect() %>% .[["P"]] %>% median %>% round(3) * 100 

min_percent_ns <- df_strand_all %>% filter(STRAND == "NS") %>% collect() %>% .[["P"]] %>% min %>% round(3) * 100
max_percent_ns <- df_strand_all %>% filter(STRAND == "NS") %>% collect() %>% .[["P"]] %>% max %>% round(3) * 100


concordant_median <- df_concordance_all %>% ungroup() %>% filter(CALL == "Concordant call") %>% collect() %>% .[["P"]] %>% median %>% round(3) * 100
wrong_median <- 100 - concordant_median

median_het_snv <- df_geno_all %>% filter(TYPE == "SNV" & CALL == "Heterozygous") %>% collect() %>% .[["N"]] %>% median %>% as.integer
median_het_indel <- df_geno_all %>% filter(TYPE == "Indel" & CALL == "Heterozygous") %>% collect() %>% .[["N"]] %>% median %>% as.integer

median_homo_snv <- df_geno_all %>% filter(TYPE == "SNV" & CALL == "Homozygous") %>% collect() %>% .[["N"]] %>% median %>% as.integer
median_homo_indel <- df_geno_all %>% filter(TYPE == "Indel" & CALL == "Homozygous") %>% collect() %>% .[["N"]] %>% median %>% as.integer
```

Comme dit précédemment, l'appel des variants fait suite à l'alignement et consiste à comparer la séquence d'un individu avec celle d'un génome de référence afin d'en relever les différences. La particularité de notre algorithme d'appel est d'effectuer pour chaque position deux appels indépendants Le premier sera effectué en utilisant uniquement les *reads forward* et le second le *reads reverse*. Encore une fois, plusieurs filtres sont appliqués de sorte à conserver uniquement les variants les plus qualitatifs. 

Tout d'abord, nos appels sont classés en trois catégories : 

1. **Les appels *double strand* (DS) :**  Qualifie les positions ayant une couverture $\ge$ 10 sur **les deux** strands. Ces appels sont ceux sont ceux ayant la meilleure qualité 
2. **Les appels *single strand* (SS) :**  Ces appels définissent les positions pour lesquels **un des deux** *strands* présentent une couverture $\le$ 10. Dans ce cas, ce *strand* est ignoré et l'appel est effectué uniquement en utilisant le second *strand*.   
3. **Les appels *non strand* (NS) :** Les positions NS sont celles pour lesquelles la couverture est $\le$ 10 sur **les deux** strands. Aucun appel n'est effectué à ces positions.  

Dans nos données, les appels SS sont majoritaires et représentent environ `r median_percent_ss` % de nos appels (contre `r median_percent_ds` % d'appels DS). Au vus de l'importance de ces appels, nous avons fait le choix de les conserver afin de ne pas filtrer une quantité trop importante de données. Ces appels seront cependant considérés comme étant de faible qualité, de fait, leurs analyses et interprétation seront plus précautionneuses En revanche, au vus de la trop grande incertitude de l'appel des variants NS, ceux-ci sont systématiquement filtrés éliminant ainsi entre `r min_percent_ns` et `r max_percent_ns` % des positions appelées (**Figure : **\@ref(fig:plotvarcall) - **A**).  

Un second filtre est appliqué aux variants ayant été précédemment appelés DS. Celui-ci consiste à comparer les appels effectués indépendamment sur chacune des deux *ends* et à vérifier leur concordance, c'est à dire que les deux appels soit identique. Les appels discordant et ambigus sont filtrer, ainsi environs `r concordant_median` % des variants DS passent ce filtre. Il est intéressant de noter que bien que les variants *single strand* (SS) soient conservés, on peut s'attendre à ce qu'environ `r wrong_median` % de ceux-ci soient aberrants, ceux-ci n'ayant pu subir le même contrôle que les SS (**Figure : **\@ref(fig:plotvarcall) - **B**). 

Pour l'ensemble des variants ayant passé les filtres énoncés ci-dessus, c'est à dire les variants SS et les variants DS avec appels concordants, le génotype est déterminé en fonction du pourcentage de *reads* portant le variant à cette position. Par exemple, si à une position donnée, 0% des *reads* portent un variant, l'individu sera appelé "Homozygote référence", si 50% des *reads* sont portent un variant, l'appel sera "hétérozygote" et si 100% des *reads* portent un variant, l'appel sera "Homozygote variant". Ainsi, pour chaque individu nous avons pu établir une liste de SNVs et d'indels avec leur génotype associé. Pour chacun de nos `r nb_run` patients les ordres de grandeur du nombre de variants appelés sont identique. Ainsi pour chaque patient nous avons appelés environ `r median_het_snv + median_het_indel` variants hétérozygotes (`r median_het_snv` SNVs et `r median_het_indel` indels) et `r median_homo_snv + median_homo_snv` variants homozygotes (`r median_homo_snv` SNVs et `r median_homo_indel` indels) (**Figure : **\@ref(fig:plotvarcall) - **C**).    

\newpage

```{r plotvarcall, dependson="varcall", fig.cap=fig_info,fig.scap=fig_name,fig.width=7, fig.height=7, cache=TRUE}

fig_name <- "Contrôle qualité des variants appelés"
fig_description_all <- "Pour chacun des graphiques, les variants représentés en vert et en orange sont conservés tandis que ceux en rouge sont filtrés"
fig_description_A <- "**A** : Distribution du *stranding* des appels pour chaque patient"
fig_description_B <- "**B** : Comparaison des appels entre les deux *ends* des variants appelés DS"
fig_description_C <- "**C** : Distribution des SNVs et indels en fonction de leur génotype pour chaque patients (représentés par une barre"
fig_description <- paste(fig_description_all, fig_description_A,fig_description_B,fig_description_C, sep = ". ")
fig_info <- paste0(fig_name, " : ", fig_description)

pA <- ggplot(df_strand_all, aes(STRAND, P)) +
  geom_boxplot(outlier.size = -1, aes(fill = IS_RETAINED)) + 
  geom_jitter(size = 2, position=position_jitter(0.3)) +
  ylab("% of called variant") +
  xlab("") +
    facet_wrap(~factor(STRAND, levels = c("DS", "SS", "NS")), scales = "free") +
  scale_fill_manual(guide = "none", values = c("firebrick3", "chartreuse3", "darkorange1")) +
  scale_y_continuous(labels = percent) + 
  theme(axis.title.x = element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

pB <- ggplot(df_concordance_all, aes(CALL, P)) +
  geom_boxplot(aes(fill = IS_RETAINED), outlier.size = -1) + 
  geom_jitter(size = 2, position=position_jitter(0.3)) +
  ylab("% of called variant") +
  xlab("") +
  facet_wrap(~factor(CALL, levels = c("Concordant call", "Ambigous call", "Discordant call")), scales = "free") +
  scale_fill_manual(guide = "none", values = c("firebrick3", "chartreuse3")) + 
  scale_y_continuous(labels = percent) + 
  theme(axis.title.x = element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

pC <- ggplot(df_geno_all,aes(RUN, N)) + 
  geom_bar(stat = "identity", aes(fill = IS_RETAINED)) +
  facet_grid(TYPE~CALL, scales = "free") +
  ylab("Nb of variant") + 
  scale_fill_manual(name = "Is the variant retained?", values = c("firebrick3", "chartreuse3", "darkorange1"), breaks = c("Yes","Yes but low quality", "No")) +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        legend.position = "bottom")

row1 <- plot_grid(pA, labels = c("A"))
plot_grid(row1, pB, pC,labels = c("","B","C"), rel_heights = c(.6,.8,1), ncol = 1)

```

\newpage

##### Résultats de l'annotation  

```{r retrieveannotation, cache=TRUE} 

annotate_file <- "results/annotate_variants.rds"

if (!file.exists(annotate_file)) {

  df_annotate <- df_call_fam %>%
    filter(grepl("zygous", CALL)) %>% 
    select(-STRAND) %>%
    variant_join(fread("data/all_variants_vep81.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE), mode = "left") %>% 
    select(-Allele, -Gene, -Feature_type, -(BIOTYPE:HGNC_ID), -(CADD_RAW:ExAC_AF_OTH), -(ExAC_AF_AMR:ExAC_AF_SAS)) %>%
    mutate(PHENO = if_else(FAM == "AZ","Azoo",
                           if_else(FAM == "FF", "Fert_fail", "MMAF"))) %>% 
    group_by(RUN) %>% 
    mutate(N_VAR_PER_RUN = n_distinct(CHR,POSITION,REF,ALT)) 
  
  saveRDS(df_annotate, annotate_file)
  
} else {
  
  df_annotate <- readRDS(annotate_file)
  
}

```

```{r cleancall2, include=FALSE, warning=FALSE}

rm(df_call_fam)
gc()

```

```{r varannotation, dependson="retrieveannotation", cache=TRUE}

nb_feature_file <- "results/annotation_nb_feature.rds"
nb_impact_geno_file <- "results/annotation_impact_geno.rds"

if (!file.exists(nb_feature_file)) {

df_nb_feature <- df_annotate %>%
  group_by(RUN) %>%
  summarise(TRANSCRIPT = n_distinct(Feature),
            GENE = n_distinct(SYMBOL)) %>%
  gather(FEATURE, NB, TRANSCRIPT:GENE) 

  saveRDS(df_nb_feature, nb_feature_file)


} else {
  
    df_nb_feature <- readRDS(nb_feature_file)

}

if (!file.exists(nb_impact_geno_file)) {


df_impact <- df_annotate %>% 
  group_by(RUN,CALL, IMPACT) %>%
  summarise(N = n()) %>%
  group_by(RUN) %>%
  mutate(P = N / sum(N))

  saveRDS(df_impact, nb_impact_geno_file)
  
} else {
  
      df_impact <- readRDS(nb_impact_geno_file)
}


df_freq <- df_annotate %>%
  group_by(RUN, ExAC_AF, `1KG`, ESP) %>% 
  distinct(CHR,POSITION,REF,ALT, N_VAR_PER_RUN) %>% 
  group_by(RUN) %>%
  rename(ExAC = ExAC_AF) %>%
  gather(DB,FREQ,ExAC:ESP) %>% 
  filter(!is.na(FREQ)) 

df_freq2 <- df_freq %>%
  ungroup() %>% 
  distinct(CHR,POSITION,REF,ALT,DB,FREQ) %>% 
  select(-(CHR:ALT)) 

df_freq_stat <- df_freq %>%
    select(-(CHR:ALT)) %>% 
  group_by(RUN, DB) %>% 
  summarise(N_PER_RUN_PER_DB = n(),
            P_PER_RUN_PER_DB = n() / mean(N_VAR_PER_RUN))

```

```{r}

mean_transcript <- df_nb_feature %>% ungroup() %>% filter(FEATURE == "TRANSCRIPT") %>% summarise(MEAN = mean(NB)) %>% collect() %>% .[["MEAN"]] %>% round(0)


mean_gene <- df_nb_feature  %>% filter(FEATURE == "GENE") %>% collect() %>% .[["NB"]] %>% mean %>% round(0) %>% as.integer
mean_transcript <- df_nb_feature  %>% filter(FEATURE == "TRANSCRIPT") %>% collect() %>% .[["NB"]] %>% mean %>% round(0) %>% as.integer



rate_tr_gene = (mean_transcript / mean_gene) %>% round(0)

mean_percent_high <- df_impact %>% filter(IMPACT == "HIGH") %>% group_by(RUN) %>% summarise(SP = sum(P)) %>% collect() %>% .[["SP"]] %>% mean %>% round(4) * 100
mean_nb_het_high <- df_impact %>% filter(IMPACT == "HIGH" & CALL == "Heterozygous") %>% group_by(RUN) %>% summarise(SN = sum(N)) %>% collect() %>% .[["SN"]] %>% mean %>% round(0) 
mean_nb_homo_high <- df_impact %>% filter(IMPACT == "HIGH" & CALL == "Homozygous") %>% group_by(RUN) %>% summarise(SN = sum(N)) %>% collect() %>% .[["SN"]] %>% mean %>% round(0) 


min_percent_exac <- df_freq_stat %>% filter(DB == "ExAC") %>% collect() %>% .[["P_PER_RUN_PER_DB"]] %>% min %>% median %>% round(3) * 100
max_percent_exac <- df_freq_stat %>% filter(DB == "ExAC") %>% collect() %>% .[["P_PER_RUN_PER_DB"]] %>% max %>% median %>% round(3) * 100

min_percent_esp <- df_freq_stat %>% filter(DB == "ESP") %>% collect() %>% .[["P_PER_RUN_PER_DB"]] %>% min %>% median %>% round(3) * 100
max_percent_esp <- df_freq_stat %>% filter(DB == "ESP") %>% collect() %>% .[["P_PER_RUN_PER_DB"]] %>% max %>% median %>% round(3) * 100

median_percent_1kg <- df_freq_stat %>% filter(DB == "1KG") %>% collect() %>% .[["P_PER_RUN_PER_DB"]] %>% median %>% round(3) * 100

```

L'annotation des variants appelés consiste à ajouter un maximum d'informations sur les variants. Ces informations seront ensuite utilisées afin de filtrer et / ou prioriser les variants. Dans ces analyses nous avons utilisé le logiciel *Variant Effect Predictor* (VEP) [@McLaren2016] qui va à la fois prédire l'effet qu'auront ces variants sur l'ensemble des transcrits (et gènes) qu'ils chevauchent, ajouter, lorsqu'elle est disponible, la fréquence de chacun de ces variants dans les bases de données ExAC, 1000Genomes (1KG) et ESP6500. Pour finir VEP nous permettra de connaitre les prédictions de pathogénicités fournies par SIFT et PolyPhen pour les variants faux-sens.

Après avoir annoter nos variants par VEP, nous avons pu constater que pour chaque patient `r mean_gene` gènes sont en moyenne affecté par au moins un variant pour en moyenne `r mean_transcript` transcrits (soit environs `r rate_tr_gene` transcrits par gènes) (**Figure : **\@ref(fig:plotvarannotation) - **A**).  

Chaque variant affectera l'ensemble des transcrits qu'il chevauche, ainsi un même variant pourra impacter plusieurs transcrits. Ces impacts sont ensuite classés par VEP en quatre catégories qui sont, de la plus délétère à la moins délétère : HIGH, MODERATE, LOW, MODIFIER (**Table :**\@ref(tab:tabvepcsq)). Comme attendu, les variants ayant un impact tronquant se retrouvent être les moins fréquent chez chacun de nos patients. Ceci est d'autant plus flagrant pour l'impact HIGH qui regroupe, entre autres, les variants créant un codon stop ou encore ceux causant un décalage du cadre de lecture (**Table :**\@ref(tab:tabvepcsq)), se retrouvent en quantité extrêmement faible puisqu'ils ne représentent en moyenne que `r mean_percent_high` % des variants, soit une moyenne de `r mean_nb_het_high` hétérozygotes et `r mean_nb_homo_high` homozygotes par patient) (**Figure : **\@ref(fig:plotvarannotation) - **B**).  

Parmi ces variants, certains étaient déjà recensés dans une des trois base donnée (ExAC, ESP et 1KG). Ainsi, on peut observer qu'entre `r min_percent_exac` et `r max_percent_exac` % de nos variant étaient listés dans ExAC et entre `r min_percent_esp` et `r max_percent_esp` % dans ESP. En revanche environ `r median_percent_1kg` % d'entre eux sont recensés dans 1KG (**Figure : **\@ref(fig:plotvarannotation) - **C**) (À discuter !!!!!).  

(À discuter !!!!!) (**Figure : **\@ref(fig:plotvarannotation) - **D**)

LES FIGURES SUR LA FRÉQUENCE SONT À DISCUTER CAR LEUR INTERPRÉTATION ME LAISSE PERPLEX (SURTOUT LA PROPORTION DE NOS VARIANTS PRÉSENTS DANS 1KG)

\newpage

```{r plotvarannotation, fig.cap=fig_info,fig.scap=fig_name,fig.width=6.5, fig.height=7, cache=TRUE}

fig_name <- "Annotation des variants par VEP"
fig_description_A <- "**A** : Quantification du nombre de gènes (en bleu) / transcrits (en rose) impactés par au moins un variant pour chaque patient chacun représentés par une barre"
fig_description_B <- "**B** : Distribution des impact HIGH MODERATE LOW et MODIFIER en fonction des patients et du génotype du variant"
fig_description_C <- "**C** : Pourcentage de nos variants retrouvés au sein des trois bases de données : ExAC, ESP et 1KG"
fig_description_D <- "**D** : Distribution des fréquences de nos variants au sein des trois bases de données : ExAC, ESP et 1KG"

fig_description <- paste(fig_description_A,fig_description_B, fig_description_C, fig_description_D, sep = ". ")
fig_info <- paste0(fig_name, " : ", fig_description)


pA <- ggplot(df_nb_feature, aes(RUN, NB)) + 
  geom_bar(stat = "identity", position = position_nudge(),  aes(fill = FEATURE)) + 
  # scale_fill_discrete(name = "Feature", labels = c("Gene", "Transcript")) + 
  xlab("Patient") + 
  ylab("Nb of feature impacted") +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank()) + 
  scale_fill_brewer(palette = "Set1", name = "Feature", labels = c("Gene", "Transcript")) 


pB <- ggplot(df_impact, aes("", P)) +
  geom_boxplot(aes(fill = CALL), alpha = .3, outlier.size = -1) + 
  geom_jitter(aes(col = CALL), size = 1, position = position_jitterdodge(0.2)) +
  facet_wrap(~factor(IMPACT, levels = c("HIGH", "MODERATE", "LOW", "MODIFIER")), scales = "free", nrow = 1) +
  scale_y_continuous(labels = percent_format()) + 
  scale_color_brewer(palette = "Set1", name = "Call") +
  scale_fill_brewer(palette = "Set1", name = "Call") + 
  theme(axis.title = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

pC <- ggplot(df_freq_stat, aes("", P_PER_RUN_PER_DB)) + 
  geom_boxplot(outlier.size = -1, aes(fill = DB)) + 
  geom_jitter(size = 1, position = position_jitter(0.2)) +
  facet_wrap(~DB, scales = "free") + 
  ylab("% of variant found within a DB") + 
  xlab("") +
  scale_x_discrete(labels = c("1KG","ESP6500","ExAC")) +
  scale_y_continuous(labels = percent) +
   scale_fill_brewer(palette = "Set1", guide = "none") +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
        
pD <- ggplot(df_freq2, aes(FREQ)) + 
  geom_line(aes(col = DB), stat = "bin", bins = 150) +
   scale_color_brewer(palette = "Set1", name = "Data base", labels = c("1KG","ESP6500","ExAC")) + 
  xlab("Variant frequency") +
  ylab("Nb of variants") + 
  scale_x_continuous(labels = percent)

row1 <- plot_grid(pA, pB, labels = c("A","B"), ncol = 1)
row2 <- plot_grid(pC, pD, labels = c("C","D"), ncol = 2)

plot_grid(row1,row2, ncol = 1, labels = c("","",""), rel_heights = c(1,.5))

```

```{r cleanfreq, include=FALSE, warning=FALSE}

rm(df_freq, df_freq2, df_freq_stat)
gc()


```

\newpage

##### Résultats du filtrage

```{r ctrldata, include=FALSE, cache=TRUE}

open_ctrl <- function(file, pheno = "none") {
  
  fread(file, sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE) %>% 
    gather(RUN, CALL, starts_with("Ghs")) %>%
    filter(CALL %in% c(3, "c")) %>%
    mutate(N_CTRL = n_distinct(RUN),
           PHENO = pheno)  %>%
    select(-CALL) %>% 
    distinct(CHR, POSITION, REF, ALT, N_CTRL, PHENO)
}

ctrl_file <- "results/all_ctrl.rds"
sample_ctrl_file <- "results/sample_ctrl.rds" 

if(!file.exists(ctrl_file)) {

  df_ctrl_az <- open_ctrl("data/genotype_not_azoo.csv", pheno = "Azoo")
  df_ctrl_ff <- open_ctrl("data/genotype_not_fert_fail.csv", pheno = "Fert_fail")
  df_ctrl_mmaf <- open_ctrl("data/genotype_not_MMAF.csv", pheno = "MMAF")
  
  nb_ctrl_az <-df_ctrl_az %>% collect() %>% .[["N_CTRL"]] %>% mean 
  nb_ctrl_ff <-df_ctrl_ff %>% collect() %>% .[["N_CTRL"]] %>% mean 
  nb_ctrl_mmaf <-df_ctrl_mmaf %>% collect() %>% .[["N_CTRL"]] %>% mean 
  
  fam_lab <- c("Az", "FF", "MMAF1", "MMAF2", "MMAF3", "MMAF4")
  
  nb_ctrl <- c(nb_ctrl_az,
               nb_ctrl_ff,
               nb_ctrl_mmaf,
               nb_ctrl_mmaf,
               nb_ctrl_mmaf,
               nb_ctrl_mmaf)
  
  df_sample_ctrl <- data_frame(FAM = fam_lab,
                               NB = nb_ctrl)
  
  df_ctrl_all <- rbind(df_ctrl_az,
                       df_ctrl_ff,
                       df_ctrl_mmaf)
  
  saveRDS(df_ctrl_all,ctrl_file)
  saveRDS(df_sample_ctrl,sample_ctrl_file)
  
  rm(df_ctrl_az, df_ctrl_ff, df_ctrl_mmaf)
  gc()
  
} else {
  
  df_ctrl_all <- readRDS(ctrl_file)
  df_sample_ctrl <- readRDS(sample_ctrl_file)
}

```

```{r filterallfam, cache=TRUE}

maf_cutoff <- .01

df_filter_fam <- df_annotate %>% 
  ungroup() %>%
  filter_genotype(het = FALSE) %>%
  filter_frequence(cutoff = maf_cutoff) %>%
  variant_join(df_ctrl_all, add_by = "PHENO", mode = "anti") %>% 
  filter(Consequence != "synonymous_variant",
         IMPACT != "MODIFIER",
         !(grepl("tolerated", SIFT) & grepl("benign", PolyPhen)),
         !grepl("NMD_transcript_variant",Consequence),
         !grepl("non_coding_transcript_variant", Consequence)) %>%
  group_by(FAM) %>%
  mutate(NB_FAM = n_distinct(RUN)) %>% 
  group_by(CHR, POSITION, REF, ALT, FAM, Feature) %>% 
  filter(n() == mean(NB_FAM))

```

```{r filternonpertinanttr, include=FALSE, warning=FALSE, cache=TRUE}

df_tmp <- df_annotate %>%
  ungroup() %>%
  select(CHR, POSITION, REF, ALT, RUN, Feature, Consequence) %>%
  mutate(IS_FILTERED = grepl("NMD_transcript_variant", Consequence) | grepl("non_coding_transcript_variant", Consequence)) %>%
  select(-Consequence) %>%
  group_by(RUN, IS_FILTERED) %>%
  mutate(N_TRANSCRIT_PER_ISNMD = n_distinct(Feature))

df_filtered_tr <- df_tmp %>%
  summarise(N = n_distinct(Feature),
            TYPE = "Transcript")  

df_filtered_tr_vr <- df_tmp %>%
  group_by(CHR, POSITION, REF, ALT, RUN) %>% 
  mutate(IS_FILTERED = if_else(n_distinct(IS_FILTERED) == 1 & IS_FILTERED == TRUE, TRUE, FALSE)) %>%
  group_by(RUN, IS_FILTERED) %>%
  summarise(N = n_distinct(CHR,POSITION,REF,ALT),
            TYPE = "Variants") %>% 
  bind_rows(df_filtered_tr)


rm(df_tmp)
gc()

max_tr <- ungroup(df_filtered_tr_vr) %>% filter(TYPE == "Transcript" & IS_FILTERED == TRUE) %>% collect() %>% .[["N"]] %>% max
min_tr <- ungroup(df_filtered_tr_vr) %>% filter(TYPE == "Transcript" & IS_FILTERED == TRUE) %>% collect() %>% .[["N"]] %>% min
mean_variant <- ungroup(df_filtered_tr_vr) %>% filter(TYPE == "Variant" & IS_FILTERED == TRUE) %>% collect() %>% .[["N"]] %>% mean %>% round(0)

```


Les étapes précédentes nous ont permis de mettre en évidence pour chaque patient une liste de variants passant l'ensemble de nos critères qualités. Ces variants ont dès lors put être annotés nous permettant entre autres d'avoir connaissance de leurs l'impacts sur les différents transcrits qu'ils chevauchent ou encore leur fréquence dans la population générale. Désormais, afin de ne conserver que les variants ayant la plus forte probabilité d'être responsable du phénotype de ces patients, nous avons appliqué successivement six filtres basés à la fois sur les différentes annotations que nous avons ajoutées mais aussi sur nos connaissances du mode de transmission du phénotype :  

1. **Filtre 1 : L'union des variants :** Dans ces différentes études, nous avons à chaque fois séquencé des duos ou des trios d'individus provenant de même fratries et étant caractérisés par le même phénotype. Ainsi nous avons pu formuler l'hypothèse d'une cause génétique commune entre les différents patients d'une même famille et donc filtrer l'ensemble des variants qui ne sont pas partagés par l'ensemble des membres de la fratrie.     
2. **Filtre 2 : Génotype des variants :**  Dans ces études, nous avons émis l'hypothèse d'une transmission récessive du phénotype. Ainsi, seul les variants homozygotes ont été conservés. (**Figure : **\@ref(fig:resvarcall), \@ref(fig:comparefilter)).    
3. **Filtre 3 : Impact du variant :** Afin de ne conserver que les variants ayant un effet potentiellement tronquant sur la protéine, nous avons filtré les variants intronique et ceux tombant dans les séquences UTRs. De même les variants synonymes ne sont pas conservés (exceptés ceux se trouvant proches des régions d'épissage) car ceux-ci n'ont aucun effet sur séquences protéique. Pour les variants faux sens (changement d'un seul aa de la séquence protéique) il est plus difficile de se décider [TODO insert citation] nous avons donc utilisé les logiciels SIFT [@Kumar2009] et Polyphen [@Adzhubei2010] et filtré l'ensemble des faux-sens prédit comme *tolerated* par SIFT et *benign* par Polyphen.  
4. **Filtre 4 : Les transcrits "non pertinents" :** Au cours de nos analyses nous nous sommes concentré uniquement sur les transcrits codant pour une protéine. Ainsi, l'ensemble des transcrits annotés comme étant non codant furent filtrés. De même Le mécanisme NMD (*nonsense-mediated decay*) a pour but de contrôler la qualité des ARNm cellulaires chez les eucaryotes [@Chang2007] en éliminant les ARNm qui comportent un codon stop prématuré [@Baker2004], pouvant être le résultat d'une erreur de transcription, d'une mutation ou encore d'une erreur d'épissage. Il est donc peu probable que les variants présents sur transcrits annotés NMD soient responsables du phénotype. Dès lors, ces transcrits furent eux aussi filtrés. Ainsi, nous avons pu retirer de nos listes de variants l'ensemble des mutations impactant **uniquement** des transcrits non codant et / ou annoté NMD. Cette étape de filtre permet à elle seule de systématiquement filtrer entre `r min_tr` et `r max_tr` transcrits différents par patients, soit une moyenne de `r mean_variant` variants par individus (**Figure : **\@ref(fig:plotfilternonpertinanttr)).    

```{r plotfilternonpertinanttr, fig.cap=fig_info,fig.scap=fig.name,fig.width=6.3, fig.height=3.5, cache=TRUE}

fig.name <- "Filtrage des transcrits jugés \"non pertinents\" et des variants les chevauchant"
fig_description <- "Pour chaque patients nous avons filtrer les transcrits jugés \"non pertinents\" pour l'analyse, c'est à dire ceux ne codant pas pour une protéine et ceux annoté NMD. Dès lors, l'intégralité des variants chevauchant uniquement des transcrits non pertinents ont put systématiquement être filtrés (boites rouges). les autres furent conservés (boites vertes)"
fig_info <- paste0(fig.name, " : ", fig_description)

ggplot(df_filtered_tr_vr, aes(IS_FILTERED, N)) + 
  geom_boxplot(aes(fill = IS_FILTERED), outlier.size = -1) + 
  geom_jitter(size = 2, position=position_jitter(0.3)) +
  scale_fill_manual(name = "Retained?", values = c("chartreuse3", "firebrick3"), labels = c("Yes","No")) +
  facet_wrap(~TYPE, scales = "free") +
  ylab("Nb of transcripts / variants") + 
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

```
5. **Fréquence des variants :**  La fréquence d'un variant dans la population générale est un moyen rapide d'avoir un avis sur l'effet délétère de celui-ci. En effet, il est peu probable qu'un retrouvé fréquemment dans la population générale soit causal d'une pathologie sévère. Ainsi nous avons filtré pour l'ensemble de nos patients l'ensemble des variants ayant une fréquence $\ge$ `r maf_cutoff` dans l'une des trois bases de données que sont ExAC, ESP et 1KG.    
6. **Présence des variants dans la cohorte contrôle :**  Au cours de nos différentes études, nous avons été amenés à séquencé `r n_tot_runs`. L'ensemble de ces individus peuvent être soit sains soit présenter l'un des `r n_pheno` phénotypes étudié au cours de nos différentes études (**Table : **\@ref(tab:TODO)). Ces phénotypes étant très différent, il n'est pas aberrant d'émettre l'hypothèse qu'ils que leurs causes génétiques le soient également. De même, les variants recherchés étant rares, il est peu probable qu'un individu porte les variants de deux phénotypes différents. Ainsi, pour chacune des `r nb_fam` familles, nous avons pu constituer une cohorte contrôle composée dans l'ensemble des patients précédemment analysés et ne présentant pas le même phénotype que celui étudié dans la famille (**Figure :** \@ref(fig:plotsamplectrl)). Dès lors, nous avons pu filtrer l'ensemble des variants retrouvés à la fois chez nos patients et observés à l'état homozygote dans la cohorte contrôle.                                                                            

```{r plotsamplectrl, fig.cap=fig_info,fig.scap=fig.name, fig.height=4, cache=TRUE}
     
fig.name <- "Nombre d'individus composant la cohorte contrôle de chaque famille"
fig_description <- "Ici, chaque barre représente une famille et sa hauteur est déterminée par le nombre d'individus composant la cohorte contrôle à laquelle elle a été confronté. Chaque individu de la cohorte contrôle a été séquencés en WES par notre équipe. Afin d'être considéré comme \"contrôle\" et intégrer cette cohorte, un individu doit être sain ou présenter un phénotype d'infertilité différent de la famille étudiée. Par exemple, un individus MMAF pourra servir de contrôle aux familles AZ et FF mais pas aux familles MMAF1-4"
fig_info <- paste0(fig.name, " : ", fig_description)
                         
ggplot(df_sample_ctrl, aes(FAM, NB, fill = FAM)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = NB), position = position_dodge(width = .9), vjust = -.25) +
  ylab("Number of control individuals") +
   scale_fill_brewer(palette = "Set1", guide = "none") +
  xlab("Familly")


```

\newpage

```{r comparefilters, include=FALSE, cache=TRUE}

filter_file <- "results/filter.rds"
filter_spe_file <- "results/filter_spe.rds"

if (!file.exists(filter_file) | 
    !file.exists(filter_spe_file)) {

df_filtered_by_geno <- df_annotate %>% 
  filter_genotype(homo = FALSE) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN) %>%
  mutate(FILTER = "Genotype", 
         N_FILTERED = n_distinct(CHR,POSITION,REF,ALT),
         P_FILTERED = N_FILTERED / N_VAR_PER_RUN)

df_filtered_by_freq <- df_annotate %>%
  filter(!is.na(ExAC_AF) & ExAC_AF >= maf_cutoff,
         !is.na(ESP) & ESP >= maf_cutoff,
         !is.na(`1KG`) & `1KG` >= maf_cutoff) %>%
  mutate(FILTER = "Frequence", 
         N_FILTERED = n_distinct(CHR,POSITION,REF,ALT),
         P_FILTERED = N_FILTERED / N_VAR_PER_RUN)
  
df_fitered_by_impact <- df_annotate %>% 
  group_by(RUN) %>% 
  mutate(IS_FILTERED = if_else(Consequence != "synonymous_variant" &
                               IMPACT != "MODIFIER" &
                               (!(grepl("tolerated", SIFT) & grepl("benign", PolyPhen))), FALSE, TRUE)) %>%
  distinct(CHR, POSITION, REF, ALT, IS_FILTERED, N_VAR_PER_RUN) %>%
  group_by(CHR, POSITION, REF, ALT, RUN) %>% 
  mutate(N = n()) %>%
  filter(N == 1,
         IS_FILTERED == TRUE) %>%
  group_by(RUN) %>% 
  mutate(FILTER = "Variant impact", 
         N_FILTERED = n(),
         P_FILTERED = N_FILTERED / N_VAR_PER_RUN)

df_filtered_by_union <- df_annotate %>% 
  distinct(CHR, POSITION, REF, ALT, FAM, N_VAR_PER_RUN) %>% 
  group_by(FAM) %>%
  mutate(NB_FAM = n_distinct(RUN)) %>%
  group_by(CHR, POSITION, REF, ALT, FAM) %>% 
  filter(n() < NB_FAM) %>% 
  group_by(RUN) %>%
  mutate(FILTER = "Union", 
         N_FILTERED = n_distinct(CHR,POSITION,REF,ALT),
         P_FILTERED = N_FILTERED / N_VAR_PER_RUN)

df_fitered_by_transcript <- df_annotate %>%
  mutate(IS_FILTERED = if_else(grepl("NMD_transcript_variant", Consequence) | grepl("non_coding_transcript_variant", Consequence), TRUE, FALSE)) %>% 
    distinct(CHR, POSITION, REF, ALT, IS_FILTERED, N_VAR_PER_RUN) %>%
  group_by(CHR, POSITION, REF, ALT, RUN) %>% 
  mutate(N = n()) %>%
  filter(N == 1,
         IS_FILTERED == TRUE) %>%
  group_by(RUN) %>% 
  mutate(FILTER = "Transcript relevance", 
         N_FILTERED = n(),
         P_FILTERED = N_FILTERED / N_VAR_PER_RUN)
  
df_filter_ctrl <- df_annotate %>% 
  variant_join(df_ctrl_all, add_by = "PHENO", mode = "inner") %>%
  mutate(FILTER = "Ctrl", 
            N_FILTERED = n_distinct(CHR,POSITION,REF,ALT),
            P_FILTERED = N_FILTERED / N_VAR_PER_RUN)


resume_filter <- function(df) {
  
  df %>% group_by(RUN, FILTER) %>% select(RUN, FILTER, N_FILTERED, P_FILTERED) %>% summarise(N = mean(N_FILTERED), P = mean(P_FILTERED))
  
}

filter_stat <- rbind(resume_filter(df_filtered_by_geno),
                     resume_filter(df_filtered_by_freq),
                     resume_filter(df_fitered_by_impact),
                     resume_filter(df_filtered_by_union),
                     resume_filter(df_filter_ctrl),
                     resume_filter(df_fitered_by_transcript))

saveRDS(filter_stat, filter_file)

} else {
  filter_stat <- readRDS(filter_file)
}


```

```{r filterspe, cache=TRUE}


if (!file.exists(filter_spe_file)) {

spe_geno <- df_filtered_by_geno %>% 
  group_by(RUN) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN, FILTER, N_FILTERED, P_FILTERED) %>% 
  variant_join(df_filtered_by_freq, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_fitered_by_impact, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_filtered_by_union, add_by = "RUN", mode = "anti") %>%
  variant_join(df_filter_ctrl, add_by = "RUN", mode = "anti") %>%
  variant_join(df_fitered_by_transcript, add_by = "RUN", mode = "anti") 

spe_freq <- df_filtered_by_freq %>% 
  group_by(RUN) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN, FILTER, N_FILTERED, P_FILTERED) %>% 
  variant_join(df_filtered_by_geno, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_fitered_by_impact, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_filtered_by_union, add_by = "RUN", mode = "anti") %>%
  variant_join(df_filter_ctrl, add_by = "RUN", mode = "anti") %>%
  variant_join(df_fitered_by_transcript, add_by = "RUN", mode = "anti") 

spe_impact <- df_fitered_by_impact %>% 
  group_by(RUN) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN, FILTER, N_FILTERED, P_FILTERED) %>% 
  variant_join(df_filtered_by_freq, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_filtered_by_geno, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_filtered_by_union, add_by = "RUN", mode = "anti") %>%
  variant_join(df_filter_ctrl, add_by = "RUN", mode = "anti") %>%
  variant_join(df_fitered_by_transcript, add_by = "RUN", mode = "anti") 

spe_union <- df_filtered_by_union %>% 
  group_by(RUN) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN, FILTER, N_FILTERED, P_FILTERED) %>% 
  variant_join(df_filtered_by_freq, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_fitered_by_impact, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_filtered_by_geno, add_by = "RUN", mode = "anti") %>%
  variant_join(df_filter_ctrl, add_by = "RUN", mode = "anti") %>%
  variant_join(df_fitered_by_transcript, add_by = "RUN", mode = "anti") 

spe_ctrl <- df_filter_ctrl %>% 
  group_by(RUN) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN, FILTER, N_FILTERED, P_FILTERED) %>% 
  variant_join(df_filtered_by_freq, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_fitered_by_impact, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_filtered_by_union, add_by = "RUN", mode = "anti") %>%
  variant_join(df_filtered_by_geno, add_by = "RUN", mode = "anti") %>%
  variant_join(df_fitered_by_transcript, add_by = "RUN", mode = "anti") 

spe_tr <- df_fitered_by_transcript %>% 
  group_by(RUN) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN, FILTER, N_FILTERED, P_FILTERED) %>% 
  variant_join(df_filtered_by_freq, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_fitered_by_impact, add_by = "RUN", mode = "anti") %>% 
  variant_join(df_filtered_by_union, add_by = "RUN", mode = "anti") %>%
  variant_join(df_filter_ctrl, add_by = "RUN", mode = "anti") %>%
  variant_join(df_filtered_by_geno, add_by = "RUN", mode = "anti") 

spe_all <- rbind(spe_geno,
                 spe_freq,
                 spe_impact,
                 spe_union,
                 spe_ctrl,
                 spe_tr) %>% 
  group_by(RUN, FILTER) %>% 
  distinct(CHR, POSITION, REF, ALT, N_VAR_PER_RUN, N_FILTERED, P_FILTERED) %>% 
  summarise(N_FILTERED_SPE = n_distinct(CHR, POSITION, REF, ALT),
            P_FILTERED_SPE = N_FILTERED_SPE / mean(N_VAR_PER_RUN))

saveRDS(spe_all, spe_filter_file)

} else {
  spe_all <- readRDS(filter_spe_file)
}


```

\newpage

```{r}

mean_filter_tr <- filter_stat %>% filter(FILTER == "Transcript relevance") %>% collect() %>% .[["P"]] %>% mean %>% round(3) * 100
max_filter_impact <- filter_stat %>% filter(FILTER == "Variant impact") %>% collect() %>% .[["P"]] %>% max %>% round(3) * 100
min_filter_ctrl <- filter_stat %>% filter(FILTER == "Ctrl") %>% collect() %>% .[["P"]] %>% min %>% round(3) * 100
max_filter_ctrl <- filter_stat %>% filter(FILTER == "Ctrl") %>% collect() %>% .[["P"]] %>% max %>% round(3) * 100

mean_filter_spe_impact <- spe_all %>% filter(FILTER == "Variant impact") %>% collect() %>% .[["N_FILTERED_SPE"]] %>% mean %>% round(0) 
mean_filter_spe_geno <- spe_all %>% filter(FILTER == "Genotype") %>% collect() %>% .[["N_FILTERED_SPE"]] %>% mean %>% round(0) 
mean_filter_spe_ctrl <- spe_all %>% filter(FILTER == "Ctrl") %>% collect() %>% .[["N_FILTERED_SPE"]] %>% mean %>% round(0) 
max_filter_spe_ctrl <- spe_all %>% filter(FILTER == "Ctrl") %>% collect() %>% .[["N_FILTERED_SPE"]] %>% max
min_filter_spe_ctrl <- spe_all %>% filter(FILTER == "Ctrl") %>% collect() %>% .[["N_FILTERED_SPE"]] %>% min

max_filter_spe_other <- spe_all %>% filter(FILTER == "Transcript relevance" | FILTER == "Union" | FILTER ==  "Frequence") %>% collect() %>% .[["N_FILTERED_SPE"]] %>% max


```


Comme on pouvait s'y attendre, ces six filtres ont un pouvoir discriminant extrêmement différent (**Figure :** \@ref(fig:plotcomparefilter)). En effet, tandis que le filtre "Transcript relevance" (filtre n°4) éliminer en moyenne `r mean_filter_tr` % des variants de chaque individu tandis que le filtre "Variant impact" (filtre n° 3) élimine jusqu'à `r max_filter_impact` % de ces mêmes variants (**Figure :** \@ref(fig:plotcomparefilter) - **A**). Cette différence n'est pas surprenante. En effet, comme nous l'avions vu plus tôt, les variants de la catégorie VEP MODIFIER  qui regroupe entre autres les variants chevauchant les séquences UTRs et introniques (**Table :**  ) représentent en moyenne ... % des variants de nos patients (**Figure :** \@ref(fig:plotvarannotation) - **A**). Ceux-ci étant tous filtrés, on s'attendait donc à une valeur aussi élevée. On peut également constater l'importance de la cohorte contrôle qui, je le rappelle, permet de filtrer l'ensemble des variants homozygotes observés en son sein, puisque ce filtre permet retirer entre `r min_filter_ctrl` et `r max_filter_ctrl`% des variants de chaque individus (**Figure :** \@ref(fig:plotvarannotation) - **A**).      

Cependant, regarder uniquement le pourcentage de variants filtrés par chaque filtre révèle une information partielle. En effet, dans ce cas de figure, on observe la quantité de variant éliminé par chaque filtre indépendamment les uns des autres. Ainsi, un même variant peut donc être filtrer par plusieurs filtres. Dès lors, il faut également analyser la quantité de variants filtrés **spécifiquement** par chaque filtre. Ainsi, on peut constater que le classement des filtres en fonctions de leur stringeance reste quasi identique (**Figure :** \@ref(fig:plotcomparefilter) - **B**) il est tout de même intéressant de noter que désormais le filtre "Variant impact" apparait moins efficace que les filtres "Ctrl" et "Genotype" en filtrant spécifiquement une moyenne de `r mean_filter_spe_impact` variants par individu contre `r mean_filter_spe_geno` pour le filtre génotype et `r mean_filter_spe_ctrl` pour le filtre "Ctrl". Ainsi, ce dernier devient celui filtrant spécifiquement le plus de variants avec entre `r min_filter_spe_ctrl` et `r max_filter_spe_ctrl` variants spécifiquement filtrés par patients confirmant ainsi l'importance de ce filtre dans nos analyses. Aussi, les filtres "Transcript relevance", "Union" et "Frequency" apparaissent désormais comme étant anecdotiques en comparaison aux trois autres filtres puisqu'ils filtrent au maximum `r max_filter_spe_other` variants spécifiques (**Figure :** \@ref(fig:plotcomparefilter) - **B**).  

\newpage


```{r plotcomparefilter, fig.cap=fig_info,fig.scap=fig_name, fig.height=7, cache=TRUE}

fig_name <- "Comparaison de l'efficacité de chacun des six filtres utilisés"
fig_description_A <- "**A** : Comparaison du pourcentage de variants filtrés par chacun des six filtres indépendamment les uns des autres pour chaque patient (représenté par les points. Dès lors, un même variants peut être filtré par plusieurs filtres"
fig_description_B <- "**B** : Comparaison du nombre de variant filtrés spécifiquement par chacun des filtres. Ici, un variant ne peut-être filtré que par un seul filtre"
fig_description <- paste(fig_description_A, fig_description_B, sep = ". ")
fig_info <- paste0(fig_name, " : ", fig_description)

pA <- ggplot(filter_stat, aes(FILTER, P)) + 
  geom_boxplot(fill = "firebrick3", outlier.size = -1) + 
  scale_x_discrete(limits = c("Transcript relevance","Union","Frequence","Genotype","Ctrl","Variant impact")) + 
  geom_jitter(position=position_jitter(0.3)) +
  ylab("% of filtered variants") + 
  xlab("") +
  scale_y_continuous(labels = percent) 

pB <- ggplot(spe_all, aes(FILTER, N_FILTERED_SPE)) + 
  geom_boxplot(fill = "firebrick3", outlier.size = -1) + 
  geom_jitter(position=position_jitter(0.3)) +
  ylab("Nb of filtered variants") + 
  xlab("") +
  scale_x_discrete(limits = c("Transcript relevance","Union","Frequence","Genotype","Ctrl","Variant impact")) 
  # facet_wrap(~factor(FILTER, levels = c("Transcript relevance","Union","Frequence","Genotype","Ctrl","Variant impact")), scales = "free")

plot_grid(pA,pB, labels = c("A","B"), ncol = 1)

```

\newpage

```{r remaininggense}

df_remaining_gene <- df_filter_fam %>% group_by(FAM) %>% distinct(SYMBOL) %>% 
  mutate(CAUSAL = if_else(FAM == "AZ", "SPINK2", 
                          if_else(FAM == "FF","PLCZ1",
                                  if_else(FAM == "MMAF2","DNAH1", 
                                          if_else(FAM == "MMAF4", "TGIF2?", "???")))),
         FIND_CAUSAL = if_else(CAUSAL == "???","No",
                               if_else(grepl("[?]", perl = TRUE, CAUSAL),"Maybe","Yes"))) %>%
  rename(Familly = FAM)

n_gene_az <- df_remaining_gene %>% filter(Familly == "AZ") %>% nrow
n_gene_mmaf1 <- df_remaining_gene %>% filter(Familly == "MMAF1") %>% nrow
n_gene_mmaf2 <- df_remaining_gene %>% filter(Familly == "MMAF2") %>% nrow
n_gene_mmaf3 <- df_remaining_gene %>% filter(Familly == "MMAF3") %>% nrow

```

Après avoir appliqué l'ensemble de ces filtres, seuls quelques variants subsistent nous permettant d'obtenir une liste de gènes restreinte pour chaque famille (**Table : **\@ref(tab:tablegene)) et ainsi de tirer des conclusions quant au variant responsable du phénotype. 

1. **Famille AZ** : Parmi les `r n_gene_az` gènes restant pour cette famille, *SPINK2* est apparu comme étant un candidat évident. Notamment son expression étant spécifique au testicule tandis que celle de *GUF1* est ubiquitaire (TODO fig). De plus, des mutations du gène *Spink2* chez la souris avait déjà été identifiée comme induisant des défauts de la spermatogenèse [@Lee2011].  
```{r}

# fifure exp SPINK2 et guf1

```
2. **Famille FF** : Pour cette famille, le gène *PLC*$\zeta 1$ a passé l'ensemble des filtres. Nos connaissances sur la fonction de se gène et notamment son rôle dans l'activation ovocytaire (TODO: REF) on fait de ce gène le candidat idéal pour expliquer le phénotype de ces deux frères.      
3. **Famille MMAF1** : L'analyse bibliographique des `r n_gene_mmaf1` gènes ayant passé l'ensemble des filtres n'a ici pu nous permettre de d'affirmer que l'un de ces gènes étaient responsable du phénotype MMAF de ces 2 frères.  
4. **Famille MMAF2** : À l'issue des filtres, `r n_gene_mmaf2` gènes ressortaient chez ces deux frères : *MYH11* et *DNAH1*. Or, notre équipe ayant déjà, il y a quelques années établit le lien entre des mutations du gène *DNAH1* et le syndrome MMAF [@BenKhelifa2014] ce gène s'est révélé être un candidat idéal pour expliquer le phénotype de ces 2 frères. De plus, l'implication de *MYH11* dans le phénotype de dissection aortique [@Imai2015] l'ont écarté des candidats pour le phénotype MMAF.    
5. **Famille MMAF3** : Comme pour les gènes de la famille MMAF2, l'analyse bibliographique des `r n_gene_mmaf3` gènes ayant ici passé les filtres de même que l'étude de leurs expressions ne nous a pas permis de conclure que l'un d'entre eux étaient responsable du phénotype MMAF de ces 2 frères.  
6. **Famille MMAF4** : Seul le gène *TGIF2* a passé l'ensemble des filtres pour la famille MMAF4. L'expression ubiquitaire de ce gène n'en font pas un candidat idéal. Cependant une étude de 2011 effectuée sur le wallaby décrit que la protéine TGIF2 localise spécifiquement dans le cytoplasme du spermatide, ainsi que dans le corps résiduel et la pièce intermédiaire du flagelle du spermatozoïde mature [@Hu2011]. Ces données pourraient corréler avec le phénotype MMAF de ces 3 frères.    

\newpage

```{r tablegene}

df_genes <- df_remaining_gene %>% select(Familly, SYMBOL) %>% 
  mutate(ind = row_number()) %>%
  spread(Familly, SYMBOL, fill = " ") %>% 
  select(-ind)

kable(df_genes, 
      booktabs = TRUE,
      longtable = TRUE,
      caption = "Liste des gènes ayant passé l'ensemble des filtres pour chaque famille")

# pander::pander(df_genes,
#                justify = 'left',
#                caption = "(\\#tab:tablegene) Liste des gènes ayant passé l'ensemble des filtres pour chaque famille")

```

<!-- \newpage  -->

#### Discussion  

```{r}

df_causal <- group_by(df_remaining_gene, Familly, FIND_CAUSAL, CAUSAL) %>%
  summarise(N = n())

nb_fam <- df_causal %>% nrow
nb_found <- df_causal %>% filter(!grepl("[?]", CAUSAL)) %>% nrow
nb_maybe <- df_causal %>% filter(CAUSAL != "???" & grepl("[?]", CAUSAL)) %>% nrow
nb_not_found <- df_causal %>% filter(CAUSAL == "???") %>% nrow
percent_found <- (nb_found / nb_fam) %>% round(3) * 100


```


L'analyse de ces `r nb_fam` familles nous a permis de mettre en évidence l'efficacité de notre pipeline d'analyse puisque pour `r nb_found`  d'entre elles (soit `r percent_found`%) le variant causal a pu être identifié avec certitude (**Figure : **\@ref(fig:plotremaininggenes)) et les résultats publiés dans trois revus dont je suis co-auteur :  

1. **Famille AZ** : [**SPINK2 deficiency causes infertility by inducing sperm defects in heterozygotes and azoospermia in homozygotes**](#spink2) : Dans cet article j'ai effectué non seulement l'intégralité des analyses bioinformatiques des données d'exomes de deux frères infertiles présentant un phénotype d'azoospermie mais aussi séquencer en Sanger les séquences codantes du gène *SPINK2* pour une partie des 611 individus analyser ainsi que contribué à l'extraction de l'ARN testiculaire des souris pour l'analyse fonctionnelle du gène *Spink2* sur le modèle murin.  
2. **Famille FF** : [**Homozygous mutation of PLCZ1 leads to defective human oocyte activation and infertility that is not rescued by the WW-binding protein PAWP**](#plcz) : Dans cet article j'ai, effectué l'intégralité des analyses bioinformatiques des données d'exomes effectués sur deux frères infertiles présentant des échecs de fécondation.    
3. **Famille MMAF2** : [**Whole-exome sequencing of familial cases of multiple morphological abnormalities of the sperm flagella (MMAF) reveals new DNAH1 mutations**](#famdnah1) : Dans cet article j'ai, comme précédemment, effectué l'ensemble des analyses bioinformatiques des données d'exomes effectués sur deux frères infertiles présentant des échecs de fécondation.  

Pour une d'entre elle, un candidat potentiel a pu être mis en évidence avec le gène *TGIF2* et notre équipe travaille actuellement sur la caractérisation de ce gène afin de savoir s'il peut effectivement expliquer le phénotype MMAF de cette famille (**Figure : **\@ref(fig:plotremaininggenes)).     

Pour les `r nb_not_found` familles restantes, aucun variant n'a pu pour l'instant expliquer leur phénotype. L'explication la plus vraisemblable est que le variant ait été filtré par l'un de nos six filtres, probablement celui consistant à filtrer l'ensemble des variants hétérozygotes. En effet, l'hypothèse d'un variant causal homozygote était extrêmement crédible pour les familles AZ, FF et MMAF2 étant donné l'historique consanguin de ces `r nb_found` familles dont les parents sont à chaque fois apparentés. En revanche rien ne laisse supposé une telle chose pour les familles restantes. Cependant, le filtre des variants hétérozygotes pour l'ensemble des patients de ces `r nb_not_found + nb_maybe` familles a été maintenu en première intention afin de faciliter les analyses en réduisant au maximum le nombre de variant. Au vus des résultats il apparait clair que les variants responsablent de leur phénotype aient été filtrés pour au moins `r nb_not_found` de ces familles. Dès lors, l'ensemble des analyses effectuées lors de l'étape de filtrage doivent être refaites en changeant les paramètres de filtrage. Cette fois-ci, les variants hétérozygotes seront conservés et les gènes sur lesquels au moins deux variants hétérozygotes seront recensés seront analysés en priorité. En effet, bien que les analyses exomiques nous fournissent en l'état pas d'informations suffisante pour savoir si ces deux variants sont présent sur le même allèle ou bien sur deux allèles différents, cela pourrait-être la signature de variants hétérozygotes composites. C'est donc sur ces analyses que se concentre actuellement notre équipe.    


```{r plotremaininggenes, fig.cap=fig_info,fig.scap=fig_name, cache=TRUE}

fig_name <- "Nombre de gènes passant l'ensemble des filtres par famille"
fig_description <- "Chaque barre représente une des familles analysées. La hauteur de cette barre correspond au nombre de gènes ayant passé l'ensemble des filtres pour chaque famille. Les barres vertes caractérisent les familles pour lesquelles le gène responsable de la pathologie a été identifié parmi la liste de gène (dans ce cas le symbole du gène est écrit au-dessus de la barre). La barre orange caractérise la famille pour laquelle un candidat potentiel a été identifié (le symbole du gène est écrit au-dessus suivit d'un \"?\"). Les barres rouges indiquent qu'aucun des gènes ayant passé les filtres pour ne semble expliquer le phénotype (dans ce cas il est écrit \"???\" au-dessus de la barre)"
fig_info <- paste(fig_name, " : ", fig_description)

ggplot(df_causal, aes(Familly, N)) +
  geom_bar(stat = "identity", aes(fill = FIND_CAUSAL)) +
  scale_y_continuous(limits = c(0,max(df_causal$N) + 1), breaks = seq(0,max(df_causal$N) + 1,2)) +
  geom_text(aes(label = CAUSAL), position = position_dodge(width = .9), vjust = -.25) +
  ylab("Nb of remaining genes after all filtering") +
  theme(axis.title.x=element_blank()) +
  scale_fill_manual(name = "Is the causal variant found?", limits = c("Yes", "Maybe", "No"), values = c("chartreuse3", "darkorange1", "firebrick3")) + 
  theme(legend.position = "bottom")

```

```{r cleanpart1, include=FALSE, warning=FALSE}

rm(df_annotate, df_ctrl_all)
gc()

```


\newpage


### Etude d’une large cohorte de patients MMAF  {#cohortemmah}  

#### Description de la cohorte  

```{r cohort, cache=TRUE}

run_mmaf_fam <- c("Ghs56","Ghs58","Ghs62","Ghs130","Ghs63","Ghs119","Ghs59","Ghs60","Ghs61")

df_runs_mmaf <- fread("data/exome_runs.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, drop = c(2,3,4,10:16), data.table = FALSE) %>%
  rename(RUN = `Magic ID`, PHENOTYPE = Pathologie, DATE = Date) %>%
  mutate(PHENOTYPE = if_else(PHENOTYPE == "Flag", "MMAF", PHENOTYPE),
         YEAR = as.numeric(str_sub(DATE, start= -4)),
         PROJECT = paste0(Project," (",YEAR, ")")) %>%
  filter(!(RUN %in% run_mmaf_fam),
         PHENOTYPE == "MMAF") %>%
  select(-DATE, -PHENOTYPE)

```

Historique : après avoir mis en évidence DNAH1 -> MMAF notre équipe s'est en partie spécialisé dans ce syndrome.

ainsi, entre (année) et année, notre équipe a effectué le séquençage de ... individus présentant ce phénotype afin d'en établir la cause génétique. 
parmi ces patients, la majorité provenait d'Afrique du Nord, cependant ... vfenaient de et de ...
ces séquençage ont été effectué dans ... centres diférents que sont (listes des centre de séquençage) et sur ... plateforme : liste des plateformes


```{r tabcohort}

kable(df_runs_mmaf %>% 
        select(-Model, -PROJECT) %>% 
        rename(Place = Project, Run = RUN, Year = YEAR) %>%
        group_by(Place, Year) %>% 
        summarise(`Nb of sequenced individuals` = n()) %>%
        arrange(Year),
      longtable = TRUE,
      booktabs = TRUE, 
      caption = "Liste des différents projets de séquençages effectués")

```

\newpage

#### Application de la pipeline - Résultats

```{r extradata, cache=TRUE}


df_rvis <- fread("data/RVIS_Unpublished_ExAC_May2015.txt",sep = "\t",header = TRUE,data.table = FALSE) %>%
  select(SYMBOL = CCDS_r15,SCORE = `RVIS_ExAC_0.05%(AnyPopn)`) %>%
  mutate(RVIS_PERCENTILE = percent_rank(SCORE)) %>%
  select(-SCORE) %>%
  na.omit()

df_ciliome_gene <- fread("data/ciliome.csv",sep = "\t",header = TRUE, data.table = FALSE) %>% 
  select(SYMBOL = Symbol, EVIDENCE = `Novelty category`, LOCALISATION = `Immunostaining of cilia`) %>% 
  mutate(EVIDENCE = substring(EVIDENCE, 4),
         LOCALISATION = substring(LOCALISATION, 4))

df_ctrl_mmaf <- open_ctrl("data/genotype_not_MMAF.csv", pheno = "MMAF")

```

```{r bigmmafcall, cache=TRUE}

bigmmaf_call_file <- "results/bigmmaf_call.rds"

if (!file.exists(bigmmaf_call_file)) {
  
  df_bigmmaf_call <- fread("data/genotype_MMAF.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE) %>%
    gather(RUN, CALL, starts_with("Ghs")) %>%
    filter(CALL %in% c(0, 2, 3, "b", "c"),
           !(RUN %in% run_mmaf_fam),
           !is.na(REF)) %>%
    mutate(STRAND = if_else(CALL %in% c(2:9), "DS", 
                            if_else(CALL == 0, "NS", "SS")),
      TYPE = if_else(stri_length(REF) == stri_length(ALT), "SNV", "Indel"),
           CALL = if_else(CALL == 0, "None",
                          if_else(CALL %in% c(2, "b"), "Heterozygous", "Homozygous")))
  saveRDS(df_bigmmaf_call, bigmmaf_call_file)
  
} else {
  
  df_bigmmaf_call <- readRDS(bigmmaf_call_file)

}

df_bigmmaf_call_geno <- df_bigmmaf_call %>% 
  filter(grepl("zygous", CALL)) %>% 
  group_by(RUN, TYPE, CALL) %>% 
  distinct(CHR, POSITION, REF, ALT) %>%
  count() %>%
  left_join(df_runs_mmaf, by = "RUN") %>% 
  select(-(Project:Model))
                       
df_bigmmaf_call_strand <- df_bigmmaf_call %>%
  group_by(RUN, STRAND) %>%
  count() %>%
  group_by(RUN) %>%
  mutate(N_ALL_STRAND = sum(n),
         P_STRAND = n / N_ALL_STRAND) %>%
  left_join(df_runs_mmaf, by = "RUN")

df_distinct_call <- df_bigmmaf_call %>%  
  filter(grepl("zygous", CALL)) %>% 
  distinct(CHR, POSITION, REF, ALT, TYPE) %>%
  variant_join(fread("data/all_variants_vep81.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, drop = c(11,12,14:28,31:34,36:40)), mode = "left")

```

```{r varbigmmafcall, dependson="bigmmafcall", cache=TRUE}

n_distinct_var <- df_distinct_call %>% nrow %>% as.integer
n_distinct_snv <- df_distinct_call %>% filter(TYPE == "SNV") %>% nrow %>% as.integer
n_distinct_indel <- df_distinct_call %>% filter(TYPE == "Indel") %>% nrow %>% as.integer

n_mean_var <- df_bigmmaf_call_geno %>% group_by(RUN) %>% summarise(N = sum(n)) %>% collect() %>% .[["N"]] %>% mean %>% round(0) %>% as.integer
n_mean_snv <- df_bigmmaf_call_geno %>% filter(TYPE == "SNV") %>% group_by(RUN) %>% summarise(N = sum(n)) %>% collect() %>% .[["N"]] %>% mean %>% round(0) %>% as.integer
n_mean_indel <- df_bigmmaf_call_geno %>% filter(TYPE == "Indel") %>% group_by(RUN) %>% summarise(N = sum(n)) %>% collect() %>% .[["N"]] %>% mean %>% round(0) %>% as.integer

n_mean_homo <- df_bigmmaf_call_geno %>% filter(CALL == "Homozygous") %>% group_by(RUN) %>% summarise(N = sum(n)) %>% collect() %>% .[["N"]] %>% mean %>% round(0) %>% as.integer
p_mean_homo <- (n_mean_homo / n_mean_var) %>% as.integer %>% round(3) * 100 

```

Après avoir appelé les variants de nos ... patients, nous avons obtenu une total de `r n_distinct_var` variants différents comprenant `r n_distinct_snv` SNVs et `r n_distinct_indel`. Ces variants étant répartit entre chaque patients qui portaient environs chacun `r n_mean_snv` SNV et `r n_mean_indel` indels dont `r p_mean_homo` % étaient homozygote. Comme on peut le voir, la proportion de chaque appel est relativement homogène lorsque l'on compare les patients ayant été séquencés dans le même centre la même année. Cependant, il est possible de noter de grandes disparités lorsque l'on compare les données provenant de différents centres ou bien du même centre avec plusieurs années de différences. Ces écarts peuvent-être causés par plusieurs facteur, tel que les différents kits de capture d'exons qui on put être utilisés puisque ... (todo lister les différents kit de capture dans une table) en revanche nous pouvons écarté un effet dus à la platforme de séquençage ou encore le modèle de séquenceur puisque tout ces projets ont été réalisés sur des Illumina HiSeq2000 (**Table : **\@ref(tab:tabcohort)) (**Figure : **\@ref(fig:plotbigmmafcall) - **A**).  

Le même constat peut être effectué lorsque l'on compare la qualité des appels puisque plus les projets de séquençage s'avèrent être récent, plus la proportion d'appel *Single Strand* s'avère être faible tandis que la proportion d'appel *Double Strand* (DS) est élevée. Ceci est une bonne chose, car, bien que ces deux appels soient conservés dans les analyses ulterieures, les appels DS sont de meilleur qualité que les appels SS. Cette augmentation des appels DS au cours du temps pourrait s'expliquer par une amélioration des protocole de séquençage qinsi que des kit de capture. En revanche cela est à pondérer avec le taux croissant d'appels *No-strand* (NS) au fur et à mesure des années pour atteindre environs ... % en (...Année) avec un projet réalisé au Génoscope. Ces derniers appels étant systématiquement filtrés, ils n'altèreront en rien les résultats obtenus en aval ormis le fait qu'ils réduisent la quantité des données utilisées (**Figure : **\@ref(fig:plotbigmmafcall) - **B** et **C**).

\newpage

```{r plotbigmmafcall, fig.cap=fig_info,fig.scap=fig_name, fig.height=7.6, cache=TRUE}

fig_name <- "Résultats de l'appel des variants par individus et par projet de séquençage"
fig_description_general <- "Chaque couleur définit un projet de séquençage caractérisé par un centre de séquençage et une année"
fig_description_A <- "**A** : Quantification pour chaque individus (représentés par les barres) du nombre de variants (SNVs et Indels) appelés homozygotes et hétérozygotes"
fig_description_B <- "**B** : Quantification des appels *Double Strand* (DS), *Single Strand* (SS) et *No strand* (NS) pour chaque projet de séquençage"
fig_description_C <- "**C** : Même chose en pourcentage"
fig_description <- paste(fig_description_general, fig_description_A, fig_description_B, fig_description_C, sep = ". ")
fig_info <- paste0(fig_name, " : ", fig_description)

pA <- ggplot(df_bigmmaf_call_geno, aes(reorder(RUN, YEAR), n)) + 
  geom_bar(stat = "identity", aes(fill = PROJECT)) + 
  facet_grid(TYPE~CALL, scales = "free") +
  scale_fill_brewer(palette = "Set1", guide = "none") +
  ylab("Nb of called variants") + 
  theme(axis.title.x = element_blank(), 
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

pB <- ggplot(df_bigmmaf_call_strand, aes(reorder(PROJECT, YEAR), n)) + 
  geom_boxplot(outlier.size = -1, aes(fill = PROJECT)) + 
  facet_wrap(~factor(STRAND, levels = c("DS", "SS", "NS")), scales = "free") +
  ylab("Nb of call") + 
  scale_x_discrete(limits = c("Strasbourg (2012)", "MountSinai (2012)", "Genoscope (2013)", "Genoscope (2014)", "Genoscope (2015)")) +
   scale_fill_brewer(palette = "Set1", guide = "none") +
  theme(axis.title.x = element_blank(), 
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

pC <- ggplot(df_bigmmaf_call_strand, aes(reorder(PROJECT, YEAR), P_STRAND)) + 
  geom_boxplot(outlier.size = -1, aes(fill = PROJECT)) + 
  facet_wrap(~factor(STRAND, levels = c("DS", "SS", "NS")), scales = "free") +
  scale_x_discrete(limits = c("Strasbourg (2012)", "MountSinai (2012)", "Genoscope (2013)", "Genoscope (2014)", "Genoscope (2015)")) +
  scale_fill_brewer(palette = "Set1", name = "Sequencing project", breaks = c("Strasbourg (2012)", "MountSinai (2012)", "Genoscope (2013)", "Genoscope (2014)", "Genoscope (2015)")) +
  ylab("% of call") + 
  scale_y_continuous(labels = percent) +
  theme(legend.position = "bottom",
        legend.title = element_blank(),
        axis.title.x = element_blank(), 
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

row2 <- plot_grid(pB,pC, ncol = 1, rel_heights = c(.43,.57), labels = c("B","C"))


plot_grid(pA,row2, ncol = 1, rel_heights = c(.45,.55), labels = c("A",""))

```

\newpage

#### Analyse des listes de gènes  

```{r filterbigmmaf, cache=TRUE}

maf_cutoff <- .01

df_distinct_filter <- df_distinct_call %>%   
  filter_frequence(cutoff = maf_cutoff) %>%
  variant_join(df_ctrl_mmaf, mode = "anti") %>%
  filter(Consequence != "synonymous_variant",
         IMPACT != "MODIFIER",
         !(grepl("tolerated", SIFT) & grepl("benign", PolyPhen)),
         !grepl("NMD_transcript_variant", Consequence),
         !grepl("non_coding_transcript_variant", Consequence)) %>%
  left_join(df_rvis, by = "SYMBOL") %>%
  left_join(df_ciliome_gene, by = "SYMBOL")

df_bigmmaf_filter <- df_bigmmaf_call %>%  
  select(-STRAND) %>%
  filter_genotype(het = FALSE) %>% 
  variant_join(df_distinct_filter, mode = "inner") %>% 
  select(-Allele)

df_bigmmaf_filter_stat <- df_bigmmaf_filter %>% 
  group_by(RUN) %>%
  mutate(N_GENE = n_distinct(SYMBOL)) %>%
  group_by(RUN, TYPE, N_GENE) %>%
  distinct(CHR, POSITION, REF, ALT) %>%
  summarise(N_VAR_PER_TYPE = n()) %>%
  group_by(RUN) %>%
  mutate(N_VAR_TOT = sum(N_VAR_PER_TYPE)) %>%
  right_join(df_runs_mmaf, by = "RUN") 
  

df_bigmmaf_genes <- df_bigmmaf_filter %>% select(SYMBOL, RUN) %>% group_by(SYMBOL) %>% distinct(RUN) %>% mutate(N_RUN = n()) %>% filter(N_RUN > 1) 
df_bigmmaf_genes_distinct <- df_bigmmaf_genes %>% distinct(N_RUN)
df_bigmmaf_genes_resume <- df_bigmmaf_genes_distinct %>% distinct(N_RUN) %>% group_by(N_RUN) %>% summarise(N_GENE = n()) 

```


```{r filterhetbigmmaf, cache=TRUE}

df_bigmmaf_filter_het <- df_bigmmaf_call %>% 
  select(-STRAND) %>% 
  filter_genotype(homo = FALSE) %>% 
  variant_join(df_distinct_filter, mode = "inner") %>% 
  select(-Allele) %>%
  group_by(RUN, SYMBOL, Feature) %>%
  mutate(N_VAR_PER_RUN_PER_GENE = n()) %>% 
  filter(N_VAR_PER_RUN_PER_GENE > 1) %>% 
  group_by(SYMBOL) %>%
  mutate(N_RUN_PER_GENE = n_distinct(RUN))


# 
# 
# df_bigmmaf_filter_het %>% filter(SYMBOL == "DNAH1" |
#                                    SYMBOL == "WDR96" |
#                                    SYMBOL == "WDR52" |
#                                    SYMBOL == "FSIP2") %>% 
#   group_by(RUN, SYMBOL, Consequence) %>%
#   distinct(CHR, POSITION, REF, ALT, CALL) %>% View 
# 

```


```{r cleanbigmmafcall, include=FALSE, warning=FALSE}

rm(df_distinct_call, df_distinct_filter)
# rm(df_distinct_call)
rm(df_bigmmaf_call)
gc()

```

```{r varfilterbigmmaf, cache=TRUE}

n_distinct_var <- df_bigmmaf_filter %>% ungroup() %>% distinct(CHR, POSITION, REF, ALT) %>% nrow
n_distinct_snv <- df_bigmmaf_filter %>% ungroup() %>% filter(TYPE == "SNV") %>% distinct(CHR, POSITION, REF, ALT) %>% nrow
n_distinct_indel <- df_bigmmaf_filter %>% ungroup() %>% filter(TYPE == "Indel") %>% ungroup() %>% distinct(CHR, POSITION, REF, ALT) %>% nrow
n_distinct_gene <- df_bigmmaf_filter %>% ungroup() %>% distinct(SYMBOL) %>% nrow

n_min_var <- df_bigmmaf_filter_stat %>% collect() %>% .[["N_VAR_TOT"]] %>% min
n_max_var <- df_bigmmaf_filter_stat %>% collect() %>% .[["N_VAR_TOT"]] %>% max

n_mean_indel <- df_bigmmaf_filter_stat %>% filter(TYPE == "Indel") %>% collect() %>% .[["N_VAR_PER_TYPE"]] %>% mean %>% round(0)
n_mean_snv <- df_bigmmaf_filter_stat %>% filter(TYPE == "SNV") %>% collect() %>% .[["N_VAR_PER_TYPE"]] %>% mean %>% round(0)

n_min_gene <- df_bigmmaf_filter_stat %>% collect() %>% .[["N_GENE"]] %>% min
n_max_gene <- df_bigmmaf_filter_stat %>% collect() %>% .[["N_GENE"]] %>% max

```

```{r}

tab_gene <- function(df, gene) {
  
  tab_gene <- df %>% 
    filter(SYMBOL == gene) %>% 
    mutate(VARIANT = paste(CHR,POSITION,REF,ALT, sep = "-"),
           Consequence = sapply(strsplit(Consequence, "_", fixed = TRUE),"[[",1)) %>%
    distinct(RUN, VARIANT, CALL, Consequence, SYMBOL) %>% 
    arrange(desc(CALL), RUN)
  
  tab_gene
}

tabdnah1 <- df_bigmmaf_filter %>% bind_rows(df_bigmmaf_filter_het) %>% tab_gene("DNAH1")
tabwdr96 <- df_bigmmaf_filter %>% bind_rows(df_bigmmaf_filter_het) %>% tab_gene("WDR96")
tabwdr52 <- df_bigmmaf_filter %>% bind_rows(df_bigmmaf_filter_het) %>% tab_gene("WDR52")
tabfsip2 <- df_bigmmaf_filter %>% bind_rows(df_bigmmaf_filter_het) %>% tab_gene("FSIP2")

run_homo_dnah1 <- tabdnah1 %>% filter(CALL == "Homozygous") %>% ungroup() %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
run_homo_wdr96 <- tabwdr96 %>% filter(CALL == "Homozygous") %>% ungroup() %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
run_homo_wdr52 <- tabwdr52 %>% filter(CALL == "Homozygous") %>% ungroup() %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
run_homo_fsip2 <- tabfsip2 %>% filter(CALL == "Homozygous") %>% ungroup() %>% distinct(RUN) %>% collect() %>% .[["RUN"]]

run_het_dnah1 <- tabdnah1 %>% filter(CALL == "Heterozygous") %>% ungroup() %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
run_het_wdr96 <- tabwdr96 %>% filter(CALL == "Heterozygous") %>% ungroup() %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
run_het_wdr52 <- tabwdr52 %>% filter(CALL == "Heterozygous") %>% ungroup() %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
run_het_fsip2 <- tabfsip2 %>% filter(CALL == "Heterozygous") %>% ungroup() %>% distinct(RUN) %>% collect() %>% .[["RUN"]]

n_run_homo_dnah1 <- run_homo_dnah1 %>% length
n_run_homo_wdr96 <- run_homo_wdr96 %>% length
n_run_homo_wdr52 <- run_homo_wdr52 %>% length
n_run_homo_fsip2 <- run_homo_wdr52 %>% length

n_run_het_dnah1 <- run_het_dnah1 %>% length
n_run_het_wdr96 <- run_het_wdr96 %>% length
n_run_het_wdr52 <- run_het_wdr52 %>% length
n_run_het_fsip2 <- run_het_fsip2 %>% length

df_bigmmaf_filter_het <- df_bigmmaf_filter_het %>% filter(!(RUN %in% c(run_homo_dnah1, run_homo_wdr96, run_homo_wdr52, run_homo_fsip2)))

```

Après avoir appliqué les mêmes filtres que ceux décrit précédement à l'exception du filtre n°... Union puisqu'ici nous avons uniquement des individus non apparentés, nous avons put obtenir une liste de `r n_distinct_var` variants différents composés de `r n_distinct_snv` SNVs et `r n_distinct_indel` indels et impactant un total de `r n_distinct_gene` gènes distincts. Ces variants étant répartis sur l'ensemble de nos ... patients ceux-ci portaient en moyenne `r n_mean_snv` SNVS et `r n_mean_indel` indels, de sorte que chacun d'entre eux avaient entre `r n_min_gene` et `r n_max_gene` gènes impactés par au moins un variants (**Figure : **\@ref(fig:plotfilterbigmmaf) - **A** et **B**).  

Parmis l'ensemble de nos patients, `r n_run_homo_dnah1` révélèrent porter au moins un variant passant l'ensemble des filtres sur le gène *DNAH1*, candidat évident pour ce phénotype. Ainsi, le patient Ghs90 porte 3 variants successifs induisant 3 variation faux-sens, le patient Ghs95 porte lui un seul variant entrainant lui aussi un faux-sens et le patient Ghs122 porte un indel entrainant un décalage du cadre de lecture (**Table : **\@ref(tab:tabdnah1)).  

```{r tabdnah1}

kable(tabdnah1, 
      booktabs = TRUE,
      longtable = TRUE,
      col.names = c("Run ID","Variant coordinates", "Genotype", "Consequence", "Gene symbol"),
      caption = "liste des variants passant les filtres et chevauchant le gène *DNAH1*")

```


```{r}

n_gene_more1 <- df_bigmmaf_genes_distinct %>% filter(N_RUN > 1) %>% nrow
n_gene_2 <- df_bigmmaf_genes_distinct %>% filter(N_RUN == 2) %>% nrow
p_gene_2 <- (n_gene_2 / n_gene_more1) %>% round(2) * 100

```

Ensuite, afin de nous concentrer sur les gènes ayant le plus de risque d'être impliquer dans le phénotype MMAF, nous avons étudié en priorité ceux sur lesquels plusieurs patients portaient au moins un variant ayant passé les filtres. Ainsi, nous avons obtenu une liste de `r n_gene_more1` gènes dont `r n_gene_2` (soit `r p_gene_2` %) étaient retrouvés variants chez uniquement 2 patients (**Figure : **\@ref(fig:plotfilterbigmmaf) - **C**). 

\newpage

```{r plotfilterbigmmaf, fig.cap=fig_info,fig.scap=fig_name, fig.height=7.5, cache=TRUE}

fig_name <- "TODOOOOOOOOOOOOOOOOOO"
fig_description_general <- "Chaque couleur définit un projet de séquençage caractérisé par un centre de séquençage et une année"
fig_description_A <- "**A** : Quantification du nombre de SNVs et indels ayant passé l'ensemble des filtres pour chaque patients"
fig_description_B <- "**B** : Nombre de gènes impactés par au moins un variant ayant passé les filtres pour chaque individus représentés par les barres"
fig_description_C <- "**C** : Présentation "

fig_description <- paste(fig_description_A, fig_description_B, fig_description_C, sep = ". ")
fig_info <- paste0(fig_name, " : ", fig_description)

pA <- ggplot(df_bigmmaf_filter_stat, aes("", N_VAR_PER_TYPE)) +
  geom_boxplot(outlier.size = -1) + 
  geom_jitter(position=position_jitter(0.3)) +
  facet_wrap(~factor(TYPE, levels = c("SNV", "Indel")), scales = "free") + 
  ylab("Nb of remaining variants after filters") + 
  xlab("") + 
  coord_flip() + 
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank())

pB <- ggplot(df_bigmmaf_filter_stat %>% group_by(RUN) %>% summarise(N_GENE = mean(N_GENE)), aes(reorder(RUN, -N_GENE), N_GENE)) + 
  geom_bar(stat = "identity") + 
  ylab("Nb of remaining genes") +
  xlab("Runs") + 
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank()) 

pC <- ggplot(df_bigmmaf_genes_resume, aes(N_RUN, N_GENE)) + 
  geom_bar(stat = "identity") +
    geom_text(aes(label =  N_GENE), size = 3, position = position_dodge(width = .9), hjust = -.25) +
  # scale_x_continuous(breaks = c(2:15)) +
  scale_x_reverse( breaks=c(2:15)) + 
  coord_flip() + 
   scale_fill_brewer(palette = "Set1")

row1 <- plot_grid(pA,pB, rel_heights = c(.33,.67), ncol = 1, labels = c("A","B"))

plot_grid(row1, pC, ncol = 1, rel_heights = c(.55,.45), labels = c("","C"))

```

\newpage

L'étude de ces gènes nous a tout d'abord permis d'identifier deux gènes : le gène *WDR96* (récemment renommé *CFAP43*) et le gène *WDR52* récemment renommé *CFAP44*). Ces gènes ont respectivement été retrouvés mutés chez `r n_run_homo_wdr96` et `r n_run_homo_wdr52` patients. En plus du nombre important de patients portant une tronquante mutation sur ces gènes (**Table : **\@ref(tab:tabwdr96) et \@ref(tab:tabwdr52)), tout deux sont retrouvés comme étant sur-exprimés dans le testicule dans les bases de donnée publiques. De même, ces deux gènes avaient déjà été décrits dans la litterature comme étant impliqués dans la structure et / ou le fonctionnement du flagelle spermatique [@Ivliev2012]. Ces informations ont ainsi fait de ces deux gènes des candidats idéaux pour expliquer le phénotype de ces `r n_run_homo_wdr96 + n_run_homo_wdr52` individus.  

De même, cette étude nous a permis égallement de relever `r n_run_homo_fsip2` patients présentants des mutations dans le gènes *FSIP2* (**Table : **\@ref(tab:tabfsip2). Comme pour les gènes *WDR96* et *WDR52*, ce gène présente une forte et quasi exclusive expression testiculaire. De plus, une équipe a démontré en 2003 l'implication de ce gène dans la structure de la gaine fibreuse su flagelle spermatique [@Brown2003] faisant égallement de ce gène un excellent candidat dans l'explication du phénotype MMAF de ces patients.   

Après avoir identifié la cause génétique du phénotype MMAF de ces `r n_run_homo_dnah1 + n_run_homo_wdr96 + n_run_homo_wdr52 + n_run_homo_fsip2` patients (`r n_run_homo_dnah1` patients *DNAH1*, `r n_run_homo_wdr96` *WDR96*, `r n_run_homo_wdr52` *WDR52* et `r n_run_homo_wdr52` *FSIP2*) grâce à des variants homozygotes, nous avons chercher l'ensemble des patients pouvant être hétérozygotes composites, c'est à dire des patients portant deux allèles différents mutés sur le même gène, l'un venant de la mère, l'autre venant du père. Pour cela, nous avons recansser l'ensemble des patients portant au moins deux variants hétérozygotes différents sur un de ces 4 gènes. Il faut tout de même noter la limite de cette approche dûe au fait de la non connaissance du phasage des variants, c'est à dire qu'il nous est impossible de déterminer si les deux variants sont situés sur le même allèle ou bien sur deux allèles différents.  

Néanmoins, cette stratégie nous a permis d'identifier `r n_run_het_dnah1` nouveaux patients présentant des mutation sur le gène *DNAH1*, `r n_run_het_wdr96` sur WDR96 et `r n_run_het_fsip2` sur *FSIP2*.  

\newpage

```{r tabwdr96}

kable(tabwdr96,
      booktabs = TRUE,
      longtable = TRUE,
      col.names = c("Run ID","Variant coordinates", "Genotype", "Consequence", "Gene symbol"),
      caption = "liste des variants passant les filtres et chevauchant le gène *WDR96*")

```

```{r tabwdr52}

kable(tabwdr52,
      booktabs = TRUE,
      longtable = TRUE,
      col.names = c("Run ID","Variant coordinates", "Genotype", "Consequence", "Gene symbol"),
      caption = "liste des variants passant les filtres et chevauchant le gène *WDR52*")

```

```{r tabfsip2}

kable(tabfsip2,
      booktabs = TRUE,
      longtable = TRUE,
      col.names = c("Run ID","Variant coordinates", "Genotype", "Consequence", "Gene symbol"),
      caption = "liste des variants passant les filtres et chevauchant le gène *FSIP2*")

```

\newpage

```{r filter2n}


run_found <- c(run_homo_dnah1,run_het_dnah1, run_homo_wdr96, run_het_wdr96, run_homo_wdr52, run_het_wdr52, run_homo_fsip2, run_het_fsip2 )



df_bigmmaf_filter2 <- df_bigmmaf_filter %>% filter(!(RUN %in% run_found))
df_bigmmaf_genes2 <- df_bigmmaf_filter2 %>% select(SYMBOL, RUN) %>% group_by(SYMBOL) %>% distinct(RUN) %>% mutate(N_RUN = n()) 
df_bigmmaf_genes_distinct2 <- df_bigmmaf_genes2 %>% distinct(N_RUN)
df_bigmmaf_genes_resume2 <- df_bigmmaf_genes_distinct2 %>% distinct(N_RUN) %>% group_by(N_RUN) %>% summarise(N_GENE = n()) %>% filter(N_RUN > 1) 

n_distinct_var2 <- df_bigmmaf_filter2 %>% ungroup() %>% distinct(CHR, POSITION, REF, ALT) %>% nrow
n_distinct_gene2 <- df_bigmmaf_genes_distinct2 %>% nrow


```

Comme précédemment, la cause génétique expliquant le phénotype de ces `r n_run_homo_wdr96 + n_run_homo_wdr52 + n_run_homo_fsip2` patients ayant été identifiée, leurs données ont été retirées des analyses ulterieure réduisant ainsi nos listes à `r n_distinct_var2` variants et `r n_distinct_gene2` gènes distincts.   

#### Disscution  

L'analyse de cette cohorte de ... patients MMAF nous à la fois permis de confirmer l'importance de l'implication du gène *DNAH1* dans ce phénotype grâce à `r n_run_homo_dnah1 + n_run_het_dnah1` patients présentant des variants sur ce gène, mais aussi de mettre en évidence de nouveaux gènes impliqués dans ce phénotype. 
Ainsi, notre pipeline d'analyse a permis d'identifier la cause génétique induisant le phénotype MMAF chez ... individus de notre cohorte, soit chez ... % des individus la composant.  

Ces résultats ont permis l'écriture de ... articles dont je suis co-auteur : 

1. **Whole exome cohort study and analysis of mouse and Trypanosoma models demonstrate the importance of WDR proteins in flagellogenesis and male fertility**, *Nat Genet* (soummis) : Cette article présente nos différents résultats dans la caractérisation des gènes *WDR96* et *WDR52* ainsi que les différentes preuves de leur implication dans le phénotype MMAF.  

2. (papier DNAH1) : 

Les résultats sur le gène *FSIP2* ne sont pour l'instant pas publiés, notre équipe travaillant à l'heure actuelle à la caractérisation de ce gène.  

```{r}


# table reca gène, nb patients avec var homo, nb patients avec au moins 2 var het 

```

## Conclusion  








