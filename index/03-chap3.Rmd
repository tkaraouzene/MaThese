---
output:
  word_document: default
  html_document: default
  pdf_document: default
  classoption: landscape
---
# Mise en place d’une stratégie pour l’analyse des données exomiques – application en recherche clinique  

```{r include.packages2, include=FALSE}
# This chunk ensures that the thesisdown package is
# installed and loaded. This thesisdown package includes
# the template files for the thesis.

if(!require(devtools))
  install.packages("devtools", repos = "http://cran.rstudio.com")
if(!require(thesisdown))
  devtools::install_github("ismayc/thesisdown")

library(thesisdown)
library(knitr)
library(tidyr)
library(dplyr)
library(data.table)
library(ggplot2)
library(stringi)
library(scales)
library(cowplot)
theme_set(theme_gray()) # otherwise use cowplot default theme

source("script/manage_variants.R")
source("script/variant_filtering.R")
source("script/resume_data.R")
source("script/plot_vep_results.R")

opts_knit$set(eval.after = c("fig.cap","fig.scap"))

knitr::opts_chunk$set(fig.align='center',echo=FALSE)

```

## Intro  

Comme vu précédemment, l'émergence du séquençage haut débit, avec notamment le WGS et le WES, a révolutionné les méthodes de recherche dans le cadre d'étude phénotype-génotype en permettant de manière rapide et à moindre coup le séquençage de la quasi totalité des gènes humains. Les causes de plusieurs centaines de pathologies ont pu être identifiées grâce à ces technique depuis leur premier succès pubilié en 2010 [@Ng].  Dès lors, l'analyse des données issues du séquençage est devenu la clef dans la réussite de ces études. 

Il existe de nombreux logiciels qui à partir des variants appelés effectuent les étapes d'annotation et de filtrage. C'est par exemple le cas d'Exomiser [TODO: insert ref and Exomiser describtion] ou encore de [TODO: insert at least one other soft]. La plupart de ces logiciels fonctionnent très bien, cependant tous prennent pour point de départ des variants appelés en amont. Ils ne contrôlent donc en aucune manière les étapes d'alignement et d'appel des variants. Or, comme il a été dit plus tôt, ces deux étapes constituent la bases de l'analyse [TODO insert ref] et les résultats

<!-- Ce chapitre décrit la constitution et l’utilisation d’un pipeline d’analyse des données de séquençage exomique et son utilisation dans le cadre de la recherche de mutations entrainant différents phénotypes d’infertilité. La difficulté des études génétiques visant à identifier des gènes pathogènes vient de l’abondance de variants rares chez tout un chacun et de la difficulté d’effectuer des tris efficaces et justes pour ne retenir que la ou les mutations causales. Thomas développe un pipeline se basant sur des outils existant mais permettant d’effectuer des tris successifs efficaces et pertinents   -->


Dans ce chapitre, je détaillerai les résultats de 4 articles dont je suis coauteur :  

1. [**Whole-exome sequencing of familial cases of multiple morphological abnormalities of the sperm flagella (MMAF) reveals new DNAH1 mutations**](#famdnah1) : [todo]
2. [**Homozygous mutation of PLCZ1 leads to defective human oocyte activation and infertility that is not rescued by the WW-binding protein PAWP**](#plcz) : Dans cet article j'ai, comme précédemment, effectué l'integralité des analyses bioinformatiques des données d'exomes effectués sur deux frères infertiles présentant des échecs de fécondation.  
3. [**SPINK2 deficiency causes infertility by inducing sperm defects in heterozygotes and azoospermia in homozygotes**](#spink2) : Dans cet article j'ai effectuer non seulement l'intégralité des analyses bioinformatiques des données d'exomes de deux frères infertiles présentant un phénotype d'azoospermie mais aussi séquencer en Sanger les séquences codantes du gène *SPINK2* pour une parie des 611 individus analyser ainsi que contribué à l'extraction de l'ARN testiculaire des souris pour l'analyse fonctionelle du gène *Spink2* sur le modèle murin.  
4. [****](#cohortemmah) : [todo]

## Résultats  

```{r all_coding_variants, cache=TRUE}

maf_cutoff <- 0.01

rm_var_count <- function(df, coding, ctrl, maf_cutoff) {
  
  tot_var <- df %>% 
    select(-(CALL:STRAND)) %>%
    group_by(FAM, RUN) %>% 
    mutate(Ntot = n_distinct(CHR, POSITION, REF, ALT))
  
  rm_ctrl <- tot_var %>% 
    variant_join(ctrl, mode = "anti") %>%
    group_by(FAM, RUN) %>% 
    summarise(N_REMOVE = n_distinct(CHR, POSITION, REF, ALT),
              N_TOT = mean(Ntot),
              FILTER = "CTRL") 
  
  rm_nmd <- ungroup(tot_var) %>%
    variant_join(coding, mode = "inner") %>%
    mutate(IS_NMD = grepl("NMD_transcript_variant",Consequence)) %>%
    distinct(RUN, FAM, IS_NMD, CHR, POSITION, REF, ALT, Ntot, Feature) %>% 
    group_by(CHR, POSITION, REF, ALT, RUN) %>%
    mutate(N = n()) %>%
    filter(N == 1,
           IS_NMD == TRUE) %>%
    group_by(RUN, FAM) %>% 
    summarise(N_REMOVE = n_distinct(CHR, POSITION, REF, ALT),
              N_TOT = mean(Ntot),
              FILTER = "NMD")
  
  rm_freq <- tot_var %>%
    variant_join(coding, mode = "inner") %>%
    filter_frequence(cutoff = maf_cutoff) %>%
    group_by(FAM, RUN) %>% 
    summarise(N_REMOVE = n_distinct(CHR, POSITION, REF, ALT),
              N_TOT = mean(Ntot),
              FILTER = "FREQ")
  
  rm_impact <- tot_var %>%
    variant_join(coding, mode = "inner") %>%
    group_by(FAM, RUN) %>%
    filter(Consequence != "synonymous_variant",     # Filter variant considering their impact on transcript
           Consequence != "5_prime_UTR_variant",
           Consequence != "3_prime_UTR_variant",
           !(grepl("tolerated", SIFT) & grepl("benign", PolyPhen))) %>%
    group_by(FAM, RUN) %>% 
    summarise(N_REMOVE = n_distinct(CHR, POSITION, REF, ALT),
              N_TOT = mean(Ntot),
              FILTER = "IMPACT")
  
  rm_genotype <- tot_var %>% 
    filter_genotype(homo = FALSE) %>% # filter homo var to know how many het are filtered
    group_by(FAM, RUN) %>% 
    summarise(N_REMOVE = n_distinct(CHR, POSITION, REF, ALT),
              N_TOT = mean(Ntot),
              FILTER = "GENOTYPE") 
    
  rbind(rm_genotype, rm_ctrl, rm_nmd, rm_impact, rm_freq)
  
}


```

```{r allruns}


df_runs <- fread("data/exome_runs.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, data.table = FALSE)

resume_pheno <- df_runs %>% 
  ungroup() %>%
  rename(Phenotype = Pathologie) %>%
  filter(Phenotype != "TVPC") %>%
  group_by(Phenotype) %>% 
  summarise(N_per_Patho = n()) %>% 
  spread(Phenotype, N_per_Patho) %>% 
  rename(Azoospermia = Azoo, 
         MMAF = Flag, 
         `Fertilization failure` = Fert_fail, 
         Globozoospermia = Globo, 
         Macrozoospermia = Macro,
         `Oocyte defect` = Ovo,
         Healthy = CTRL) %>% 
  gather(Phenotype,`Nb of individuals`, Azoospermia:`Oocyte defect`)


resume_tot <- resume_pheno %>% 
  ungroup() %>% 
  summarise(N_tot = sum(`Nb of individuals`),
            N_pheno = n_distinct(Phenotype) - 1)

n_tot_runs <- resume_tot %>% collect() %>% .[["N_tot"]]
n_pheno <- resume_tot %>% collect() %>% .[["N_pheno"]]

```


### Description de la pipeline  

Notre pipeline d'analyse effectue l'ensemble des étapes allant de l'alignement des données jusqu'au filtrage des variants  

1. **L'alignement** : L'alignement des *reads* le long du génome de référence est effectué par le logiciel MAGIC [@Su2014]. Celui-ci l'intégralité pour l'ensemble des analyses en aval l'ensemble des *reads* dupliqués et / ou s'alignant à plusieurs zone du génome. Au cours de cette étape, MAGIC va produire également quatre comptages pour chaque position couverte du génome : R+, V+, R- et V- :  
    a. **R+ et R-** : Ces deux comptages correspondent au nombres de *reads* *forward* (+) et *reverse* (-) sur lesquels est observé l'allere de **référence** (R) à une position donnée.  
    b. **V+ et V-** : À l'inverse de R+ et R-, ces comptages correspondent au nombres de *reads* *forward* et *reverse* sur lesquels est observé un allele de **variant** (V) à une position donnée.  
2. **L'appel des variants** : Comme nous l'avons vu plus [tôt](#varcall), il est fortement conseillé d'effectuer l'appel des variants en tenant compte de l'aligneur choisi [@Nielsen2011, @DePristo2011, @Lunter2011]. C'est pourquoi, nous avons conçu notre propre algorithme d'appel des variants spécialement conçu pour l'analyse des données de MAGIC. Ainsi, l'appel des variants sera directement basé sur les quatre comptages vu précédement. Tout d'abord, les positions ayant une couverture < 10 sur l'un des deux *strands* sera considérée comme de faible qualité, celles aynant une couverture < 10 sur les deux *strands* seront exclus. Ensuite pour chaque variant, des appels indépendant seront effectués pour chaque *strand*. L'appel final sera une synthèse de ces deux appels où seul les cas où ces deux appels sont concordants seront considérés comme de bone qualité.    
3. **L'annotation** : Chaque variant retenu sera ensuite annoté tout d'abord par le logiciel *variant effect predictor* (VEP) [@McLaren2016] qui nous indiquera pour chaque variant la conséquence que celui-ci aura sur la séquence codante de l'ensemble des transcrits Ensembl qu'il chevauche (**Figure : **\@ref(fig:figvepcsq)) (**Table : **\@ref(tab:tabvepcsq)). Suite à cela nous ajoutons, lorsque celle-ci est disponible, la fréquence du variant dans les bases de données ExAC [@Lek2016], ESP600 [TODO] et 1000Genomes [TODO] donnant ainsi une estimation de sa fréquence dans la population générale. De même, la particularité de cette pipeline est qu'elle conserve l'ensemble des variants identifiés dans les études effectués précédement permettant d'ajouter aux annotations la fréquences d'un variant chez les individus déjà séquencé et donc la fréquence d'un variant dans chaque phénotype étudié créant ainsi une base de données interne qui pourra servir de contrôle dans les études ulterieur.  

```{r figvepcsq, fig.cap=fig.info,fig.scap=fig.name, out.extra="scale=.9"}


fig.name <- "Listes des différentes conséquences prédites par VEP et leurs positionement sur le transcrit"
fig.description <- ""
fig.from <- "[VEP site](http://www.ensembl.org/info/genome/variation/consequences.jpg)"
fig.info <- paste0(fig.name," d'après ",fig.from)

include_graphics(path = "figure/vep_csq.jpg")


```

4. **Le filtrage des variants** : L'étape de filtrage est extremement importante si l'on souhaite analyser de manière efficace les données provenant de WES. C'est pourquoi elle occupe une place importante dans notre pipeline. L'intégralité des paramètres de cette étape peuvent être modifier par l'utilisateur de sorte à faire correspondre les critères de filtre aux bsoins de l'étude. Afin de rendre son utilisation le plus efficace possibe, nous avons souhaité définir des paramètres par défauts pertinent dans la plupart des étude de séquençage exomique de sorte que à moins que le contraire ne soit spécifié, seul les variants impactant les transcrits codant pour une protéine sont conservés. De même les variants synonymes ou affectant les séquences UTRs sont filtrés ainsi que les variants ayant une fréquence $\ge$ 1% dans les bases dans l'une des bases données (ExAC, ESP6500 ou 1KH). Aussi, pour un phénotype donné, l'ensemble des variants observés chez les individus étudiés présentant un phénotype différent sont de même enlevés de la liste finale.   

<!-- \newpage         -->

```{r tabvepcsq}


# tab.name <- "Liste des conséquences prédites par VEP avec leur description et impact associée (trouver comment la faire tenir"
# 
# df_vep_csq <-  fread("data/vep_csq.csv", sep = "\t", header = TRUE, showProgress = FALSE, data.table = FALSE, verbose = FALSE) %>% 
#   select(Consequence = `Display term`,
#          Description = `SO description`,
#          Impact = IMPACT)
# 
# kable(df_vep_csq, 
#       caption = tab.name, 
#       booktabs = TRUE)

```

<!-- \newpage        -->

### Utilisation de la pipeline dans des cas familiaux :  

#### Description des familles 

```{r}

run_az_fam <- c("Ghs44","Ghs45")
run_ff_fam <- c("Ghs113","Ghs117")
run_mmaf_fam <- c("Ghs56","Ghs58","Ghs62","Ghs130","Ghs63","Ghs119","Ghs59","Ghs60","Ghs61")

run_all_fam <- c(run_az_fam, run_ff_fam, run_mmaf_fam)

df_seq <- data_frame(FAM = c("Az","FF","MMAF1","MMAF2","MMAF3","MMAF4"),
                     NB = c(2,2,2,2,2,3),
                     PHENOTYPE = c("Azoospermia","Fertilization failure","MMAF","MMAF","MMAF","MMAF"),
                     YEAR = c(2012,2014,2014,2014,2014,2014),
                     PLATFORM = c("Illumina HiSeq2000","Illumina HiSeq2000","Illumina HiSeq2000","Illumina HiSeq2000","Illumina HiSeq2000","Illumina HiSeq2000"),
                     PLACE = c("Mount Sinai Institut","Genoscope (Evry)","Genoscope (Evry)","Genoscope (Evry)","Genoscope (Evry)","Genoscope (Evry)"))


nb_fam <- df_seq %>% summarise(N_FAM = n_distinct(FAM)) %>% collect() %>% .[["N_FAM"]] 
nb_pheno <- df_seq %>% summarise(N_PHENO = n_distinct(PHENOTYPE)) %>% collect() %>% .[["N_PHENO"]] 

```

Dans cette partie, je me concentre sur l'analyse bioinformatique des résultats des séquençages exomiques effectués entre `r min(df_seq$YEAR)` et `r max(df_seq$YEAR)` de `r sum(df_seq$NB)` individus infertiles provenant de `r nb_fam` familles différentes. Parmi celles-ci, `r nb_pheno` phénotypes différents ont été observés : 

1. **[L'Azoospermie](#infquant) :** Comme nous avons pu le voir, l'azoospermie est un phénotype d'infertilité masculine caractérisé par l'absence de spermatozoïde dans l'éjaculat.    
2. **Echec de fécondation :**  Ce phénotype d'infertilité se caractérise par l'incapacité des spermatozoïdes à féconder l'ovocyte.  
3. **MMAF** :  Le syndrome MMAF (*multiple morphological abnormalities of the sperm flagella*) caractérise comme son nom l'indique les patients présentant une majorité de spermatozoïdes atteins par une mosaïque d'anomalie morphologique du flagelle.  

Un récapitulatif des familles et de leur phénotype est disponible dans la table \@ref(tab:recapfam).    

```{r recapfam}

tab.name <- "Tableau recapitulatif des familles séquencées et de leur phénotype"

kable(df_seq,
      col.names = c("Familly","Individuals","Phenotype","Year","Plateform","Place"),
      caption = tab.name,
      longtable = TRUE,
      booktabs = TRUE)

```

#### Resultats des exomes  

##### Résultat de l'alignement  les

```{r runstrandness, warning=FALSE, cache=TRUE}

df_read_fate_nb <- fread("data/magic_results/All_Exomes.read_fate.txt", sep = "\t", data.table = FALSE, header = TRUE, drop = c(17:32)) %>% 
  select(-V1, -(Sample:RunId), -contains("entropy"), -contains("but"), -contains("insert")) %>%
  rename(RUN = `# Run`,
         `Map to 1 site` = `Mapped uniquely to 1 genomic site and maximum 1 gene`,
         S2 = `Mapped at 2 to 9 sites`,
         S10 = `Rejected because they map to 10 or more sites`) %>% 
  filter(RUN != "All runs") %>%
  mutate(`Map to 2 or more sites`  = S2 + S10) %>% 
  select(-S2, -S10) %>% 
  filter(RUN %in% run_all_fam) %>% 
  gather(QUALITY, NB_OF_READS, `Raw reads`:`Map to 2 or more sites`) 

pair_stat <- fread("data/magic_results/All_Exomes.pair_stats.txt", sep = "\t", data.table = FALSE, header = FALSE) %>% transpose()
names(pair_stat) <- pair_stat[1,] 

pair_stat <- pair_stat %>%
  filter(Run %in% run_all_fam) %>%
  select(RUN = Run, Compatible_pairs, Non_compatible_pairs, `Orphans Any`) %>% 
  rename(`Compatible` = Compatible_pairs,
         `Non compatible` = Non_compatible_pairs,
         Orphans = `Orphans Any`) %>%
  gather(QUALITY, NB_OF_READS, Compatible:Orphans) %>%
  mutate(NB_OF_READS = as.numeric(NB_OF_READS)) 

df_reads_summary <- rbind(df_read_fate_nb, pair_stat) %>% 
  mutate(IS_CONSERVED = if_else((QUALITY == "Raw reads" |
                                   QUALITY == "Compatible" |
                                   QUALITY == "Map to 1 site"), "Yes", "No" ))

```

Pour rappel, l'[alignement]({#lalignement}) consiste à repositionnerl'ensemble des *reads* générés au cours de l'étape de séquençage le long d'un génome de référence. La quantité de *reads* peut varier en fonction de plusieurs paramètres et n'est donc pas éguale pour chaque patient bien que l'ordre de grandeur reste le même exceptés pour les deux frères AZ1 et AZ2 pour lesquels on a près de 3 fois plus de *reads* que pour les autres patients (**Figure : **\@ref(fig:readsselection) - **A**). Ceci peut être expliqué car ces deux patients sont les deux seuls à voir été séquencé au Mount Sinaï Institut or leur protocol d'amplification contient un nombre de cycles de PCR superieur à ceux appliqué au Génopole d'Evry où ont été séquencé les autres patients (**Table :**  \@ref(tab:recapfam)), L'ensemble de nos exomes ayant été réalisés en *paired-end*, les deux extrémités de chaques fragments sont séquencés chaque *end* d'un même *read* peut donc être considéré comme un *read* à part entière. Celle-ci sont ensuite alignées **indépendemment** le long du génome de référence, l'information fournit par le *paired-end* n'est utilisé qu'à *posteriri* en tant que critère qualité. Ainsi, après avoir filtré les *reads* ne s'étant pas aligné sur le génome et le *reads* orphelines (une seule des deux *ends* s'est alignée sur le génome), la "compatibilité entre les deux *ends* d'un même *reads* est analysée. Un *read* est dit "compatible" lorsque les deux *ends* qui le composent s'alignent face à face (une sur le *strand* + et l'autre sur le *strand* -) et couvrent une zone ne faisant pas plus de 3 fois la taille médiane de l'insert. Ici encore, seul les *reads* ayant des *ends* "compatibles" seront conservés. Pour l'ensemble de nos patients, les *reads* compatibles sont environs 10 fois plus important que la somme des *reads* non compatible, orphelins ou non mappés (**Figure : **\@ref(fig:readsselection) - **B**). Suite à cela, le nombre de site auxquels se sont alignés les *reads* est analysé. En effet, certaine zone du génome étant dupliqué, l'une des problématique des *short-reads* est qu'il est possible que ceux-ci s'alignent à plusieurs endroit du génome. Afin d'éviter toute ambiguité, seul ceux s'étant aligné sur un site unique sont conservés pour la suite des analyse. ces *reads* représente entre ... et ... % des *reads* ayant passé les précédents filtres (**Figure : **\@ref(fig:readsselection) - **C**). Les *reads* ayant passé l'ensemble des critères qualité seront ensuite utilisé pour effectué l'appel des variants.     

\newpage

```{r readsselection, fig.cap=fig.info,fig.scap=fig.name,fig.width=6.3, fig.height=6.5, cache=TRUE}

fig.name <- "Processus simplifié du contrôle qualité des *reads*"
fig.description <- "**A** : Diagramme montrant le nombre de *reads* bruts générés pour chaque patients au cours de l'étape de séquençage. On constate que ce nombre reste pour chaque patient dans le même ordre de grandeur sauf pour les frères AZ1 et AZ2  qui contienent presque 3 fois plus de *reads* que la mediane représentée en bleue. **B** : Ce graphique la distribution pour chaque patient des reads compatibles, incompatibles, orphelins et non mappés. Comme attendu, les reads compatible sont les plus important. Ils sont les seuls à être utilisé dans le reste de l'analyse. **C** : Présentation pour chaque *reads* du nombre de site auxquels ils s'alignent. Seuls les reads s'alignant sur un site unique sont conservés"
fig.info <- paste0(fig.name, " : ", fig.description)


pA <- ggplot(df_reads_summary %>% filter(QUALITY == "Raw reads"), aes(RUN, NB_OF_READS)) + 
  geom_bar(stat = "identity", aes(fill = IS_CONSERVED)) + 
  xlab("") + 
  ylab("Nb of raw reads") + 
  # scale_x_discrete(labels = c("AZ1","AZ2","FF1","FF2","MMAF1.1","MMAF1.2","MMAF2.1","MMAF2.2","MMAF3.1","MMAF3.2","MMAF3.3")) + 
  scale_fill_manual(values = c("chartreuse3", "grey48"), guide = "none") +
  geom_hline(col = "blue", aes(yintercept = median(NB_OF_READS))) + 
  geom_text(data=data.frame(x=0,y=median(df_reads_summary$NB_OF_READS)), col = "blue", x = 12.5, y = 110000000, label = median(df_reads_summary$NB_OF_READS))

pB <- ggplot(df_reads_summary %>% 
         filter(QUALITY == "Compatible" | 
                  QUALITY == "Non compatible" |
                  QUALITY == "Orphans" |
                  QUALITY == "Unmapped"), aes(QUALITY, NB_OF_READS)) + 
         geom_boxplot(outlier.size = -1, aes(fill = IS_CONSERVED)) + 
         geom_jitter(position=position_jitter(0.3)) +
  facet_wrap(~QUALITY, scales = "free", nrow = 1) + 
  ylab("Nb of reads") +
  xlab("") + 
  scale_fill_manual(values = c("grey48", "chartreuse3"), guide = "none") + 
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

pC <- ggplot(df_reads_summary %>% 
               filter(QUALITY == "Map to 1 site" | 
                        QUALITY == "Map to 2 or more sites"), aes(QUALITY, NB_OF_READS)) + 
  geom_boxplot(outlier.size = -1, aes(fill = IS_CONSERVED)) + 
  geom_jitter(position=position_jitter(0.3)) +
  facet_wrap(~QUALITY, scales = "free", nrow = 1) + 
  scale_fill_manual(name = "Conserved read ?", values = c("grey48", "chartreuse3")) +
  ylab("Nb of reads") +
  xlab("") + 
  theme(axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        legend.position="bottom") +
  coord_flip()

row1 <- plot_grid(pA, labels = c("A"))
plot_grid(row1, pB, pC,labels = c("","B","C"), rel_heights = c(1,.7,.7), ncol = 1)



```

\newpage

##### Résultat de l'appel des variants  

```{r varcall, cache=TRUE} 

call <- function(file, fam, run) {

fread(file, sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE) %>% 
    gather(RUN, CALL, starts_with("Ghs")) %>% 
  filter(CALL != "*",
         CALL != "a",
         CALL != 1) %>% 
  mutate(RUN = run,
         FAM = fam, 
         TYPE = if_else(stri_length(REF) == stri_length(ALT), "SNV", "Indel"), 
         STRAND = if_else(CALL %in% c(2:9), "DS", 
                          if_else(CALL == 0, "NS", "SS")),
         CALL = if_else(CALL %in% c(2,"b"),"Heterozygous",
                        if_else(CALL %in% c(3,"c"), "Homozygous",
                                if_else(CALL %in% c(4:7,"d","e","f","g","h","i"),"Ambigous call",
                                                if_else(CALL %in% c(8,9), "Discordant call",
                                                        if_else(CALL == 0, "NA", paste0("ERROR !!!: ",CALL)))))))
  
}

df_call_az1 <- call(file = "data/call_results/call_az1.csv", fam = "AZ", run = "AZ1")
df_call_az2 <- call(file = "data/call_results/call_az2.csv", fam = "AZ", run = "AZ2")
df_call_ff1 <- call(file = "data/call_results/call_ff1.csv", fam = "FF", run = "FF1")
df_call_ff2 <- call(file = "data/call_results/call_ff2.csv", fam = "FF", run = "FF2")
df_call_mmaf1_1 <- call(file = "data/call_results/call_mmaf1_1.csv", fam = "MMAF1", run = "MMAF1.1")
df_call_mmaf1_2 <- call(file = "data/call_results/call_mmaf1_2.csv", fam = "MMAF1", run = "MMAF1.2")
df_call_mmaf2_1 <- call(file = "data/call_results/call_mmaf2_1.csv", fam = "MMAF2", run = "MMAF2.1")
df_call_mmaf2_2 <- call(file = "data/call_results/call_mmaf2_2.csv", fam = "MMAF2", run = "MMAF2.2")
df_call_mmaf3_1 <- call(file = "data/call_results/call_mmaf3_1.csv", fam = "MMAF3", run = "MMAF3.1")
df_call_mmaf3_2 <- call(file = "data/call_results/call_mmaf3_2.csv", fam = "MMAF3", run = "MMAF3.2")
df_call_mmaf4_1 <- call(file = "data/call_results/call_mmaf4_1.csv", fam = "MMAF4", run = "MMAF4.1")
df_call_mmaf4_2 <- call(file = "data/call_results/call_mmaf4_2.csv", fam = "MMAF4", run = "MMAF4.2")
df_call_mmaf4_3 <- call(file = "data/call_results/call_mmaf4_3.csv", fam = "MMAF4", run = "MMAF4.3")

df_call_fam <- rbind(df_call_az1, 
                       df_call_az2,
                       df_call_ff1, 
                       df_call_ff2,
                       df_call_mmaf1_1,
                       df_call_mmaf1_2,
                       df_call_mmaf2_1,
                       df_call_mmaf2_2,
                       df_call_mmaf3_1,
                       df_call_mmaf3_2,
                       df_call_mmaf4_1,
                       df_call_mmaf4_2,
                       df_call_mmaf4_3)

df_strand_all <-  df_call_fam %>%
  select(RUN, STRAND) %>% 
  group_by(RUN, STRAND) %>%
  summarise(N = n()) %>%
  group_by(RUN) %>%
  mutate(P = N / sum(N),
         IS_CONSERVED = if_else(STRAND == "NS","No","Yes"))
     
df_concordance_all <- df_call_fam %>%
  select(RUN, CALL, STRAND) %>%
  filter(STRAND == "DS") %>% 
  mutate(CALL = if_else(grepl("zygous", CALL), "Concordant call", CALL)) %>%
  group_by(RUN, CALL) %>%
  summarise(N = n()) %>%
  group_by(RUN) %>%
  mutate(P = N / sum(N),
         IS_CONSERVED = if_else(CALL == "Concordant call","Yes","No"))

df_geno_all <- df_call_fam %>%
  select(RUN, CALL, TYPE) %>%
  filter(grepl("zygous", CALL)) %>% 
group_by(RUN, CALL, TYPE) %>%
  summarise(N = n()) %>% 
  group_by(RUN) %>%
  mutate(P = N / sum(N),
         IS_CONSERVED = if_else(grepl("zygous", CALL),"Yes","No"))
#   
# df_call_ff <- fread("data/genotype_plcz.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE) %>%
#   gather(RUN, CALL, starts_with("Ghs")) %>%
#   filter(CALL %in% c(2, 3, "b", "c")) %>%
#   mutate(TYPE = if_else(stri_length(REF) == stri_length(ALT), "SNV", "Indel"), 
#          STRAND = if_else(CALL %in% c(2, 3), "Both strand", "Single strand"),
#          GENOTYPE = if_else(CALL %in% c(2, "b"), "Heterozygous", "Homozygous"),
#          RUN = if_else(RUN == "Ghs113", "FF1", "FF2"),
#          FAM = "FF")
# 
# df_call_mmaf1 <- fread("data/genotype_MMAF_fam1.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE) %>%
#   gather(RUN, CALL, starts_with("Ghs")) %>%
#   filter(CALL %in% c(2, 3, "b", "c")) %>%
#   mutate(TYPE = if_else(stri_length(REF) == stri_length(ALT), "SNV", "Indel"), 
#          STRAND = if_else(CALL %in% c(2, 3), "Both strand", "Single strand"),
#          GENOTYPE = if_else(CALL %in% c(2, "b"), "Heterozygous", "Homozygous"),
#          RUN = if_else(RUN == "Ghs56", "MM1.1", "MM1.2"),
#          FAM = "MMAF1")
# 
# df_call_mmaf2 <- fread("data/genotype_MMAF_fam2.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE) %>%
#   gather(RUN, CALL, starts_with("Ghs")) %>%
#   filter(CALL %in% c(2, 3, "b", "c")) %>%
#   mutate(TYPE = if_else(stri_length(REF) == stri_length(ALT), "SNV", "Indel"), 
#          STRAND = if_else(CALL %in% c(2, 3), "Both strand", "Single strand"),
#          GENOTYPE = if_else(CALL %in% c(2, "b"), "Heterozygous", "Homozygous"),
#          RUN = if_else(RUN == "Ghs62", "MM2.1", "MM2.2"),
#          FAM = "MMAF2")
# 
# df_call_mmaf3 <- fread("data/genotype_MMAF_fam3.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE) %>%
#   gather(RUN, CALL, starts_with("Ghs")) %>%
#   filter(CALL %in% c(2, 3, "b", "c")) %>%
#   mutate(TYPE = if_else(stri_length(REF) == stri_length(ALT), "SNV", "Indel"), 
#          STRAND = if_else(CALL %in% c(2, 3), "Both strand", "Single strand"),
#          GENOTYPE = if_else(CALL %in% c(2, "b"), "Heterozygous", "Homozygous"),
#          RUN = if_else(RUN == "Ghs63", "MM3.1", "MM3.2"),
#          FAM = "MMAF3")
# 
# df_call_mmaf4 <- fread("data/genotype_MMAF_fam4.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE) %>%
#   gather(RUN, CALL, starts_with("Ghs")) %>%
#   filter(CALL %in% c(2, 3, "b", "c")) %>%
#   mutate(TYPE = if_else(stri_length(REF) == stri_length(ALT), "SNV", "Indel"), 
#          STRAND = if_else(CALL %in% c(2, 3), "Both strand", "Single strand"),
#          GENOTYPE = if_else(CALL %in% c(2, "b"), "Heterozygous", "Homozygous"),
#          RUN = if_else(RUN == "Ghs59", "MM4.1", 
#                        if_else(RUN == "Ghs60", "MM4.2", "MM4.3")),
#          FAM = "MMAF4")

# 
# df_resume_strand_fam <- df_call_fam %>% 
#   group_by(STRAND, RUN, FAM) %>% 
#   summarise(N = n()) %>% 
#   mutate(IS_CONSERVED = if_else(STRAND == "NS","No","Yes"))



```

```{r cleancall, include=FALSE, warning=FALSE}

rm(df_call_az1,
   df_call_az2,
   df_call_ff1, 
   df_call_ff2,
   df_call_mmaf1_1,
   df_call_mmaf1_2,
   df_call_mmaf2_1,
   df_call_mmaf2_2,
   df_call_mmaf3_1,
   df_call_mmaf3_2,
   df_call_mmaf4_1,
   df_call_mmaf4_2,
   df_call_mmaf4_3)
gc()

```

Comme dit précédement, l'appel des variants fait suite à l'alignement et consiste à comparer la séquence d'un individus avec celle d'un génome de référence afin d'en relever les différences. La particularité de notre algorithme d'appel est d'effectuer pour chaque position deux appels indépendents. Le premier sera effectué en utilisant uniquement les *reads forward* et le second le *reads reverse*. Les positions ayant une couverture $\le$ 10 sur **les deux** *strands* seront filtrés (NS). Les autres seront conservés bien que ceux ayant une couverture $\le$ 10 sur **un des deux** *strands* (SS) seront considéré comme de faible qualité et seront leurs interprétations sera plus précotionneuse. Ainsi, chez nos `r ` [TODO nb of patients] entre ... et ... variants sont filtrés car leur couverture est < 10 sur les deux *ends* du *reads* (**Figure : **\@ref(fig:plotvarcall) - **A**). 

Pour les position ayant une couverture $\ge$ 10 sur **les deux** *strands* (DS) les résultats des deux appels sont comparés et seul les appel concordant seront conservés, c'est à dire environs ...% des variants DS. Les appels ambigus et discordants seront filtrés et non considérés dans les analyses en aval (**Figure : **\@ref(fig:plotvarcall) - **B**). 

Dès lors il est intéréssant de noter que bien que les variants *single strand* (SS) soient conservés, on peut s'attendre à ce qu'également ... % de ces variants soient abérents, ceux-ci n'ayant put subir le même contrôle que les SS. Pour l'ensemble des variants ayant passé les premiers filtres, c'est à dire les variants SS et les variants DS avec appels concordants, le génotype est déterminé en fonction du pourcentage de *reads* portant le variant à cette position. Par exemple, si à une position donnée, 0% des *reads* portent un variant, l'individu sera appelé "Homozygote référence", si 50% des *reads* sont portent un variant, l'appel sera "hétérozygote" et si 100% des *reads* portent un variant, l'appel sera "Homozygote variant". Ainsi, pour chaque individu nous avons pu établire une liste de variants avec leur génotype associé (**Figure : **\@ref(fig:plotvarcall) - **C**).    

\newpage

```{r plotvarcall, fig.cap=fig.info,fig.scap=fig.name,fig.width=7, fig.height=6.8, cache=TRUE}

fig.name <- "Contrôle qualité des variants appelés"
fig.description <- "Pour l'ensemble des figures les variants verts sont conservés, les gris sont filtrés. **A** : Distribution du *stranding* des appels pour chaque patients. Environs 16 pourcents des vairants ont une couverture insufisante pour l'appel *forward* et l'appel *revers* et sont donc filtrés, les autres sont conservés. **B** : Comparaison des appels entre les deux *ends* des variants appelés DS. En fonction des individus, 80 à 90 pourcent des appels sont concordants. Les autres appels sont filtrés des analyses ulterieures. **C** : Distribution des SNVs et indels en fonction de leur génotype pour chaque patients (représentés par une barre)."
fig.info <- paste0(fig.name, " : ", fig.description)

pA <- ggplot(df_strand_all, aes(STRAND, P)) +
  geom_boxplot(outlier.size = -1, aes(fill = IS_CONSERVED)) + 
  geom_jitter(size = 2, position=position_jitter(0.3)) +
  ylab("% of called variant") +
  xlab("") +
    facet_wrap(~STRAND, scales = "free") +
  scale_fill_manual(guide = "none", values = c("grey48", "chartreuse3")) +
  scale_y_continuous(labels = percent) + 
  theme(axis.title.x = element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

pB <- ggplot(df_concordance_all, aes(CALL, P)) +
  geom_boxplot(aes(fill = IS_CONSERVED), outlier.size = -1) + 
  geom_jitter(size = 2, position=position_jitter(0.3)) +
  ylab("% of called variant") +
  xlab("") +
  facet_wrap(~CALL, scales = "free") +
  scale_fill_manual(guide = "none", values = c("grey48", "chartreuse3")) + 
  scale_y_continuous(labels = percent) + 
  theme(axis.title.x = element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

pC <- ggplot(df_geno_all,aes(RUN, N)) + 
  geom_bar(stat = "identity", aes(fill = IS_CONSERVED)) +
  facet_grid(TYPE~CALL, scales = "free") +
  ylab("Nb of variant") + 
  scale_fill_manual(name = "Is the variant conserved?", values = c("chartreuse3", "grey48"), breaks = c("Yes","No"), labels = c("Yes","No")) +
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

row1 <- plot_grid(pA, labels = c("A"))
plot_grid(row1, pB, pC,labels = c("","B","C"), rel_heights = c(.6,.8,1), ncol = 1)

```

\newpage

##### Résultats de l'annotation  

```{r varannotation, include=FALSE, warning=FALSE, cache=TRUE} 

df_annotate <- df_call_fam %>%
  filter(grepl("zygous", CALL)) %>% 
  select(-STRAND) %>%
  variant_join(fread("data/all_variants_vep81.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE), mode = "left") %>% 
  select(-Allele, -Gene, -Feature_type, -(BIOTYPE:HGNC_ID), -(CADD_RAW:ExAC_AF_OTH), -(ExAC_AF_AMR:ExAC_AF_SAS)) 

df_gene_transcript <- df_annotate %>%
  group_by(RUN) %>%
  summarise(TRANSCRIPT = n_distinct(Feature),
            GENE = n_distinct(SYMBOL)) %>%
  gather(FEATURE,NB,TRANSCRIPT:GENE) 

df_impact <- df_annotate %>% 
  group_by(RUN, IMPACT) %>%
  summarise(N = n()) %>%
  group_by(RUN) %>%
  mutate(P = N / sum(N))

```

```{r cleancall2, include=FALSE, warning=FALSE}

rm(df_call_fam)
gc()

```

```{r annotstat, cache=TRUE}

mean_gene <- df_gene_transcript %>% ungroup() %>% filter(FEATURE == "GENE") %>% summarise(MEAN = mean(NB)) %>% collect() %>% .[["MEAN"]] %>% round(0)
mean_transcript <- df_gene_transcript %>% ungroup() %>% filter(FEATURE == "TRANSCRIPT") %>% summarise(MEAN = mean(NB)) %>% collect() %>% .[["MEAN"]] %>% round(0)
rate_tr_gene = (mean_transcript / mean_gene) %>% round(0)

```

```{r varfreq, cache=TRUE}

df_freq <- df_annotate %>%
  group_by(RUN) %>% 
  distinct(CHR,POSITION,REF,ALT,ExAC_AF,`1KG`,ESP) %>% 
  mutate(N_VAR_TOT = n()) %>%
  gather(DB,FREQ,ExAC_AF:ESP) %>% 
  filter(!is.na(FREQ)) 

df_freq_stat <- df_freq %>%
    select(-(CHR:ALT)) %>% 
  group_by(RUN, DB) %>%
  summarise(N_PER_RUN_PER_DB = n(),
            P_PER_RUN_PER_DB = n() / mean(N_VAR_TOT))

df_freq2 <- df_freq %>%
  ungroup() %>% 
  distinct(CHR,POSITION,REF,ALT,DB,FREQ) %>% 
  select(-(CHR:ALT)) 
```

Afin de connaitre l'effet qu'auront chacun des variants appelés sur les différents transcrits qu'ils chevauchent nous utilisons le logiciel VEP. Grâce à celà, nous pouvons constater que pour chaque patient ... gènes sont en moyenne affecté par au moins un variant tandis que ... sont impactés (soit environs ... transcrits par gènes) (**Figure : **\@ref(fig:plotvarannotation) - **A**). Chaque variant affectera l'ensemble des transcrits qu'il chevauche, ainsi un même variant pourra impacter plusieurs transcrits. Ces impacts sont ensuite classés par VEP en quatre catégories qui sont, de la plus délétère à la moins délétère : HIGH, MODERATE, LOW, MODIFIER. Comme attendu, les variants ayant un impact tronquant se retrouvent être les moins fréquent chez chacun de nos patients. Ceci est d'autant plus flagrant pour l'impact HIGH qui regroupe, entre autre, les variants créant un codon stop ou encore ceux causant un décalage du cadre de lécture, se retrouvent en quantité extrêment faible puisqu'ils ne représentent en moyenne que ... % des variants (soit environs ... par patient (en nb ici)) (**Figure : **\@ref(fig:plotvarannotation) - **B**).  


```{r plotvarannotation, fig.cap=fig.info,fig.scap=fig.name,fig.width=6.3, fig.height=5, cache=TRUE}


# TODO VENN des prédiction SIFT ET POLYPHEN !!!!!!!!!!!!!!!

fig.name <- "TODO"
fig.description <- "TODOooooooo ooooooooo oooooooooooooooooo oooooooooooooooo oooooooooooo ooooooooooo oooo oooooooo oooooooooooooooooooooooooooo oooooooooo ooooo ooooooooooooo oooooooooo oooooooooo ooooooo."
fig.info <- paste0(fig.name, " : ", fig.description)


pB <- ggplot(df_gene_transcript, aes(RUN, NB)) + 
  geom_bar(stat = "identity", position = position_identity(),  aes(fill = FEATURE)) + 
  scale_fill_discrete(name = "Feature", labels = c("Gene", "Transcript")) + 
  xlab("Patient") + 
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

pA <- ggplot(df_impact, aes("", P)) +
  geom_boxplot(outlier.size = -1) + 
  geom_jitter(size = 2, position = position_jitter(0.3)) +
  facet_wrap(~IMPACT, scales = "free", nrow = 1) +
  scale_y_continuous(labels = percent_format()) +
  theme(axis.title = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

plot_grid(pA, pB, labels = c("A","B"), ncol = 1)

```

```{r plotvarfreq, fig.cap=fig.info,fig.scap=fig.name,fig.width=6.3, fig.height=6, cache=TRUE}

# corélation freq impact matrice

fig.name <- "TODO"
fig.description <- "TODOooooooo ooooooooo oooooooooooooooooo oooooooooooooooo oooooooooooo ooooooooooo oooo oooooooo oooooooooooooooooooooooooooo oooooooooo ooooo ooooooooooooo oooooooooo oooooooooo ooooooo."
fig.info <- paste0(fig.name, " : ", fig.description)

pA <- ggplot(df_freq_stat, aes(DB, P_PER_RUN_PER_DB)) + 
  geom_boxplot(aes(fill = DB)) + 
  ylab("% of variant found within a DB") + 
  scale_x_discrete(labels = c("1KG","ESP6500","ExAC")) + 
  theme(axis.title.x = element_blank()) + 
  scale_fill_discrete(guide = "none")


pB <- ggplot(df_freq2, aes(FREQ)) + 
  geom_line(aes(col = DB), stat = "bin", bins = 150) +
  scale_color_discrete(name = "Data base", labels = c("1KG","ESP6500","ExAC")) + 
  xlab("Variant frequency") +
  ylab("Nb of variants") + 
  theme(legend.position = "bottom")


plot_grid(pA,pB,labels = c("A","B"), ncol = 1)


```


```{r}
# 
# df_cor_impact_freq <- df_annotate %>% 
#   ungroup() %>%
#   distinct(CHR,POSITION,REF,ALT,ExAC_AF,`1KG`,ESP,IMPACT) %>%
#   select(-(CHR:ALT)) 
# 
# 
# df_cor_impact_freq %>% 
#   gather(DB,FREQ,ExAC_AF:ESP) %>% View
#   
#   spread(IMPACT)
# 
# 
# View(mtcars)
# 
# cor()
# 
# type
# 
# %>% 


```



```{r cleanfreq, include=FALSE, warning=FALSE}

rm(df_freq, df_freq2, df_freq_stat)
gc()


```


\newpage

##### Résultats du filtrage
