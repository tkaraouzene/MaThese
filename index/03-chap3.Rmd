---
output:
  word_document: default
  html_document: default
  pdf_document: default
  classoption: landscape
---
# Mise en place d’une stratégie pour l’analyse des données exomiques – application en recherche clinique  

```{r include.packages2, include=FALSE}
# This chunk ensures that the thesisdown package is
# installed and loaded. This thesisdown package includes
# the template files for the thesis.

if(!require(devtools))
  install.packages("devtools", repos = "http://cran.rstudio.com")

if(!require(bookdown))
  devtools::install_github('rstudio/bookdown')

if(!require(thesisdown))
  devtools::install_github("ismayc/thesisdown")

if(!require(kableExtra))
devtools::install_github("haozhu233/kableExtra")

library(thesisdown)
library(pander)
library(knitr)
library(tidyr)
library(dplyr)
library(data.table)
library(ggplot2)
library(stringi)
library(scales)
library(cowplot)
library(stringr)
library(foreach) 
library(viridis)
library(kableExtra)

theme_set(theme_gray()) # otherwise use cowplot default theme

source("script/manage_variants.R")
source("script/variant_filtering.R")
source("script/resume_data.R")
source("script/plot_vep_results.R")
source("script/gene_expression.R")

opts_knit$set(eval.after = c("fig.cap","fig.scap"))

knitr::opts_chunk$set(fig.align='center',echo=FALSE)

```

```{r localfunction, cache=TRUE}

open_ctrl <- function(file, pheno = "none") {
  
  fread(file, sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE) %>% 
    gather(RUN, CALL, starts_with("Ghs")) %>%
    filter(CALL %in% c(3, "c")) %>%
    mutate(N_CTRL = n_distinct(RUN),
           PHENO = pheno)  %>%
    select(-CALL) %>% 
    distinct(CHR, POSITION, REF, ALT, N_CTRL, PHENO)
}

`%tin%` <- function(x, y) {
    mapply(assign, as.character(substitute(x)[-1]), y,
      MoreArgs = list(envir = parent.frame()))
    invisible()
}

tab_gene <- function(df, gene) {
  
  tab_gene <- df %>% 
    filter(SYMBOL == gene) %>% 
    mutate(VARIANT = paste(CHR,POSITION,REF,ALT, sep = "-"),
           Consequence = sapply(strsplit(Consequence, "_variant", fixed = TRUE),"[[",1),
           Consequence = gsub("_", " ", Consequence)) %>%
    distinct(RUN, VARIANT, CALL, Consequence, SYMBOL) %>% 
    arrange(desc(CALL), RUN)
  
  run_homo <- tab_gene %>% filter(CALL == "Homozygous") %>% ungroup() %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
  run_het <- tab_gene %>% filter(CALL == "Heterozygous") %>% ungroup() %>% distinct(RUN) %>% collect() %>% .[["RUN"]]

  n_run_homo <- run_homo %>% length
  n_run_het <- run_het %>% length
  list(tab_gene, run_homo, run_het, n_run_homo, n_run_het)
}

na.replace <- function (x, char = "") {
    x[is.na(x)] <- char
    return(x)
}

plot_resume_analysis <- function(df) {
  
  
  levels <- c("High","Moderate","Low")
  
  df <- df %>% 
    mutate(TRUST = factor(TRUST, levels = levels))
  
  n_distinct_gene <- df %>% ungroup() %>% distinct(SYMBOL) %>% nrow
  
  if (n_distinct_gene == 1) {
  
  break_max <- df$N_RUN %>% max
  
  p <- ggplot(df, aes(TRUST, N_RUN)) +
    facet_wrap(~SYMBOL) 
    
  } else {
    
    break_max <- df$TOT %>% max
  
    p <- ggplot(df, aes(reorder(SYMBOL, -TOT), N_RUN)) 
  
    }
  
  p + geom_col(aes(fill = TRUST)) + 
    scale_fill_manual(guide = "none", limits = c("High","Moderate","Low"), values = c("#4DAF4A","#FF7F00","#E41A1C")) + 
    scale_y_continuous(breaks = c(0:break_max)) +
    ylab("Nb of individuals") + 
    xlab("")
  
}

tab_high <- function(df, caption = "", evidence = TRUE, landscape = FALSE) {

  df <- df %>% 
    ungroup() %>% 
    filter(CANONICAL == "YES") %>%
    mutate(HGVSc = na.replace(HGVSc, "."),
           HGVSp = na.replace(HGVSp, "."),
           `HGVSc, HGVSp` = paste0(HGVSc," ; ", HGVSp)) %>%
    select(Patient = RUN, Gene = SYMBOL, Evidence = EVIDENCE, `HGVSc, HGVSp`, Consequence, ESP, `1KG`, ExAC = ExAC_AF) %>%
    arrange(Gene) %>% 
    mutate(ESP = na.replace(ESP, "."),
           `1KG` = na.replace(`1KG`, "."),
           ExAC = na.replace(ExAC, "."))
  
  if(evidence == FALSE) df <- df %>% select(-Evidence)
  
  kdf <- df %>% kable(format = "latex",
                      booktabs = TRUE,
                      longtable = TRUE,
                      caption = caption) %>%
    add_header_above(c(rep(" ", ncol(df) - 5), "Variant impact" = 2, "Variant frequency" = 3))

  
    if (landscape == TRUE) kdf <- kdf %>% landscape(margin = NULL)

  kdf
  
}


tab_modelow <- function(df, caption = "", landscape = FALSE) {
  
  kdf <- df %>% 
    ungroup() %>%
    filter(CANONICAL == "YES") %>%
    mutate(HGVSc = na.replace(HGVSc, "."),
           HGVSp = na.replace(HGVSp, "."),
           `HGVSc, HGVSp` = paste0(HGVSc," ; ", HGVSp)) %>%

    select(Patient = RUN, Gene = SYMBOL, `HGVSc, HGVSp`, Consequence, SIFT, PolyPhen, ESP, `1KG`, ExAC = ExAC_AF) %>%
    distinct() %>% 
    mutate(ESP = na.replace(ESP, "."),
           `1KG` = na.replace(`1KG`, "."),
           ExAC = na.replace(ExAC, "."),
           SIFT = na.replace(SIFT, "."),
           SIFT = gsub(" low confidence", "", SIFT),
           PolyPhen = na.replace(PolyPhen, "."),
           PolyPhen = gsub("probably", "proba", PolyPhen),
           PolyPhen = gsub("possibly", "possib", PolyPhen)) %>%
    kable(format = "latex",
          booktabs = TRUE,
          longtable = TRUE,
          caption = caption) %>%
    add_header_above(c(" ", " ", "Variant impact" = 4, "Variant frequency" = 3))
  
  if (landscape == TRUE) kdf <- kdf %>% landscape(margin = NULL)

  kdf

}

paste_vector <- function(v, style = "none", sep = ", ", last = " et ", sort = TRUE) {
  
  if (sort == TRUE) v <- v %>% sort
  
  if (style == "bold") v <- paste0("**",v,"**")
  if (style == "itallic") v <- paste0("*",v,"*")
  if (style == "both") v <- paste0("**_",v,"_**")

  v_head <- v %>% head(-1) %>% paste(collapse = sep)
  
  v_tail <- v %>% tail(1)
  
  paste(v_head, last , v_tail)
}


gene_to_run <- function(df, genes) {
  
  df %>% ungroup() %>% filter(SYMBOL %in% genes) %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
  
}
                                    
```


\newpage


## Introduction  

En 2011, les bases moléculaires d'environ 3700 pathologies à transmission Mendélienne avaient été élucidées. Cependant, pour une quantité équivalente de pathologies Mendéliennes (ou suspectées de l'être) cette cause reste un mystère [@Amberger2011]. Avec plusieurs centaines de pathologies caractérisées depuis 2010 [@Ng], les séquençages WGS et WES ont, depuis leur émergence, révolutionnés les méthodes de recherche dans le cadre d'étude phénotype-génotype en permettant de manière rapide et à moindre coup le séquençage de la quasi-totalité des gènes humains. Dès lors, le défis de ces analyses n'est plus le séquençage de l'ADN mais l'interprétation des données massives produites. En effet, l'un des plus grands challenges des analyses phénotype-génotype réalisées par WES réside dans l'analyse de l'importante quantité de variant portés par chaque individu s'élevant à plusieurs dizaines de milliers lorsque l'on  compare avec le génome de référence. Même après avoir retiré les variants retrouvés fréquemment dans la population générale, des méthodes additionnelles sont nécessaires pour prédire, parmi les variants restant, lesquels induisent des conséquences fonctionnelles sérieuses afin de les prioriser [@Pelak2010]. De nombreux logiciels tel que Variant Effect Predictor [@McLaren2016], SnpEff [@Cingolani2012] ou encore ANNOVAR [@Wang2010] permettent d'identifier quels sont les variants qui ont un effet tronquant sur la protéine. Cependant, avec en moyenne 165 variants homozygotes ayant un effet tronquant retrouvés dans chaque exomes [@Pelak2010] ces méthodes, bien qu'efficaces sont souvent insuffisantes.   

D'autres logiciels tel que Exomiser [@Robinson2014] vont, à partir d'une liste de variants **déjà** appelés effectuer les étapes d'annotation, de filtrage et de priorisation. Malgré l'efficacité de ces logiciels, aucun d'entre eux ne couvrent l'ensemble des étapes allant de l'alignement des *reads* à la priorisation des variants. La plupart ayant pour point de départ une liste de variants appelés en amont. Ils ne contrôlent donc en aucune manière les étapes d'alignement et d'appel des variants. Or, comme il a été dit plus tôt, ces deux étapes constituent la base de l'analyse []. 

Ce chapitre décrit à la fois la constitution d’un pipeline d’analyse des données de séquençage exomique recouvrant l'ensemble des étapes allant de l'allignement des séquences à la priorisation des variants ainsi que son utilisation dans le cadre de la recherche de mutations entrainant différents phénotypes d’infertilité d'une part de cas familiaux composés de duos ou trio et, pour finir, d'une large cohorte d'individus non apparentés présentant tous le même phénotype.  


\newpage

## Résultats  

```{r dfallruns, cahce=TRUE}


df_runs <- fread("data/exome_runs.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, data.table = FALSE) %>%
  rename(Phenotype = Pathologie) %>%
  filter(Phenotype != "TVPC")

run_az_fam <- c("Ghs44","Ghs45")
run_ff_fam <- c("Ghs113","Ghs117")
run_mmaf_fam <- c("Ghs56","Ghs58","Ghs62","Ghs130","Ghs63","Ghs119","Ghs59","Ghs60","Ghs61")

run_all_fam <- c(run_az_fam, run_ff_fam, run_mmaf_fam)

df_runs_analysed <- df_runs %>% 
  filter(Phenotype == "Flag" | 
           `Magic ID` %in% run_all_fam)

resume_pheno <- df_runs %>% 
  group_by(Phenotype) %>% 
  summarise(N_per_Patho = n()) %>% 
  spread(Phenotype, N_per_Patho) %>% 
  rename(Azoospermia = Azoo, 
         MMAF = Flag, 
         `Fertilization failure` = Fert_fail, 
         Globozoospermia = Globo, 
         Macrozoospermia = Macro,
         `Oocyte defect` = Ovo,
         Healthy = CTRL) %>% 
  gather(Phenotype,`Nb of individuals`, Azoospermia:`Oocyte defect`)


resume_tot <- resume_pheno %>% 
  ungroup() %>% 
  summarise(N_tot = sum(`Nb of individuals`),
            N_pheno = n_distinct(Phenotype) - 1)



```

```{r recapfam}

df_seq <- data_frame(FAM = c("AZ","FF","MMAF1","MMAF2","MMAF3","MMAF4"),
                     CONSANGUINITY = c("Yes","Yes","No","Yes","No","No"),
                     NB = c(2,2,2,2,2,3),
                     INDIV = c("AZ1, AZ2","FF1, FF2", "MMAF1.1, MMAF1.2", "MMAF2.1, MMAF2.2", "MMAF3.1, MMAF3.2", "MMAF4.1, MMAF4.2, MMAF4.3"),
                     PHENOTYPE = c("Azoospermia","Fertilization failure","MMAF","MMAF","MMAF","MMAF"),
                     YEAR = c(2012,2014,2014,2014,2014,2014),
                     # PLATFORM = c("Illumina HiSeq2000","Illumina HiSeq2000","Illumina HiSeq2000","Illumina HiSeq2000","Illumina HiSeq2000","Illumina HiSeq2000"),
                     PLACE = c("Mount Sinai Institut","Genoscope (Evry)","Genoscope (Evry)","Genoscope (Evry)","Genoscope (Evry)","Genoscope (Evry)")) 

```

```{r varrecapfam, cache=TRUE, dependson="recapfam"}

n_fam <- df_seq %>% summarise(N_FAM = n_distinct(FAM)) %>% collect() %>% .[["N_FAM"]] 
n_min_fam <- df_seq %>% collect() %>% .[["NB"]] %>% min 
n_max_fam <- df_seq %>% collect() %>% .[["NB"]] %>% max 
n_consanguinity_fam <- df_seq %>% filter(CONSANGUINITY == "Yes") %>% nrow
consanguine_fam <- df_seq %>% filter(CONSANGUINITY == "Yes") %>% collect() %>% .[["FAM"]]

n_not_consanguinity_fam <- n_fam - n_consanguinity_fam

nb_pheno <- df_seq %>% summarise(N_PHENO = n_distinct(PHENOTYPE)) %>% collect() %>% .[["N_PHENO"]] 



```

```{r varallruns, cache=TRUE, dependson="dfallruns"}

n_tot_runs <- resume_tot %>% collect() %>% .[["N_tot"]]
n_pheno_tot <- resume_tot %>% collect() %>% .[["N_pheno"]]

n_run_analysed <- df_runs_analysed %>% nrow
n_run_fam <- run_all_fam %>% length



n_run_bigmmaf <- n_run_analysed - n_run_fam

```


### Etude d’une large cohorte de patients MMAF  {#cohortemmah}  

#### Description de la cohorte  

```{r dfcohort, cache=TRUE}

run_mmaf_fam <- c("Indiv1","indiv2","indiv3","Ghs130","Ghs63","Ghs119","Ghs59","Ghs60","Ghs61")

df_runs_mmaf <- fread("data/exome_runs.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, drop = c(2,3,4,10:16), data.table = FALSE) %>%
  rename(RUN = `Magic ID`, PHENOTYPE = Pathologie, DATE = Date) %>%
  mutate(PHENOTYPE = if_else(PHENOTYPE == "Flag", "MMAF", PHENOTYPE),
         YEAR = as.numeric(str_sub(DATE, start= -4)),
         PROJECT = paste0(Project," (",YEAR,")")) %>%
  filter(!(RUN %in% run_mmaf_fam),
         PHENOTYPE == "MMAF") %>%
  select(-DATE, -PHENOTYPE)


```

```{r varcohort, dependson="dfcohorte", cache=TRUE}

runs_bigmmaf <- df_runs_mmaf %>% collect() %>% .[["RUN"]]

min_year <- df_runs_mmaf$YEAR %>% min
max_year <- df_runs_mmaf$YEAR %>% max

center <- df_runs_mmaf$Project %>% unique
n_center <- center %>% length

```

Après avoir mis en évidence l'implication du gène *DNAH1* dans le phénotype MMAF notre équipe s'est en partie spécialisé dans la caractérisation ce syndrome. Ainsi, entre `r min_year` et `r max_year`, notre équipe a effectué le séquençage de `r n_run_bigmmaf` individus présentant tous ce phénotype afin d'en établir la cause génétique. Ces séquençages ont été effectué dans `r n_center` centres différents que sont `r center %>% paste_vector` et sur une seule plateforme de séquençage, le Illumina HiSeq2000.

```{r tabcohort}

kable(df_runs_mmaf %>% 
        mutate(Platform = paste0(Platform, " ", Model)) %>%
        select(-Model, -PROJECT) %>%
        rename(Place = Project, Patient = RUN, Year = YEAR) %>% 
        group_by(Place, Year, Platform) %>% 
        summarise(`Nb of individuals` = n_distinct(Patient)) %>%
        arrange(Year),
      longtable = TRUE,
      booktabs = TRUE, 
      caption = "Liste des différents projets de séquençages effectués") 

```

\newpage

#### Application de la pipeline - Résultats

```{r extradata, cache=TRUE}

df_rvis <- fread("data/RVIS_Unpublished_ExAC_May2015.txt",sep = "\t",header = TRUE,data.table = FALSE) %>%
  select(SYMBOL = CCDS_r15,SCORE = `RVIS_ExAC_0.05%(AnyPopn)`) %>%
  mutate(RVIS_PERCENTILE = percent_rank(SCORE)) %>%
  select(-SCORE) %>%
  na.omit()

df_cilliome_gene <- fread("data/ciliome.csv",sep = "\t",header = TRUE, data.table = FALSE) %>% 
  select(SYMBOL = Symbol, EVIDENCE = `Novelty category`, LOCALISATION = `Immunostaining of cilia`) %>% 
  mutate(EVIDENCE = substring(EVIDENCE, 4),
         EVIDENCE = if_else(grepl("Strong", EVIDENCE), "Strong",
                            if_else(grepl("Weak", EVIDENCE), "Weak", "Novel")),
         LOCALISATION = substring(LOCALISATION, 4))

n_cilliome_gene <- df_cilliome_gene %>% nrow

df_ctrl_mmaf <- open_ctrl("data/genotype_not_MMAF.csv", pheno = "MMAF")

```

```{r bigmmafcall, cache=TRUE}

bigmmaf_call_file <- "results/bigmmaf_call.rds"
bigmmaf_distinct_call_file <- "results/bigmmaf_distinct_call.rds"

if (!file.exists(bigmmaf_call_file)) {
  
  df_bigmmaf_call <- fread("data/genotype_MMAF.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE) %>% 
    gather(RUN, CALL, starts_with("Ghs")) %>%
    filter(CALL %in% c(0, 2, 3, "b", "c"),
           !(RUN %in% run_mmaf_fam),
           !is.na(REF)) %>%
    mutate(STRAND = if_else(CALL %in% c(2:9), "DS", 
                            if_else(CALL == 0, "NS", "SS")),
      TYPE = if_else(stri_length(REF) == stri_length(ALT), "SNV", "Indel"),
           CALL = if_else(CALL == 0, "None",
                          if_else(CALL %in% c(2, "b"), "Heterozygous", "Homozygous")))

  saveRDS(df_bigmmaf_call, bigmmaf_call_file)
  
} else {
  
  df_bigmmaf_call <- readRDS(bigmmaf_call_file)

}

if (!file.exists(bigmmaf_distinct_call_file)) {

  
df_distinct_call <- df_bigmmaf_call %>%  
  filter(grepl("zygous", CALL)) %>% 
  distinct(CHR, POSITION, REF, ALT, TYPE) %>%
  mutate(CHR = as.character(CHR)) %>%
  # variant_join(fread("data/all_variants_vep81.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE, drop = c(11,12,14:28,31:34,36:40)), mode = "left") %>%
  variant_join(fread("~/all_chr_var.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE), mode = "left") %>%
         mutate(PolyPhen = gsub("_", " ", str_extract(PolyPhen, "\\w+")),
              SIFT = gsub("_", " ", str_extract(SIFT, "\\w+")),
              Consequence = sapply(strsplit(Consequence, "_variant", fixed = TRUE),"[[",1),
              Consequence = gsub("_", " ", Consequence),
              HGVSc = sapply(strsplit(HGVSc, split=':', fixed=TRUE), function(x) (x[2])),
              HGVSp = sapply(strsplit(HGVSp, split=':', fixed=TRUE), function(x) (x[2])))

  saveRDS(df_distinct_call, bigmmaf_distinct_call_file)

} else {
  
  df_distinct_call <- readRDS(bigmmaf_distinct_call_file)
  
}


df_bigmmaf_call_geno <- df_bigmmaf_call %>% 
  filter(grepl("zygous", CALL)) %>% 
  group_by(RUN, TYPE, CALL) %>% 
  distinct(CHR, POSITION, REF, ALT) %>%
  count() %>%
  left_join(df_runs_mmaf, by = "RUN") %>% 
  select(-(Project:Model))
                       
df_bigmmaf_call_strand <- df_bigmmaf_call %>%
  group_by(RUN, STRAND) %>%
  count() %>%
  group_by(RUN) %>%
  mutate(N_ALL_STRAND = sum(n),
         P_STRAND = n / N_ALL_STRAND) %>%
  left_join(df_runs_mmaf, by = "RUN")


```

```{r varbigmmafcall, dependson="bigmmafcall", cache=TRUE}

n_distinct_var <- df_distinct_call %>% nrow %>% as.integer
n_distinct_snv <- df_distinct_call %>% filter(TYPE == "SNV") %>% nrow %>% as.integer
n_distinct_indel <- df_distinct_call %>% filter(TYPE == "Indel") %>% nrow %>% as.integer

n_mean_var <- df_bigmmaf_call_geno %>% group_by(RUN) %>% summarise(N = sum(n)) %>% collect() %>% .[["N"]] %>% mean %>% round(0) %>% as.integer
n_mean_snv <- df_bigmmaf_call_geno %>% filter(TYPE == "SNV") %>% group_by(RUN) %>% summarise(N = sum(n)) %>% collect() %>% .[["N"]] %>% mean %>% round(0) %>% as.integer
n_mean_indel <- df_bigmmaf_call_geno %>% filter(TYPE == "Indel") %>% group_by(RUN) %>% summarise(N = sum(n)) %>% collect() %>% .[["N"]] %>% mean %>% round(0) %>% as.integer

n_mean_homo <- df_bigmmaf_call_geno %>% filter(CALL == "Homozygous") %>% group_by(RUN) %>% summarise(N = sum(n)) %>% collect() %>% .[["N"]] %>% mean %>% round(0) %>% as.integer
p_mean_homo <- (n_mean_homo / n_mean_var)  %>% round(3) * 100 

ns_geno_2015_mean <- df_bigmmaf_call_strand %>% filter(PROJECT == "Genoscope (2015)", STRAND == "NS") %>% collect() %>% .[["P_STRAND"]] %>% median %>% round(3) * 100

```

Après avoir appelé les variants de nos `r n_run_bigmmaf` patients, nous avons obtenu un total de `r n_distinct_var` variants différents comprenant `r n_distinct_snv` SNVs et `r n_distinct_indel` indels. Ces variants étant répartit entre chaque patient qui portaient environs chacun `r n_mean_snv` SNV et `r n_mean_indel` indels dont `r p_mean_homo` % étaient homozygote. Comme on peut le voir, la proportion de chaque appel est relativement homogène lorsque l'on compare les patients ayant été séquencés dans le même centre la même année. Cependant, il est possible de noter de grandes disparités lorsque l'on compare les données provenant de différents centres ou bien du même centre avec plusieurs années de différences. Ces écarts peuvent-être causés par plusieurs facteur, tel que les différents kits de capture d'exons qui on put être utilisés puisque ... (**todo lister les différents kits de capture dans une table**) en revanche nous pouvons écarter un effet dus à la plateforme de séquençage ou encore le modèle de séquenceur puisque tous ces projets ont été réalisés sur des Illumina HiSeq2000 (**Table : **\@ref(tab:tabcohort)) (**Figure : **\@ref(fig:plotbigmmafcall) - **A**).  

Le même constat peut être effectué lorsque l'on compare la qualité des appels puisque plus les projets de séquençage s'avèrent être récent, plus la proportion d'appel *Single Strand* s'avère être faible tandis que la proportion d'appel *Double Strand* (DS) est élevée. Ceci est une bonne chose, car, bien que ces deux appels soient conservés dans les analyses ultérieures, les appels DS sont de meilleure qualité que les appels SS. Cette augmentation des appels DS au cours du temps pourrait s'expliquer par une amélioration des protocoles de séquençage ainsi que des kits de capture. En revanche cela est à pondérer avec le taux croissant d'appels *No-strand* (NS) au fur et à mesure des années pour atteindre environs `r ns_geno_2015_mean` % en 2015 avec un projet réalisé au Génoscope. Ces derniers appels étant systématiquement filtrés, ils n'altèreront en rien les résultats obtenus en aval hormis le fait qu'ils réduisent la quantité des données utilisées (**Figure : **\@ref(fig:plotbigmmafcall) - **B** et **C**).

\newpage

```{r plotbigmmafcall, dependson="bigmmafcall", fig.cap=fig_info,fig.scap=fig_name, fig.height=7.6, cache=TRUE}

fig_name <- "Résultats de l'appel des variants par individus et par projet de séquençage"
fig_description_general <- "Chaque couleur définit un projet de séquençage caractérisé par un centre de séquençage et une année"
fig_description_A <- "**A** : Quantification pour chaque individus (représentés par les barres) du nombre de variants (SNVs et Indels) appelés homozygotes et hétérozygotes"
fig_description_B <- "**B** : Quantification des appels *Double Strand* (DS), *Single Strand* (SS) et *No strand* (NS) pour chaque projet de séquençage"
fig_description_C <- "**C** : Même chose en pourcentage"
fig_description <- paste(fig_description_general, fig_description_A, fig_description_B, fig_description_C, sep = ". ")
fig_info <- paste0(fig_name, " : ", fig_description)

pA <- ggplot(df_bigmmaf_call_geno, aes(reorder(RUN, YEAR), n)) + 
  geom_bar(stat = "identity", aes(fill = PROJECT)) + 
  facet_grid(TYPE~CALL, scales = "free") +
  scale_fill_brewer(palette = "Set1", guide = "none") +
  ylab("Nb of called variants") + 
  theme(axis.title.x = element_blank(), 
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

pB <- ggplot(df_bigmmaf_call_strand, aes(reorder(PROJECT, YEAR), n)) + 
  geom_boxplot(outlier.size = -1, aes(fill = PROJECT)) + 
  facet_wrap(~factor(STRAND, levels = c("DS", "SS", "NS")), scales = "free") +
  ylab("Nb of call") + 
  scale_x_discrete(limits = c("Strasbourg (2012)", "MountSinai (2012)", "Genoscope (2013)", "Genoscope (2014)", "Genoscope (2015)")) +
   scale_fill_brewer(palette = "Set1", guide = "none") +
  theme(axis.title.x = element_blank(), 
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

pC <- ggplot(df_bigmmaf_call_strand, aes(reorder(PROJECT, YEAR), P_STRAND)) + 
  geom_boxplot(outlier.size = -1, aes(fill = PROJECT)) + 
  facet_wrap(~factor(STRAND, levels = c("DS", "SS", "NS")), scales = "free") +
  scale_x_discrete(limits = c("Strasbourg (2012)", "MountSinai (2012)", "Genoscope (2013)", "Genoscope (2014)", "Genoscope (2015)")) +
  scale_fill_brewer(palette = "Set1", name = "Sequencing project", 
                    breaks = c("Strasbourg (2012)", "MountSinai (2012)", "Genoscope (2013)", "Genoscope (2014)", "Genoscope (2015)")) +
  ylab("% of call") + 
  scale_y_continuous(labels = percent) +
  theme(legend.position = "bottom",
        legend.title = element_blank(),
        axis.title.x = element_blank(), 
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())


row2 <- plot_grid(pB,pC, ncol = 1, rel_heights = c(.43,.57), labels = c("B","C"))

plot_grid(pA,row2, ncol = 1, rel_heights = c(.45,.55), labels = c("A",""))

```

\newpage

#### Analyse des listes de gènes  

```{r filterbigmmaf, dependson=c("bigmmafcall","extradata"), cache=TRUE}

maf_cutoff <- .01

df_distinct_filter <- df_distinct_call %>%
  filter_frequence(cutoff = maf_cutoff) %>%
  variant_join(df_ctrl_mmaf %>% mutate(CHR = as.character(CHR)), mode = "anti") %>%
  filter(Consequence != "synonymous",
         IMPACT != "MODIFIER",
         !(grepl("tolerated", SIFT) & grepl("benign", PolyPhen)),
         !grepl("NMD transcript", Consequence),
         !grepl("non coding transcript", Consequence)) %>%
  left_join(df_rvis, by = "SYMBOL") %>%
  left_join(df_cilliome_gene, by = "SYMBOL") %>%
  mutate(EVIDENCE = if_else(is.na(EVIDENCE), "Not in the list", EVIDENCE))
  

df_bigmmaf_filter <- df_bigmmaf_call %>% 
  mutate(CHR = as.character(CHR)) %>%
  select(-STRAND) %>%
  filter_genotype(het = FALSE) %>% 
  variant_join(df_distinct_filter, mode = "inner") %>% 
  # select(-Allele) %>% 
  mutate(SYMBOL = if_else(SYMBOL == "WDR52", "CFAP44", 
                          if_else(SYMBOL == "WDR96", "CFAP43", SYMBOL))) %>%
  ungroup()
  
df_bigmmaf_filter_stat <- df_bigmmaf_filter %>% 
  group_by(RUN) %>%
  mutate(N_GENE = n_distinct(SYMBOL)) %>%
  group_by(RUN, TYPE, N_GENE) %>%
  distinct(CHR, POSITION, REF, ALT) %>%
  summarise(N_VAR_PER_TYPE = n()) %>%
  group_by(RUN) %>%
  mutate(N_VAR_TOT = sum(N_VAR_PER_TYPE)) %>%
  right_join(df_runs_mmaf, by = "RUN") 
  
df_bigmmaf_genes <- df_bigmmaf_filter %>% group_by(SYMBOL, EVIDENCE, LOCALISATION) %>% distinct(RUN) %>% mutate(N_RUN = n()) 
df_bigmmaf_genes_distinct <- df_bigmmaf_genes %>% distinct(N_RUN)
df_bigmmaf_genes_resume <- df_bigmmaf_genes_distinct %>% distinct(N_RUN) %>% group_by(N_RUN) %>% summarise(N_GENE = n()) 

```

```{r filterhetbigmmaf, dependson="bigmmafcall", cache=TRUE}

df_bigmmaf_filter_het <- df_bigmmaf_call %>% 
  mutate(CHR = as.character(CHR)) %>%
  select(-STRAND) %>% 
  filter_genotype(homo = FALSE) %>% 
  variant_join(df_distinct_filter, mode = "inner") %>% 
  # select(-Allele) %>%
  group_by(RUN, SYMBOL, Feature) %>%
  mutate(N_VAR_PER_RUN_PER_GENE = n()) %>% 
  filter(N_VAR_PER_RUN_PER_GENE > 1) %>% 
  group_by(SYMBOL) %>%
  mutate(N_RUN_PER_GENE = n_distinct(RUN)) %>%
  ungroup() %>%
  mutate(SYMBOL = if_else(SYMBOL == "WDR52", "CFAP44", 
                          if_else(SYMBOL == "WDR96", "CFAP43", SYMBOL)))

```

```{r}

# Pierre Ray 
# 
# bind_rows(df_runs %>% select(RUN = `Magic ID`, Patient) %>% filter(Patient == "12") %>% inner_join(df_bigmmaf_filter),
#           df_runs %>% select(RUN = `Magic ID`, Patient) %>% filter(Patient == "12") %>% inner_join(df_bigmmaf_filter_het)) %>%
#   select(-CANONICAL) %>%
#   inner_join(df_canonical_transcripts) %>%
#   select(-N_VAR_PER_RUN_PER_GENE, -N_RUN_PER_GENE) %>%
#   add_exp() %>% 
#   write.table("~/Bureau/canonical_variants_homo_het_16IF93_v2.csv", sep = "\t", row.names = FALSE)


```

```{r cleanbigmmafcall, include=FALSE, warning=FALSE}

rm(df_distinct_call, df_distinct_filter)
rm(df_bigmmaf_call)
gc()

```

```{r varfilterbigmmaf, dependson="filterbigmmaf", cache=TRUE}

n_distinct_var <- df_bigmmaf_filter %>% ungroup() %>% distinct(CHR, POSITION, REF, ALT) %>% nrow
n_distinct_snv <- df_bigmmaf_filter %>% ungroup() %>% filter(TYPE == "SNV") %>% distinct(CHR, POSITION, REF, ALT) %>% nrow
n_distinct_indel <- df_bigmmaf_filter %>% ungroup() %>% filter(TYPE == "Indel") %>% ungroup() %>% distinct(CHR, POSITION, REF, ALT) %>% nrow
n_distinct_gene <- df_bigmmaf_filter %>% ungroup() %>% distinct(SYMBOL) %>% nrow

n_min_var <- df_bigmmaf_filter_stat %>% collect() %>% .[["N_VAR_TOT"]] %>% min
n_max_var <- df_bigmmaf_filter_stat %>% collect() %>% .[["N_VAR_TOT"]] %>% max

n_mean_indel <- df_bigmmaf_filter_stat %>% filter(TYPE == "Indel") %>% collect() %>% .[["N_VAR_PER_TYPE"]] %>% mean %>% round(0)
n_mean_snv <- df_bigmmaf_filter_stat %>% filter(TYPE == "SNV") %>% collect() %>% .[["N_VAR_PER_TYPE"]] %>% mean %>% round(0)

n_min_gene <- df_bigmmaf_filter_stat %>% collect() %>% .[["N_GENE"]] %>% min
n_max_gene <- df_bigmmaf_filter_stat %>% collect() %>% .[["N_GENE"]] %>% max

```

Après avoir appliqué les mêmes filtres que ceux décrit précédemment à l'exception du filtre n°1 ["Union"](#filterdescription) puisqu'ici nous avons uniquement des individus non apparentés, nous avons pu obtenir une liste de `r n_distinct_var` variants différents composés de `r n_distinct_snv` SNVs et `r n_distinct_indel` indels et impactant un total de `r n_distinct_gene` gènes distincts. Ces variants étant répartis sur l'ensemble de nos `r n_run_bigmmaf` patients ceux-ci portaient en moyenne `r n_mean_snv` SNVS et `r n_mean_indel` indels, de sorte que chacun d'entre eux avaient entre `r n_min_gene` et `r n_max_gene` gènes impactés par au moins un variants homozygote (**Figure : **\@ref(fig:plotfilterbigmmaf) - **A** et **B**).  

```{r plotfilterbigmmaf, dependson="filterbigmmaf", fig.cap=fig_info,fig.scap=fig_name, fig.height=5, cache=TRUE}

fig_name <- "Résultats de l'étape de filtrage"
fig_description_general <- "Chaque couleur définit un projet de séquençage caractérisé par un centre de séquençage et une année"
fig_description_A <- "**A** : Quantification du nombre de SNVs et indels ayant passé l'ensemble des filtres pour chaque patient"
fig_description_B <- "**B** : Nombre de gènes impactés par au moins un variant ayant passé les filtres pour chaque individu représenté par les barres"
fig_description_C <- "**C** : Présentation "

fig_description <- paste(fig_description_A, fig_description_B, fig_description_C, sep = ". ")
fig_info <- paste0(fig_name, " : ", fig_description)

pA <- ggplot(df_bigmmaf_filter_stat, aes("", N_VAR_PER_TYPE)) +
  geom_boxplot(outlier.size = -1, alpha = .8, aes(fill = TYPE)) + 
  geom_jitter(position=position_jitter(0.3)) +
  scale_fill_brewer(guide = "none", palette = "Set1") +
  facet_wrap(~factor(TYPE, levels = c("SNV", "Indel")), scales = "free") + 
  ylab("Nb of remaining variants after filters") + 
  xlab("") + 
  coord_flip() + 
  theme(axis.text.y = element_blank(),
        axis.ticks.y = element_blank())

pB <- ggplot(df_bigmmaf_filter_stat %>% group_by(RUN) %>% summarise(N_GENE = mean(N_GENE)), aes(reorder(RUN, -N_GENE), N_GENE)) + 
  geom_bar(stat = "identity", fill = "#999999") + 
  ylab("Nb of remaining genes") +
  xlab("Runs") + 
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank()) 

plot_grid(pA,pB, rel_heights = c(.33,.67), ncol = 1, labels = c("A","B"))

```

\newpage

```{r dfcil, dependson="filterbigmmaf", cache=TRUE}

df_bigmmaf_genes_distinct <- df_bigmmaf_filter  %>% 
  group_by(SYMBOL, EVIDENCE) %>% 
  mutate(N_RUN = n_distinct(RUN)) %>% 
  distinct(N_RUN) 

df_bigmmaf_genes_resume <- df_bigmmaf_genes_distinct %>% 
  group_by(N_RUN, EVIDENCE) %>% 
  summarise(N_GENE = n())

```

```{r varcil, cache=TRUE, dependson="dfcil"}

n_distinct_gene <- df_bigmmaf_filter %>% ungroup() %>% distinct(SYMBOL) %>% nrow

n_distinct_gene_more1_run <- df_bigmmaf_genes_resume %>% filter(N_RUN > 1) %>% collect() %>% .[["N_GENE"]] %>% sum
p_distinct_gene_more1_run <- ((n_distinct_gene_more1_run / n_distinct_gene) * 100) %>% round(1)
n_gene_cil <- df_bigmmaf_filter %>% ungroup() %>% filter(EVIDENCE != "Not in the list") %>% distinct(SYMBOL) %>% nrow
n_gene_cil_strong <- df_bigmmaf_filter %>% ungroup() %>% filter(EVIDENCE == "Strong") %>% distinct(SYMBOL) %>% nrow

```

Afin de nous orienter dans nos recherches, nous nous sommes basés sur une étude de 2012 qui établissait une liste des gènes humains pouvant être impliqués dans le cilliome humain [@Ivliev2012] en se basnat entre autre sur les gènes fournis par la base de données CilDB [@Arnaiz2015] mais aussi des analyses *in silico* permettant d'identifier des gènes jusqu'à présent jamais associés au ciliome. Ainsi, chaque gène était classé dans l'une des 3 catégories suivantes en fonction des preuves déjà existante (au moment de l'étude) permettant de lier un gène au cilliome humain : **Strong evidence from previous studies** (Strong), **Weak evidence from previous studies** (Weak) et **No evidence from previous studies** (Novel). L'utilisation de cette liste nous a permis d'ajouter une nouvelle annotation pertinente à nos gènes. En effet, le spermatozoïde humain est une cellule ciliée, et le flagelle en est le cil. Nous pouvons donc attendre à ce qu'une partie des gènes responsables du phénotype MMAF soit présents dans cette liste de `r n_cilliome_gene` gènes. 

Ainsi, `r n_gene_cil` de nos `r n_distinct_gene` gènes retenus faisaient partis de cette liste dont `r n_gene_cil_strong` présentaient des preuves fortes de leur appartenance au cilliome. Il faut tout de même noter que bien que cette liste soit un bon outil pour orienter les recherches et prioriser certains gènes, elle ne peut constituer un critère suffisant pour filtrer les gènes n'en faisant pas partie. Par exemple le gène *DNAH1*, de par son expression ubiquitaire n'a pas été intégré à cette liste (**Figure : **\@ref(fig:plotdnah1) - **A**), or on connait désormais son implication dans le phénotype MMAF (**Table :** \@ref(tab:tabcil), **Figure : **\@ref(fig:plotcil) - **A**).  

Parmi l'ensemble des gènes retrouvés mutés, on peut constater que `r n_distinct_gene - n_distinct_gene_more1_run` d'entre eux, soit `r 100 - p_distinct_gene_more1_run`%, ne sont observés muté, à l'état homozygote, uniquement chez un seul de nos patients tandis que `r n_distinct_gene_more1_run` sont retrouvés muté à l'état homozygote chez au moins 2 patients. Ainsi, analyser en priorité ces `r n_distinct_gene_more1_run` gènes permet à la fois de réduire considérablement notre liste, et donc de faciliter les analyses, mais aussi de pouvoir identifier en priorité les gènes affectant le plus grand nombre de patient et donc probablement les principaux acteurs du impliqués dans le phénotype MMAF (**Figure : **\@ref(fig:plotcil) - **B**).

\newpage 

```{r plotcil, dependson="dfcil", warning=FALSE, fig.height=7, fig.cap=fig_info,fig.scap=fig_name, cache=TRUE}

fig_name <- 'Répartition des gènes retrouvés mutés chez nos patients dans les différentes classes de la liste du cilliome'
fig_description_general <- "Chaque couleur définit une classe de la liste des gènes du cilliome décrit dans [@Ivliev2012]. Vert = *Strong evidence from previous studies* (*Strong*), Orange = *Weak evidence from previous studies* (*Weak*), rouge = *No evidence from previous studies* (*Novel*), bleu = Non présent dans la liste"
fig_description_A <- "**A** : Quantification du nombre de gène ayant passé les filtres au sein des 3 classes de la liste des gènes du cilliome"
fig_description_B <- "**B** : Quantification pour chacun des gènes du nombre d'individus présentant un variant homozygotes ayant passé l'ensemble des filtres"

fig_description <- paste(fig_description_general, fig_description_A, fig_description_B, sep = ". ")


fig_info <- paste0(fig_name, " : ", fig_description)

# color from Set1 palette : 
# #4DAF4A = Green
# #FF7F00 = Orange
# #E41A1C = Red
# #377EB8 = Blue

fill_A <- c("#4DAF4A", "#FF7F00", "#E41A1C")
order_A <- c("Strong", "Weak", "Novel")

fill_B <- c("#4DAF4A", "#FF7F00", "#E41A1C", "#377EB8")
order_B <- c("Strong", "Weak", "Novel", "Not in the list")

pA <- ggplot(df_bigmmaf_genes_distinct, aes(EVIDENCE)) +
  geom_bar(aes(fill = EVIDENCE)) +
    scale_x_discrete(limits = order_A) + 
  geom_text(stat='count',aes(label= ..count..), size = 5, vjust = -.25) +
  ylab("Nb of gene") +
  xlab("Evidence") +
  scale_fill_manual(guide = "none", limits = order_A, values = fill_A, breaks = order_A)  +
  theme(axis.title.x = element_blank())

pB <- ggplot(df_bigmmaf_genes_resume, aes(N_RUN, N_GENE)) + 
  geom_col(aes(fill = factor(EVIDENCE, levels = (order_B)))) +
  scale_x_reverse(breaks = c(1:15)) + 
  ylab("Nb of gene") + 
  xlab("Nb of individuals") +
  coord_flip() +
  scale_fill_manual(name = "Evidence", limits = order_B, values = fill_B, breaks = order_B) + 
  theme(legend.position = "bottom")

plot_grid(pA, pB, labels = c("A","B"), ncol = 1)

```

\newpage  

```{r tabcil}

x <- df_bigmmaf_genes_distinct %>% 
  ungroup() %>%
  filter(EVIDENCE != "Not in the list") %>% 
  mutate(EVIDENCE = factor(EVIDENCE, levels = c("Strong","Weak","Novel"))) %>%
  arrange(EVIDENCE) %>% 
  group_by(EVIDENCE) %>%
  summarise(N = n()) 

evidence_count <- x %>% collect() %>% .[["N"]]
evidence_label <- x %>% collect() %>% .[["EVIDENCE"]]

names(evidence_count) <- evidence_label


df_bigmmaf_genes_distinct %>%   ungroup() %>%
  filter(EVIDENCE != "Not in the list") %>% 
  mutate(EVIDENCE = factor(EVIDENCE, levels = c("Strong","Weak","Novel"))) %>%
  arrange(EVIDENCE, SYMBOL) %>%
  select(`Ciliome evidence` = EVIDENCE, Gene = SYMBOL) %>%

  kable("latex",
        longtable = TRUE,
        booktabs = TRUE, 
        caption = "Liste des gènes prédits comme faisant partie du ciliome humain retrouvés mutés à l'état homozygote chez nos patients") 
# 
# %>%
#   kableExtra::add_header_left(evidence_count, "Ciliome evidence")
  
  
```


\newpage

Nous avons ensuite *designer* 5 analyses fonctionnant de manière pyramidale. C'est à dire que la première analyse permet d'identifier les candidats les plus évidents tandis que la cinquième ceux pour lesquels il y a moins d'indices. L'interêt de ce fonctionnement est qu'à chacune des analyses, l'ensemble des variants portés par les patients pour lesquels un candidat a pu être déterminer avec **certitudes** seront retirés dans analyses suivantes. Ce procédé nous permettra ainsi après chacune de ces 5 analyses d'alléger notre liste de variants, et donc de gènes, rendant l'analyse suivante plus simple : 

1. **Analyse n°1** : Au moment de nos analyses, le gène *DNAH1* était encore le seul décrit comme responsable du phénotype MMAF faisant de lui un candidat évident pour expliquer le phénotype MMAF de nos patients malgré son expression non spécifique au testicule (**Figure : **\@ref(fig:plotdnah1) - **A**). C'est pourquoi nous avons recherché en priorité des patients portant des variants tronquants homozygotes sur ce gène.  

2. **Analyse n°2** : Dans second temps, nous avons sélectionné uniquement les gènes **présents dans la liste cilliome** sur lesquels **au moins deux** de nos patients présentaient au moins 1 variant tronquant à l'état **homozygote**.  

3. **Analyse n°3** : Ensuite, nous avons étudié les gènes **absents dans la liste cilliome**  mais sur lesquels on trouvait toujours **au moins deux** de nos patients présentant au moins 1 variant tronquant à l'état **homozygote**.  

4. **Analyse n°4** : Dans un troisième temps nous sommes revenus à étudier les gènes **présents dans la liste cilliome** en considérant cette fois-ci les gènes sur lesquels **un seul** de nos patients présentaient au moins 1 variant tronquant à l'état **homozygote**.  

5. **Analyse n°5** : Pour finir nous avons étudié les gènes **absents dans la liste cilliome** sur lesquels **un seul** de nos patients présentaient au moins 1 variant tronquant à l'état **homozygote**.

Chacune de ces analyses s'est ensuite déroulée en 5 étapes : 

1. **Étape n°1** : Cette première étape consistait à récupérer l'ensemble des patients répondant aux critères de l'analyse en question, par exemple : l'ensemble des patients portant un variant homozygote sur le gène *DNAH1* dans le cas de l'analyse n°1. Au vu de l'effet délétère des variants sélectionés au cours de cette étape, les preuves génétiques seront considérées comme de forte confiance (*High trust*).  

2. **Étape n°2** : Pour l'ensemble des gènes retenus dans l'étape n°1, nous recherchons ensuite des patients portant, **toujours à l'état homozygote**, des variant aux effets **non tronquants** tel que des variants faux-sens ou encore des variants intronique situés proches des sites d'épissage. Dans le cas des variants faux-sens, les logiciels SIFT et PolyPhen sont ensuite utilisés afin de nous orienter quant à l'effet délétère du variant, bien que comme nous l'avons déjà vu, ces logiciels son contredisent régulièrement [@Salgado2016] (**Figure :** \@ref(fig:vennpred)). Au vus de la difficulté à déterminer l'effet délétère de ces variants, les preuves génétiques seront considérées comme de confiance modérée (*Moderate trust*).    

3. **Étape n°3** : Cette étape consiste à rechercher des patients éventuellement hétérozygotes composites, c'est à dire des patients portant deux variants hétérozygotes différents sur chacun des deux allèles d'un même gène. Malheureusement, dans le cadre des séquençages WES et WGS, il est impossible de connaitre le "phasage" des variants, c'est à dire que l'on ne peut déterminer si deux variants hétérozygotes sont situés sur le même allèles ou sur deux allèles différents (**Figure : **\@ref(fig:compositehet)). Pour cela, des analyses de biologie moléculaire sont nécessaires. C'est pour cette raison que ces preuves génétiques seront considérées comme étant de faible confiance (*Low trust*). 

```{r compositehet,fig.cap=fig_info,fig.scap=fig_name, out.extra="scale=0.35"}

fig_name <- "Représentation schématique des ....TODO"
fig_description <- "Un variant est dit homozygote lorsque le **même** variant est présents sur les deux allèles d'un gène et hétérozygote lorsqu'il est présent sur **un seul** des deux allèles. On parlera d'hétérozygotes *cis* lorsque deux variants hétérozygotes différents seront positionnés sur **le même** allèle et d'hétérozygote *trans* (ou composite) lorsque ces deux variants hétérozygotes seront positionnés sur **deux allèles différents**. En WES et en WGS il est impossible de différentié les hétérozygotes *cis* des hétérozygotes *trans*"
fig_info <- paste(fig_name, fig_description, sep = " : ")

include_graphics("figure/hetero_composites.png")

```

4. **Étape n°4** : Au cours de cette étape, nous allons étudier chacun des gènes sélectionnés et déterminer au vus des différentes preuves génétiques, des données d'expressions de ces gènes mais aussi des informations disponibles dans la litterature, si ceux-ci sont de bons candidats pour expliquer le phénotype MMAF de nos patients. Il est à noter que **cette étape est la seul à ne pas être automatisée**. 

5. **Étape n°5** : Pour finir, les données des patients pour lesquels un gène candidat a été identifié et dont les preuves génétiques sont considérées comme de forte confiance (c'est à dire les patients identifiés lors de l'étape n°1) sont retirés de notre liste de variants allégeant ainsi celle-ci pour les analyses suivante.  

\newpage  

##### Analyse n°1 :     

```{r dfdnah1high, cache=TRUE, dependson="filterbigmmaf"}

df_dnah1_high <- df_bigmmaf_filter %>% 
  filter(SYMBOL == "DNAH1",
         IMPACT == "HIGH") %>%
  ungroup()

```

```{r vardnah1high, cache=TRUE, dependson="dfdnah1high"}

run_dnah1_high <- df_dnah1_high %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
n_run_dnah1_high <- run_dnah1_high %>% length
p_run_dnah1_high <- (n_run_dnah1_high / n_run_bigmmaf) %>% round(2) * 100

```

```{r dfdnah1moderate, cache=TRUE, dependson="filterbigmmaf"}

df_dnah1_moderate <-  df_bigmmaf_filter %>% 
  filter(SYMBOL == "DNAH1",
         IMPACT != "HIGH")

```

```{r vardnah1moderate}

run_dnah1_moderate <- df_dnah1_moderate %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
n_run_dnah1_moderate <- run_dnah1_moderate %>% length
p_run_dnah1_homo <- ((n_run_dnah1_high + n_run_dnah1_moderate) / n_run_bigmmaf) %>% round(2) * 100

```

```{r dfdnah1low}

df_dnah1_low <-  df_bigmmaf_filter_het %>% 
  filter(SYMBOL == "DNAH1",
         N_VAR_PER_RUN_PER_GENE > 1)

```

```{r vardnah1low, cache=TRUE, dependson="filterhetbigmmaf"}

run_dnah1_low <- df_dnah1_low %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
n_run_dnah1_low <- run_dnah1_low %>% length
p_run_dnah1_tot <- ((n_run_dnah1_high + n_run_dnah1_moderate + n_run_dnah1_low) / n_run_bigmmaf) %>% round(2) * 100

```

```{r resumednah1, dependson=c("dfdnah1high","dfdnah1moderate","dfdnah1low"), cache=TRUE}

df_resume_dnah1 <- bind_rows(df_dnah1_high %>% group_by(RUN, SYMBOL) %>% summarise(TRUST = "High"),
                             df_dnah1_moderate %>% group_by(RUN, SYMBOL) %>% summarise(TRUST = "Moderate"),
                             df_dnah1_low %>% group_by(RUN, SYMBOL) %>% summarise(TRUST = "Low")) %>% 
  group_by(TRUST, SYMBOL) %>%
  summarise(N_RUN = n_distinct(RUN)) %>% 
  select(SYMBOL, N_RUN, TRUST) %>%
  group_by(SYMBOL) %>% 
  mutate(TOT = sum(N_RUN)) 

```

```{r removednah1, dependson=c("extradata","filterbigmmaf","dfdnah1high","filterhetbigmmaf"), cache=TRUE}

run_found <- c(run_dnah1_high)

df_bigmmaf_filter2 <- df_bigmmaf_filter %>% 
  ungroup() %>%
  filter(!(RUN %in% run_found))  
  
df_bigmmaf_filter_het2 <- df_bigmmaf_filter_het %>% 
  ungroup() %>%
  filter(!(RUN %in% run_found))  

```

```{r varremovednah1, dependson="removednah1", cache=TRUE}

n_found <- run_found %>% length
n_distinct_var2 <- df_bigmmaf_filter2 %>% distinct(CHR, POSITION, REF, ALT) %>% nrow
n_distinct_gene2 <- df_bigmmaf_filter2  %>% distinct(SYMBOL) %>% nrow

```

1. **_DNAH1_** : Parmi l'ensemble de nos `r n_run_bigmmaf` patients MMAF `r n_run_dnah1_high` portait un indel homozygote entrainant un décalage du cadre de lecture sur le gène *DNAH1* et répertorié dans aucune des 3 bases de données qua nous avons utilisées. Le patient `r run_dnah1_moderate[1] %>% paste_vector("itallic")` était porteur de 3 variants homozygotes successifs entrainant tous un faux-sens tandis que le patient `r run_dnah1_moderate[2] %>% paste_vector("itallic")` portait lui 1 autre variant homozygote entrainant un faux-sens différent des 3 portés par `r run_dnah1_moderate[1] %>% paste_vector("itallic")`. On peut noter qu'aucun de ces 4 variants n'est répertorié dans les bases de données, cependant tous sont prédits comme *benign* par PolyPhen tandis que SIFT ne donne aucune prédiction. La recherche de patients potentiellement hétérozygotes composites nous a permis de révéler `r n_run_dnah1_low` patients portant tous 2 variants hétérozygotes sur le gène *DNAH1*. On peut alors noter le patients *Ghs36* porteur d'un premier variant créant un codon stop de manière prématuré et d'un second variant entrainant un faux-sens absent des 3 bases de données et prédit comme *probably damaging* par PolyPhen. Ainsi, s'ils étaient situés sur deux allèles différents, ces deux variants pourraient être des bons candidats pour expliquer le phénotype du patient *Ghs36*. On peut noter également le patient *Ghs129* portant deux faux-sens hétérozygote tout deux prédits comme *probably damaging* par PolyPhen et dont un seul est retrouvé dans la base de données ExAC avec une très faible fréquence. Pour les `r n_run_dnah1_low - 2` autres patients, il est plus difficile de se prononcer à ce stade compte tenus des fréquences parfois élevée des variants ou bien des prédictions fournies par PolyPhen.  

Cette première analyse nous a permis de révéler que `r n_run_dnah1_high + n_run_dnah1_moderate + n_run_dnah1_low` des `r n_run_bigmmaf` patients de notre cohorte portaient au moins 1 variant sur le gène *DNAH1* et que pour `r n_run_dnah1_high + n_run_dnah1_moderate` d'entre eux ce(s) variants étaient présents à l'état homozygote. Cependant, il faut noter que du fait de son effet tronquant sur la protéine, seul le variant homozygote porté par le patient `r run_dnah1_high %>% paste_vector("itallic")` nous permets d'être certains de la causalité du phénotype MMAF. C'est pourquoi, seul les données de ce patient seront retirées de notre liste de variants réduisant celle-ci à `r n_distinct_var2` variants chevauchant `r n_distinct_gene2` gènes (**Table :** \@ref(tab:annexetabafterdnah1)). Pour les `r n_run_dnah1_moderate + n_run_dnah1_low` autres patients, des analyses fonctionnelles complémentaires sont nécessaires.   

Ainsi, les mutations du gène *DNAH1* seraient ainsi responsables de manière certaine de `r p_run_dnah1_high` % des phénotype MMAF de notre cohorte. Ce pourcentage monte jusqu'à `r p_run_dnah1_tot`% si l'on considère l'ensemble des patients identifiés dans cette analyse.

Bien que ce pourcentage soit en deçà des 40% observés dans notre étude précédente [@BenKhelifa2014], ces résultats confirment néanmoins le rôle primordial de la protéine DNAH1 dans la structure du flagelle et l'implication majeure du gène *DNAH1* dans le phénotype MMAF.   


\newpage

```{r plotdnah1, dependson="resumednah1", fig.cap=fig_info, fig.height=8, fig.scap=fig_name, cache=TRUE}

fig_name <- "Analyse du gène *DNAH1*"
fig_description_A <- "Expression tissulaire du gène *DNAH1* d'après les données du projet Illumina BodyMap"
fig_description_B <- "Quantification du nombre de patients portant au moins un variant sur le gène *DNAH1* pour chacun des 3 niveau de confiance"

fig_description <- paste(fig_description_A, fig_description_B, sep = ". ")
fig_info <- paste0(fig_name, " : ", fig_description)

pA <- plot_expression("dnah1", "percent", TRUE) +
  xlab("") + 
  theme(legend.position = c(1,.5),
        legend.justification = c(1,.5))

pB <- plot_resume_analysis(df_resume_dnah1)

plot_grid(pA,pB, labels = c("A","B"), ncol = 1)


```

\newpage

```{r tabdnah1high}

tab_high(df_dnah1_high,
         caption = "Analyse n°1 : Liste des patients portant au moins un variant homozygote tronquant sur le gène *DNAH1*",
         landscape = TRUE)

```

```{r tabdnah1moderate}

tab_modelow(df_dnah1_moderate,
            caption = "Analyse n°1 : Liste des patients portant au moins un variant homozygote non tronquant sur le gène *DNAH1*",
            landscape = TRUE)

```

\newpage

```{r tabdnah1low}

tab_modelow(df_dnah1_low,
            caption = "Analyse n°1 : Liste des patients portant au moins deux variant hétérozygotes sur le gène *DNAH1*",
            landscape = TRUE)

```

\newpage

##### Analyse n°2  

```{r dfgrp1high, dependson="removednah1", cache=TRUE}

df_grp1_high <- df_bigmmaf_filter2 %>% 
  filter(IMPACT == "HIGH") %>%
  group_by(SYMBOL, Feature) %>%
  mutate(N_RUN = n_distinct(RUN)) %>% 
  filter(N_RUN > 1,
         EVIDENCE != "Not in the list") %>%
  ungroup()
  
```

```{r vargrp1high, dependson="dfgrp1high", cache=TRUE}

gene_grp1_high <- df_grp1_high %>% distinct(SYMBOL) %>% collect() %>% .[["SYMBOL"]]
n_gene_grp1_high <- gene_grp1_high %>% length

run_grp1_high <- df_grp1_high %>% ungroup() %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
n_run_grp1_high <- run_grp1_high %>% length 

run_armc2_high <- gene_to_run(df_grp1_high, "ARMC2") 
n_run_armc2_high <- run_armc2_high %>% length

run_cfap44_high <- gene_to_run(df_grp1_high, "CFAP44")
n_run_cfap44_high <- run_cfap44_high %>% length

run_ccdc146_high <- gene_to_run(df_grp1_high, "CCDC146")
n_run_ccdc146_high <- run_ccdc146_high %>% length

run_ttc29_high <- gene_to_run(df_grp1_high, "TTC29")
n_run_ttc29_high <- run_ttc29_high %>% length

```

```{r dfgrp1moderate, dependson="removednah1", cache=TRUE}

df_grp1_moderate <- df_bigmmaf_filter2 %>% 
  filter(SYMBOL %in% gene_grp1_high,
         IMPACT != "HIGH") %>%
  group_by(SYMBOL, Feature) %>%
  mutate(N_RUN = n_distinct(RUN)) %>% 
  ungroup()

```

```{r vargrp1moderate, dependson="dfgrp1moderate", cache=TRUE}

n_gene_grp1 <- df_grp1_moderate %>% ungroup() %>% distinct(SYMBOL) %>% nrow
run_grp1_moderate <- df_grp1_moderate %>% ungroup() %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
n_run_grp1_moderate <- run_grp1_moderate %>% length 

run_armc2_moderate <- gene_to_run(df_grp1_moderate, "ARMC2")
n_run_armc2_moderate <- run_armc2_moderate %>% length

run_cfap44_moderate <- gene_to_run(df_grp1_moderate, "CFAP44") 
n_run_cfap44_moderate <- run_cfap44_moderate %>% length

```

```{r dfgrp1low, dependson="removednah1", cache=TRUE}

df_grp1_low <- df_bigmmaf_filter_het2 %>% 
  filter(SYMBOL %in% gene_grp1_high,
    N_VAR_PER_RUN_PER_GENE > 1) %>% 
         group_by(SYMBOL, Feature) %>% 
  mutate(N_RUN = n_distinct(RUN)) %>% 
  ungroup()

```

```{r vargrp1low, dependson="dfgrp1low", cache=TRUE}

run_grp1_low <- df_grp1_low %>% ungroup() %>% distinct(RUN) %>% collect() %>% .[["RUN"]]

```

```{r dfresumegrp1, dependson=c("dfgrp1high","dfgrp1moderate","dfgrp1low"), cache=TRUE}

df_resume_grp1 <- bind_rows(df_grp1_high %>%
                              select(-EVIDENCE) %>%
                              mutate(TRUST = "High") %>%
                              group_by(SYMBOL) %>%
                              summarise(N_RUN = n_distinct(RUN), TRUST = "High"),
                            
                            df_grp1_moderate %>%
                              select(-EVIDENCE) %>%
                              group_by(SYMBOL) %>%
                              summarise(N_RUN = n_distinct(RUN), TRUST = "Moderate"),
                            
                            df_grp1_low %>%
                              select(-EVIDENCE) %>%
                              group_by(SYMBOL) %>%
                              summarise(N_RUN = n_distinct(RUN), TRUST = "Low")) %>%
  select(SYMBOL, N_RUN, TRUST) %>%
  group_by(SYMBOL) %>%
  mutate(TOT = sum(N_RUN))

```

```{r removegrp1, dependson=c("dfgrp1high","removednah1"), cache=TRUE}

run_found <- c(run_found, run_grp1_high)

df_bigmmaf_filter3 <- df_bigmmaf_filter2 %>% 
  filter(!(RUN %in% run_found))
   
df_bigmmaf_filter_het3 <- df_bigmmaf_filter_het2 %>% 
  filter(!(RUN %in% run_found))

```

```{r varremovegrp1, dependson="removegrp1", cache=TRUE}

n_found <- run_found %>% length
n_var_distinct3 <- df_bigmmaf_filter3 %>% ungroup %>% distinct(CHR, POSITION, REF, ALT) %>% nrow
n_gene_distinct3 <- df_bigmmaf_filter3 %>% ungroup %>% distinct(SYMBOL) %>% nrow
n_run_distinct3 <- df_bigmmaf_filter3 %>% ungroup %>% distinct(RUN) %>% nrow

```


Comme dit précédemment, dans cette analyse nous nous sommes concentrés sur les gènes **présents dans la liste cilliome** sur lesquels **au moins deux** de nos patients présentaient au moins 1 variant **homozygote** ayant un effet tronquant sur la protéine. Nous avons ainsi pu identifier les `r n_gene_grp1_high` gènes suivants : `r paste_vector(gene_grp1_high,"itallic")` : 


1. **_ARMC2_** : Sur ce gène, `r n_run_armc2_high` patients portent un variant homozygote tronquant : `r run_armc2_high %>% paste_vector("itallic")`. Le patient `r run_armc2_high[1] %>% paste_vector("itallic")` portent un indel créant un décalage du cadre de lecture tandis que `r run_armc2_high[2] %>% paste_vector("itallic")` porte un variant créant un codon stop prématuré (**Table : **\@ref(tab:tabgrp1high)). Le patient`r run_armc2_moderate %>% paste_vector("itallic")` porte quant à lui un variant faux-sens prédit comme *deleterious* par SIFT et *probably damaging* par PolyPhen. Nous pouvons également noter qu'aucun des variants portés par ces `r n_run_armc2_high + n_run_armc2_moderate` sont absents des 3 bases de données. Les arguments génétiques mentionnés couplés à la forte expression testiculaire de ce gène (**Figure : **\@ref(fig:plotgrp1high) - **B**) font de celui-ci un très bon candidat pour expliquer le phénotype de ces `r n_run_armc2_high + n_run_armc2_moderate` bien que des analyses fonctionnelles soient nécéssaires pour `r run_armc2_moderate %>% length` d'entre eux.  

2. **_CFAP44_** : Comme *ARMC2*, `r n_run_cfap44_high` patients portent un variant homozygote tronquant. `r run_cfap44_high[1] %>% paste_vector("itallic")` porte un variant stop et `r run_cfap44_high[2] %>% paste_vector("itallic")` un variant affectant un site donneur d'épissage. Le fait qu'aucun de ces variant ne soir répertorié dans aucune des bases de données laisse supposer qu'ils sont tous deux très rares. Le patient `r run_cfap44_moderate[1] %>% paste_vector("itallic")` porte un variant faux-sens prédit comme *tolerated* par SIFT et *possibly damaging* par PolyPhen. Les preuves fortes impliquant ce gène dans le cilliome humain ainsi que les effets délétères retrouvé chez `r n_run_cfap44_high` des `r n_run_cfap44_high +  n_run_cfap44_moderate` portant des mutations sur ce gène font de *CFAP44* un autre très bon candidat malgré son expression non spécifique au testicule (**Table : **\@ref(tab:tabgrp1high) et \@ref(tab:tabgrp1moderate), **Figure : **\@ref(fig:plotgrp1high) - **B**).      

3. **_CCDC146_** : Sur ce gène, seuls les patients `r run_ccdc146_high %>% paste_vector("itallic")` sont retrouvés mutés. Cependant, ces deux patients portent tous deux des variants homozygotes induisant respectivement un variant un codon stop prématuré et un décalage du cadre de lecture. Le premier de ces variants est retrouvé à une fréquence très faible à la fois dans ESP et ExAC, tandis que le second est totalement absent de l'ensemble des bases de données. On peut également ajouter que ce gène décrit comme faisant partie du cilliome humain avec de fortes preuves présente également une expression testiculaire relativement élevée. Pour finir, la protéine CCDC146 codée par le gène *CCDC146* avait déjà été décrite comme composant du centrosome spermatique, un organite ayant un rôle dans l'orientation des cellules et étant à l'origine des cils et des flagelles [@Firat-Karalar2014] renforçant ainsi les arguments de l'implication de ce gène dans le phénotype MMAF nous permettent ainsi d'affirmer que ces variants sont responsables du phénotype MMAF de ces `r n_run_ccdc146_high` patients (**Table : **\@ref(tab:tabgrp1high) et \@ref(tab:tabgrp1moderate), **Figure : **\@ref(fig:plotgrp1high) - **B**).    

4. **_TTC29_** : Sur ce gène, les patients `r run_ttc29_high %>% paste_vector("itallic")` portent la même variation retrouvée à très faible fréquence dans les trois bases de données et impactant un site donneur d’épissage du transcrit induisant la production d’une protéine aberrante. Ce gène à très forte expression testiculaire avait déjà été décrit en 2014 comme localisant au niveau de l'axonème du flagelle et qu'un *knock-down* entrainait des défauts de la cilliogénèse [@Chung2014] faisant de celui-ci un bon candidat pour expliquer le phénotype de ces `r n_run_ttc29_high` patients  (**Table : **\@ref(tab:tabgrp1high) et \@ref(tab:tabgrp1moderate), **Figure : **\@ref(fig:plotgrp1high) - **B**).

Cette première analyse au cours de laquelle nous avons sélectionné les gènes retrouvés présents dans la liste cilliome et sur lesquels au moins deux de nos patients présentaient au moins 1 variant homozygote ayant un effet tronquant sur la protéine nous a permis de mettre en évidence `r n_gene_grp1_high` nouveaux gènes candidats : `r gene_grp1_high %>% paste_vector("itallic")` retrouvés mutés à l'état homozygote chez `r n_run_grp1_high + n_run_grp1_moderate` de nos patients dont `r n_run_grp1_high` avec des variants tronquants soit `r (n_run_grp1_high / (n_run_bigmmaf - length(n_found))) %>% round(3) * 100`% des patients restant dans notre cohorte. Pour les `r n_run_grp1_moderate` autres, des analyses fonctionnelles sont nécessaires afin de pouvoir être sûr ce leurs variants sont bien responsables de leur phénotype. La cause génétique responsable du phénotype des patients `r run_grp1_high %>% paste_vector("itallic")` ayant été identifiées avec certitude, l'ensemble de leurs données de variants sont retirées de nos liste réduisant ainsi celle-ci à `r n_var_distinct3` chevauchant `r n_gene_distinct3` et répartis sur `r n_run_distinct3`. Les données des patients `r run_grp1_moderate %>% paste_vector("itallic")` sont, elles, conservées afin de voir si un meilleur candidat pourrait expliquer le phénotype de ces patients. 

\newpage

```{r plotgrp1high, fig.height=7.2, dependson=c("vargrp1","dfresumegrp1","localfunction"), fig.cap=fig_info,fig.scap=fig_name, cache=TRUE}

fig_name <- "Analyse des gènes sélectionnés dans l'Analyse n°1"
fig_description_A <- "Expression tissulaire des gènes retenus d'après les données du projet de transcriptome Illumina bodyMap"
fig_description_B <- "Résumé de l'Analyse 1, quantification du nombre de patients retrouvés mutés sur chacun des gènes retenus ainsi que du degré de confiance accordé à la cause génétique"
fig_description <- paste(fig_description_A, fig_description_B, sep = ". ")
fig_info <- paste0(fig_name, " : ", fig_description)

pA <- plot_resume_analysis(df_resume_grp1)

pB <- plot_expression(gene_grp1_high, mode = "percent", flip = TRUE) + 
  xlab("") + 
  theme(legend.position = c(1,.5),
        legend.justification = c(1,.5))

plot_grid(pA,pB, labels = c("A","B"), ncol = 1)

```

\newpage

```{r tabgrp1high}

tab_high(df_grp1_high,
         caption = "Analyse n°2 : List des gènes présents dans la liste ciliome sur lesquels au moins deux patients portent une mutation tronquante homozygote",
         landscape = TRUE)

```


```{r tabgrp1moderate}

tab_modelow(df_grp1_moderate,
            caption = paste0("Analyse n°2 : Liste des patients portant un variant non troquant homozygote sur un des gènes suivant : ", paste_vector(gene_grp1_high)),
            landscape = TRUE)

```

\newpage

##### Analyse n°3  

```{r dfgrp2high, dependson="removegrp1", cache=TRUE}

df_grp2_high <- df_bigmmaf_filter3 %>% 
  filter(IMPACT == "HIGH") %>%
  group_by(SYMBOL, Feature) %>%
  mutate(N_RUN = n_distinct(RUN)) %>% 
  filter(N_RUN > 1) %>% 
  filter(SYMBOL != "hsa-mir-150") %>% 
  ungroup()

df_distinct_gene_grp2_high <- df_grp2_high %>%
  distinct(SYMBOL, N_RUN)

```

```{r vargrp2high, dependson="dfgrp2high", cache=TRUE}

gene_grp2 <- df_grp2_high %>% ungroup() %>% distinct(SYMBOL) %>% collect() %>% .[["SYMBOL"]]
n_gene_grp2 <- gene_grp2 %>% length

run_grp2_high <- df_grp2_high %>% ungroup() %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
n_run_grp2_high <- run_grp2_high %>% length

n_run_max_grp2 <- df_distinct_gene_grp2_high %>% collect() %>% .[["N_RUN"]] %>% max

run_cfap43_high <- df_grp2_high %>% gene_to_run("CFAP43")
run_fsip2_high <- df_grp2_high %>% gene_to_run("FSIP2")
run_ccdc129_high <- df_grp2_high %>% gene_to_run("CCDC129")
run_ica1_high <- df_grp2_high %>% gene_to_run("ICA1")
run_trav26_high <- df_grp2_high %>% gene_to_run("TRAV26-1")
run_ica1_trav26_high <- df_grp2_high %>% gene_to_run(c("ICA1", "TRAV261"))
run_baz1a_high <- df_grp2_high %>% gene_to_run("BAZ1A")
run_naca_high <- df_grp2_high %>% gene_to_run("NACA")

n_run_cfap43_high <- run_cfap43_high %>% length
n_run_fsip2_high <- run_fsip2_high %>% length
n_run_ccdc129_high <- run_ccdc129_high %>% length
n_run_sart3_high <- df_grp2_high %>% gene_to_run("SART3") %>% length
n_run_ica1_high <- run_ica1_high %>% length
n_run_trav26_high <- run_trav26_high %>% length
n_run_ica1_trav26_high <- run_ica1_trav26_high %>% length
n_run_baz1a_high <- run_baz1a_high %>% length
n_run_naca_high <- run_naca_high %>% length

```

```{r dfgrp2moderate, dependson="removegrp1",cache=TRUE}

df_grp2_moderate <- df_bigmmaf_filter3 %>% 
  filter(IMPACT != "HIGH",
         SYMBOL %in% gene_grp2) %>%
  group_by(SYMBOL) %>%
  mutate(N_RUN = n_distinct(RUN))

```

```{r vargrp2moderate, dependson="dfgrp2moderate", cache=TRUE}

n_run_grp2_moderate <- df_grp2_moderate %>% ungroup() %>% distinct(RUN) %>% nrow

run_cfap43_moderate <- df_grp2_moderate %>% gene_to_run("CFAP43")
n_run_cfap43_moderate <- run_cfap43_moderate %>% length


run_fsip2_moderate <- df_grp2_moderate %>% gene_to_run("FSIP2")
n_run_fsip2_moderate <- run_fsip2_moderate %>% length


```

```{r dfgrp2low, dependson="removegrp1",cache=TRUE}

df_grp2_low <- df_bigmmaf_filter_het3 %>% 
  filter(SYMBOL %in% gene_grp2,
    N_VAR_PER_RUN_PER_GENE > 1) %>% 
         group_by(SYMBOL, Feature) %>% 
  mutate(N_RUN = n_distinct(RUN)) %>% 
  ungroup()

```

```{r vargrp2low, dependson="dfgrp2low", cache=TRUE}

n_run_grp2_low <- df_grp2_low %>% ungroup() %>% distinct(RUN) %>% nrow

run_cfap43_low <- df_grp2_low %>% gene_to_run("CFAP43")
n_run_cfap43_low <- run_cfap43_low %>% length

run_fsip2_low <- df_grp2_low %>% gene_to_run("FSIP2")
n_run_fsip2_low <- run_fsip2_low %>% length

```

```{r dfresumegrp2, dependson=c("dfgrp2highreduce","dfgrp2moderate","dfgrp2low"), cache=TRUE}

df_resume_grp2 <- bind_rows(df_grp2_high %>% group_by(RUN, SYMBOL) %>% summarise(TRUST = "High"),
                            df_grp2_moderate %>% group_by(RUN, SYMBOL) %>% summarise(TRUST = "Moderate"),
                            df_grp2_low %>% group_by(RUN, SYMBOL) %>% summarise(TRUST = "Low")) %>% 
  group_by(TRUST, SYMBOL) %>%
  summarise(N_RUN = n_distinct(RUN)) %>% 
  select(SYMBOL, N_RUN, TRUST) %>%
  group_by(SYMBOL) %>% 
  mutate(TOT = sum(N_RUN)) 

```

```{r dfgrp2retained, dependson="dfgrp2high", cache=TRUE}

gene_grp2_retained <- c("CFAP43", "CCDC129","FSIP2","BAZ1A")

df_grp2_high_retained <- df_grp2_high %>%
  filter(SYMBOL %in% gene_grp2_retained) 

df_grp2_moderate_retained <- df_grp2_moderate %>%
  filter(SYMBOL %in% gene_grp2_retained) 

df_grp2_low_retained <- df_grp2_low %>%
  filter(SYMBOL %in% gene_grp2_retained) 

df_resume_grp2_retained <- bind_rows(df_grp2_high_retained %>% group_by(RUN, SYMBOL) %>% summarise(TRUST = "High"),
                                    df_grp2_moderate_retained %>% group_by(RUN, SYMBOL) %>% summarise(TRUST = "Moderate"),
                                    df_grp2_low_retained %>% group_by(RUN, SYMBOL) %>% summarise(TRUST = "Low")) %>% 
  group_by(TRUST, SYMBOL) %>%
  summarise(N_RUN = n_distinct(RUN)) %>% 
  select(SYMBOL, N_RUN, TRUST) %>%
  group_by(SYMBOL) %>% 
  mutate(TOT = sum(N_RUN)) 


```

```{r vargrp2reduce, cache=TRUE, dependson="dfgrp2retained"}

n_gene_grp2_retained <- gene_grp2_retained %>% length

run_grp2_high_retained <- df_grp2_high_retained %>% ungroup %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
n_run_grp2_high_retained <- run_grp2_high_retained %>% length

run_grp2_moderate_retained <- df_grp2_moderate_retained %>% ungroup %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
n_run_grp2_moderate_retained <- run_grp2_moderate_retained %>% length

run_grp2_low_retained <- df_grp2_low_retained %>% ungroup %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
n_run_grp2_low_retained <- run_grp2_low_retained %>% length

```

```{r removegrp2, cache=TRUE, dependson=c("removegrp1","dfgrp2retained")}

run_found <- c(run_found, run_grp2_high_retained)

df_bigmmaf_filter4 <- df_bigmmaf_filter3 %>% 
  filter(!(RUN %in% run_found))
   
df_bigmmaf_filter_het4 <- df_bigmmaf_filter_het3 %>% 
  filter(!(RUN %in% run_found))

```

```{r varremovegrp2, cache=TRUE, dependson="removegrp2"}

n_var_after_grp2 <- df_bigmmaf_filter4 %>% ungroup() %>% distinct(CHR, POSITION, REF, ALT) %>% nrow()
n_gene_after_grp2 <- df_bigmmaf_filter4 %>% ungroup() %>% distinct(SYMBOL) %>% nrow()
n_run_after_grp2 <- df_bigmmaf_filter4 %>% ungroup() %>% distinct(RUN) %>% nrow()

```

Pour rappel, au cours de cette analyse, nous avons étudié les gènes **absents dans la liste cilliome**  mais sur lesquels on trouvait toujours **au moins deux** de nos patients présentant au moins 1 variant tronquant à l'état **homozygote**. `r n_run_grp2_high` patients différents portaient ainsi au moins un variant homozygote tronquant sur l'un des `r n_gene_grp2` gènes suivants : `r gene_grp2 %>% paste_vector("itallic")`.

1. **_CFAP43_** : `r n_run_cfap43_high + n_run_cfap43_moderate + n_run_cfap43_low` patients portent au moins 1 variant sur le gène *CFAP43*. Parmi ceux-ci, les patients `r run_cfap43_high %>% paste_vector("itallic")` portent une mutation tronquante à l'état homozygote soit absente des bases de données soit présentent avec une très faible fréquence. Le patient `r run_cfap43_moderate %>% paste_vector("itallic")` lui porte un variant homozygote intronique au situé au sein de la région d'épissage (et non sur un site donneur ou accepteur). Bien que ce type de variants puissent effectivement avoir un impact sur l'épissage, il pourrait également être sans effet, or, il est difficile de le prédire à ce stade. (TODO :: faire tourner un algo de prédiction). Le patient `r run_cfap43_low %>% paste_vector("itallic")` en revanche semble plus intéressant, puisque celui-ci porte deux variant hétérozygotes sur le gène *CFAP43* parmi lesquels un est un indel entrainant un décalage du cadre de lecture tandis que l'autre est un faux-sens prédit comme *possibly damaging* par Polyphen, bien qu'il soit annoté *tolerated* par SIFT. Malgré une expression ubiquitaire (**Figure : **\@ref(fig:plotgrp2) - **B**), le nombre important de patients portant des variant sur celui-ci, notamment `r n_run_cfap43_high` portant des variants tronquants homozygote font de ce gène un bon candidat.  

2. **_FSIP2_** :  Comme pour le gène *CFAP43*, `r n_run_cfap43_high + n_run_cfap43_moderate + n_run_cfap43_low` de nos patients portaient 1 variant sur le gène *FSIP2* cependant pour seulement `r n_run_fsip2_high` d'entre eux ce variant était tronquant à l'état homozygote.  En effet, les patients `r run_fsip2_high %>% paste_vector("itallic")` portent tous deux un indel entrainant un décalage du cadre de lecture dont aucun n'est répertorié dans les bases de données. Le patient `r run_fsip2_moderate %>% paste_vector("itallic")` porte lui un faux-sens homozygote prédit comme *benign* par PolyPhen. `r n_run_fsip2_low` autres patients portent au moins deux variants hétérozygote sur ce gène, cependant la plupart sont des faux-sens prédit également comme *benign* par PolyPhen. Bien que l'effet sur la protéine des variants portés par `r n_run_fsip2_moderate + n_run_fsip2_low` des `r n_run_fsip2_high + n_run_fsip2_moderate + n_run_fsip2_low` patients portant au moins un variant sur ce gène soit incertains, les variants tronquant portés par les patients `r run_fsip2_high %>% paste_vector("itallic")` ainsi que sa forte expression testiculaire et le fait que son implication dans la structure de la gaine fibreuse du flagelle spermatique ait été montrée en 2003 [@Brown2003] font de ce gène un excellent candidat pour expliquer le phénotype d'au moins `r n_run_fsip2_high` patients. Pour les autres, des analyses fonctionnelles seront nécessaires.  

3. **_SART3_** : Un total de `r n_run_sart3_high` patients portait **le même** variants homozygote. Ces patients étant tous issus du même projet de séquençage (Strasbourg 2012) ce variant pourrait parfaitement être un artefact dû au protocole de séquençage. Cette hypothèse est d'autant plus probable que l'ensemble des patients séquencés dans ce projet présentaient un phénotype MMAF, ainsi, aucun des individus de notre cohorte contrôle n'a donc pu servir à filtrer les variants artefactuels issus de ce projet. De plus, on peut constater que l'expression tissulaire de ce gène est ubiquitaire. Pour ces différentes raisons, ce gène n'a pas été retenu comme candidat dans nos analyses.

4. **_ICA1_ et _TRAV26-1_** :  Ces deux gènes sont chacun retrouvés présentant des variants homozygotes tronquant chez `r c(n_run_ica1_high + n_run_trav26_high) %>% mean` de nos patients. Pour chaque gène on peut noter que c'est à chaque fois le même variant qui est partagé par les trois patients ce qui est asses étonnant étant donné le fait que ces patients ne sont pas apparentés et n'ont pas été séquencés lors du même projet de séquençage. De plus, on peut observer que le patient `r run_ica1_high[2] %>% paste_vector("itallic")` porte un variant sur chacun de ces deux gènes, de même qu'il en portait également un sur le gène *SART3*. L'expression testiculaire de ces deux gènes apparait elle aussi très faible. De plus, la bibliographie du gène *ICA1* révèle que celui-ci est principalement exprimé dans le pancréas [@Mally1996, @Stassi1997] et que celui-ci serait à la fois lié au diabète de type 1 [@Martin1995, @Gaedigk1994, @Martin1996] et au syndrome de Gougerot-Sjögren [@Winer2002]. Malgré le nombre important de patients présentant des variants homozygotes tronquant sur ces deux gènes, ceux-ci n'ont pas été retenus comme candidat pour expliquer le phénotype MMAF de ces `r n_run_ica1_trav26_high` patients.  

5. **_BAZ1A_** : Sur ce gène, les patient `r run_baz1a_high %>% paste_vector("itallic")` portent tous deux le même indel à l'état homozygote. Celui-ci entrainant un décalage du cadre de lecture induit la formation d'une protéine aberrente. L'absence de cette indel dans les trois bases de données laisse supposer une faible fréquence de ce variant dans la population générale. Bien que ce gène présente une faible expression testiculaire, une étude de 2013 effectuée chez la souris a démontré son rôle majeur dans la spermatogénèse, les souris *KO* *Baz1a*^{-/-} présentaient de nombreux défauts tel que des spermatozoïdes non motiles, présentant une morphologie de la tête et du flagelle aberrante [@Dowdle2013] faisant ainsi de ce gène un bon candidat pour expliquer le phénotype de ces `r n_run_baz1a_high` patients. 

6. **_CCDC129_** : Ce gène est retrouvé muté à l'état homozygote chez `r n_run_ccdc129_high` patients porteur du même indel, non répertorié dans les bases de données, causant un décalage du cadre de lecture. On peut également constate que ce gène possède une expression testiculaire forte et exclusive faisant ainsi de ce gène un bon candidat malgré une littérature pauvre à son sujet.   

7. **_NACA_** : `r n_run_naca_high` patients partagent le même variant homozygote causant un décalage du cadre de lecture sur le gène *NACA*. On peut noter que les patient *Ghs37*  et *Ghs37* portaient porteurs respectifs de variant homozygote tronquant sur les gène *CCDC146* et *ARMC2* portaient également ce même variant. L'ensemble de ces patients provenant du même projet de séquençage (Strasbourg 2012), cela laisse supposer que comme pour *SART3*, ce variant est artefactuel. On peut d'ailleurs noter que le patient *Ghs41* était lui aussi porteur du variant sur *SART3* renforçant ainsi l'hypothèse de l'erreur de séquençage. Pour ces raisons, ce gène n'a pas été retenu en tant que candidat.

Dans cette analyse, `r n_gene_grp2` gène ont dans un premier temps été identifiés. Cependant, une analyse plus approfondie a fait que seuls les gènes `r gene_grp2_retained %>% paste_vector("itallic")` ont été retenus. Les variants présent sur les gènes *SART3* et *NACA* étant probablement des artefacts dus aux erreurs de séquençage. Dès lors, seuls `r gene_grp2_retained %>% length` des `r gene_grp2 %>% length` gènes identifiés présentaient des arguments suffisamment convainquant pour être considéré comme responsable du phénotype MMAF. Ainsi, `r n_run_grp2_high_retained + n_run_grp2_moderate_retained + n_run_grp2_low_retained` de nos patients sont porteurs de variants sur l'un de ces gènes dont `r n_run_grp2_high_retained + n_run_grp2_moderate_retained` à l'état homozygote avec notamment les patients `r run_grp2_high_retained %>% paste_vector("itallic")` porteur de variants homozygotes tronquants. Les gènes `r gene_grp2_retained %>% paste_vector("itallic")` étant de bons candidats et les données génétiques des `r n_run_grp2_high_retained` patients précédemment cités étant suffisamment fortes, l'ensemble de leurs variant furent ainsi retirés de notre liste contenant désormais `r n_var_after_grp2` variants et `r n_gene_after_grp2` gènes différents.  

\newpage  

```{r plotgrp2, fig.height=7.2, dependson=c("vargrp2","dfresumegrp2","localfunction"), fig.cap=fig_info,fig.scap=fig_name, cache=TRUE}

fig_name <- "Analyse des gènes sélectionnés dans l'Analyse n°2"
fig_description_A <- "Expression tissulaire des gènes retenus d'après les données du projet de transcriptome Illumina bodyMap"
fig_description_B <- "Résumé de l'Analyse 2, quantification du nombre de patients retrouvés mutés sur chacun des gènes retenus ainsi que du degré de confiance accordé à la cause génétique"
fig_description <- paste(fig_description_A, fig_description_B, sep = ". ")
fig_info <- paste0(fig_name, " : ", fig_description)

pA <- plot_resume_analysis(df_resume_grp2)

pB <- plot_expression(gene_grp2, mode = "percent", flip = TRUE) + 
  xlab("") + 
  theme(legend.position = c(1,.5),
        legend.justification = c(1,.5))

plot_grid(pA,pB, labels = c("A","B"), ncol = 1)

```

\newpage  

```{r tabgrp2high, dependson=c("localfunction","dfgrp2"), cache=TRUE}

tab_high(df_grp2_high,
         caption = "Analyse n°3 : List des gènes sur lesquels au moins deux patients portent une mutation tronquante non présents dans la liste ciliome",
         evidence = FALSE,
         landscape = TRUE) 

```

\newpage

```{r tabgrp2moderate, dependson=c("localfunction","dfgrp2moderate"), cache=TRUE}

tab_modelow(df_grp2_moderate,
            caption = paste0("Analyse n°3 : Liste des patients portant un variant non troquant homozygote sur un des gènes suivant : ", paste_vector(gene_grp2, "itallic")),
            landscape = TRUE)

```

```{r tabgrp2low, dependson=c("localfunction","dfgrp2low"), cache=TRUE}

tab_modelow(df_grp2_low,
            caption = paste0("Analyse n°3 : Liste des patients portant un variant non troquant homozygote sur un des gènes suivant : ", paste_vector(gene_grp2, "itallic")),
            landscape = TRUE) %>%
  column_spec(3, width = "11em" )

```

\newpage

##### Analyse n°4  

```{r dfgrp3high, dependson="removegrp2", cache=TRUE}

df_grp3_high <- df_bigmmaf_filter4 %>% 
  group_by(SYMBOL, Feature) %>%
  mutate(N_RUN = n_distinct(RUN)) %>% 
  filter(N_RUN == 1) %>% 
  filter(IMPACT == "HIGH",
         EVIDENCE != "Not in the list") %>% 
  ungroup()

```

```{r vargrp3high, cache=TRUE, dependson="dfgrp3high"}

gene_grp3 <- df_grp3_high %>% distinct(SYMBOL) %>% collect() %>% .[["SYMBOL"]]
n_gene_grp3 <- gene_grp3 %>% length

run_grp3_high <- df_grp3_high %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
n_run_grp3_high <- run_grp3_high %>% length

run_c6orf118_high <- df_grp3_high %>% gene_to_run("C6orf118")
n_run_c6orf118_high <- run_c6orf118_high %>% length

run_c21orf59_ccdc65_high <- df_grp3_high %>% gene_to_run(c("C21orf59","CCDC65"))
n_run_c21orf59_ccdc65_high <- run_c21orf59_ccdc65_high %>% length

run_spef2_high <- df_grp3_high %>% gene_to_run("SPEF2")

```

```{r dfgrp3moderate, dependson="removegrp2", cache=TRUE}

df_grp3_moderate <- df_bigmmaf_filter4 %>% 
  filter(IMPACT != "HIGH",
         SYMBOL %in% gene_grp3) %>% 
  ungroup()

```

```{r vargrp3moderate, dependson="dfgrp3moderate", cache=TRUE}

run_grp3_moderate <- df_grp3_moderate %>% distinct(RUN) %>% collect() %>% .[["RUN"]]

run_grp3_moderate <- df_grp3_moderate %>% length


```

```{r dfgrp3low, dependson="removegrp2", cache=TRUE}

df_grp3_low <- df_bigmmaf_filter_het4 %>% 
  filter(N_VAR_PER_RUN_PER_GENE > 1,
         SYMBOL %in% gene_grp3) %>% 
  ungroup()

```

```{r vargrp3low, dependson="dfgrp3low", cache=TRUE}

run_grp3_low <- df_grp3_low %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
n_run_grp3_low <- run_grp3_low %>% length
gene_grp3_low <- df_grp3_low %>% distinct(SYMBOL) %>% collect() %>% .[["SYMBOL"]] 


run_c6orf118_low <- df_grp3_low %>% gene_to_run("C6orf118")
n_run_c6orf118_low <- run_c6orf118_low %>% length

```

```{r dfresumegrp3, dependson=c("dfgrp3high","dfgrp3moderate","dfgrp3low"), cache=TRUE}

df_resume_grp3 <- bind_rows(df_grp3_high %>% group_by(RUN, SYMBOL) %>% summarise(TRUST = "High"),
                            df_grp3_moderate %>% group_by(RUN, SYMBOL) %>% summarise(TRUST = "Moderate"),
                            df_grp3_low %>% group_by(RUN, SYMBOL) %>% summarise(TRUST = "Low")) %>% 
  group_by(TRUST, SYMBOL) %>%
  summarise(N_RUN = n_distinct(RUN)) %>% 
  select(SYMBOL, N_RUN, TRUST) %>%
  group_by(SYMBOL) %>% 
  mutate(TOT = sum(N_RUN))

```

```{r removegrp3, cache=TRUE, dependson=c("vargrp3high","removegrp2")}

run_found <- c(run_found, run_grp3_high)

df_bigmmaf_filter5 <- df_bigmmaf_filter4 %>% 
  filter(!(RUN %in% run_found))
   
df_bigmmaf_filter_het5 <- df_bigmmaf_filter_het4 %>% 
  filter(!(RUN %in% run_found)) 

```

```{r varremovegrp3, cache=TRUE, dependson="removegrp3"}

n_var_after_grp3 <- df_bigmmaf_filter5 %>% ungroup() %>% distinct(CHR, POSITION, REF, ALT) %>% nrow()
n_gene_after_grp3 <- df_bigmmaf_filter5 %>% ungroup() %>% distinct(SYMBOL) %>% nrow()
n_run_after_grp3 <- df_bigmmaf_filter5 %>% ungroup() %>% distinct(RUN) %>% nrow()

```

Dans cette troisième analyse,  nous avons sélectionné à nouveau les gènes **présents dans la liste cilliome** en conservant cette fois-ci ceux sur lesquels **un seul** de nos patients présentaient au moins 1 variant tronquant à l'état **homozygote**. Les `r n_gene_grp3` gènes suivant correspondaient à ces critères : `r gene_grp3 %>% paste_vector("itallic")` tous présentant de fortes preuves indiquant leur appartenance au ciliome humain. 

1. **_C6orf118_** :  Ce gène a été retrouvé muté à l'état homozygote chez le patient `r run_c6orf118_high %>% paste_vector("itallic")` qui portait une substitution entrainant la formation d'un codon stop prématuré. Il faut noter que ce même patient portait également des variants homozygotes tronquant sur les gènes *SART3*, *TRAV26-1*, et *ICA1* cependant la forte expression testiculaire de ce gène en fait un meilleur candidat. Le patient `r run_c6orf118_low %>% paste_vector("itallic")` quant à lui porte deux variants faux-sens hétérozygote Le premier étant prédit probably *damaging* par PolyPhen et *tolerated low confidence* par SIFT tandis que le second est prédit *possibly damaging* et *tolerated*, il est difficile de se prononcer quant à l’effet délétère de ces deux variants sans effectuer d'analyses fonctionnelles. Il faut noter que *C6orf118* présente une forte expression dans le poumon. De plus, ce gène a récemment été décrit comme étant associé au phénotype de tuberculose pulmonaire [@Hong2017]. Cependant cela n'est en rien contradictoire avec le phénotype MMAF de ces `r n_run_c6orf118_high + n_run_c6orf118_low` patients, le poumon comprenant de nombreuses cellules ciliées, notamment au niveau de l'épithélium respiratoire, il n'est donc pas surprenant que des gènes du flagelle aient également une fonction au sein d'autres organes ciliés.

2. **_C21orf59_ et _CCDC65_** :  Les patients `r run_c21orf59_ccdc65_high %>% paste_vector("itallic")` porte tout deux des indels induisant un décalage du cadre de lecture, le premier sur le gène *C21orf59*, le second sur *CCDC65* deux gènes déjà connu pour être impliqué dans la formations des cils. En effet, la protéine NYD-SP28 (ancien nom de CCDC65) avait déjà caractérisé comme faisant partie du flagelle spermatique [@Zheng2006] alors que *C21orf59* contrôlerait à la fois la mobilité et la polarisation des cils chez *zebrafish* [@Jaffe2016]. On note aussi que ces deux gènes ont été associés à des pathologies ciliaires chez le *zebrafish*, *Chlamydomonas* ainsi que chez l'humain, pouvant entrainer un phénotype de dyskinésie ciliaire primaire, de même, la protéine FBB18 du gène orthologue de C21orf59 régulerait la motilité du flagelle chez *Chlamydomonas* [@Austin-Tse2013]. Ainsi, les arguments génétiques associés aux implications déjà avérées de ces 2 gènes dans la ciliogénèse font de *CCDC65* et *c21orf59* des excellents candidats pour expliquer les phénotype MMAF de nos `r n_run_c21orf59_ccdc65_high` patients malgré l'expression non spécifique au testicule du gène *C21orf59*.     
  
4. **_SPEF2_** :  Ce gène est retrouvé muté à l'état homozygote chez le patient `r run_spef2_high %>% paste_vector("itallic")` qui porte un indel créant un décalage du cadre de lecture. Malgré son expression non spécifique au testicule, plusieurs études ont démontré le rôle important de la protéine SPEF2 chez la souris dans la formation et la structure du flagelle spermatique de même que l'absence de cette protéine entrainait la formation d'un flagelle court et désorganisé [@Sironen2010, @Sironen2011] faisant ainsi de ce gène un excellent candidat pour le phénotype MMAF du patient `r run_spef2_high %>% paste_vector("itallic")`.

Analyser les gènes de la liste ciliome sur lesquels **un seul** patient portait un variant tronquant à l'état homozygote nous a permis d'identifier `r n_gene_grp3` nouveaux gènes : `r gene_grp3 %>% paste_vector("itallic")`. Ainsi, `r n_run_grp3_high` patients portaient un variant homozygote tronquant sur l'un d'eux tandis qu'un autre patient portait deux variant faux-sens hétérozygotes sur le gène *C6orf118*. Parmi ces `r n_gene_grp3`, seuls *CCDC65* et *C6orf118* présentaient une forte expression testiculaire, cependant tous avaient déjà été associés à la formation du cil chez l'humain ou chez une autre espèce animale. Bien que des analyses supplémentaires soient nécessaires afin de pouvoir affirmer que les deux variants hétérozygotes portés par le patients `r run_grp3_low %>% paste_vector("itallic")` sont bien responsables de son phénotype, les arguments génétiques ainsi que les informations fournies par la littérature nous ont permis d'affirmer que ces gènes sont responsables des phénotypes des patients `r run_grp3_high %>% paste_vector("itallic")`. Les données de variants de ces derniers ont ainsi été retirés réduisant à nouveau notre liste à  `r n_var_after_grp3` variants et `r n_gene_after_grp3` gènes différents.  

\newpage  

```{r plotgrp3, fig.cap=fig_info,fig.scap=fig_name, fig.height=7.2, dependson=c("dfresumegrp3","localfunction","vargrp3high"), cache=TRUE}

fig_name <- "Analyse des gènes sélectionnés dans l'Analyse n°4"
fig_description_A <- "**A** : Expression tissulaire des gènes retenus dans cette analyse d'après les données du projet de transcriptome Illumina bodyMap"
fig_description_B <- "**B** : Résumé de l'Analyse 3, quantification du nombre de patients retrouvés mutés sur chacun des gènes retenus ainsi que du degré de confiance accordé à la cause génétique"
fig_description <- paste(fig_description_A, fig_description_B, sep = ". ")
fig_info <- paste0(fig_name, " : ", fig_description)


pA <- plot_expression(gene_grp3,"percent",TRUE) +
  xlab("") +
  theme(legend.position = c(1,0),
        legend.justification = c(1,0))

pB <- plot_resume_analysis(df_resume_grp3)

plot_grid(pA,pB, labels = c("A","B"), ncol = 1)

```

\newpage

```{r tabgrp3high, dependson=c("localfunction","dfgrp3high"), cache=TRUE}

tab_high(df_grp3_high,
         caption = "Analyse n°4 : List des gènes présents dans la liste ciliome sur lesquels un seul patient portent une mutation homozygote tronquante",
         landscape = TRUE) 

```

```{r tabgrp3low, dependson=c("localfunction","dfgrp3high"), cache=TRUE}

tab_modelow(df_grp3_low,
            caption = paste0("Analyse n°4 : Liste des patients portant au moins deux variants hétérozygotes sur un des gènes suivant : ",paste_vector(gene_grp3,"itallic")),
            landscape = TRUE)

```

\newpage

##### Analyse n°5  

```{r dfgrp4high, dependson="removegrp3", cache=TRUE}

df_grp4_high <- df_bigmmaf_filter5 %>% 
  group_by(SYMBOL, Feature) %>%
  mutate(N_RUN = n_distinct(RUN)) %>% 
  filter(N_RUN == 1,
         IMPACT == "HIGH",
         EVIDENCE == "Not in the list") %>% 
  ungroup() 

```

```{r vargrp4high, cache=TRUE, dependson="dfgrp4high"}

gene_grp4 <- df_grp4_high %>% distinct(SYMBOL) %>% collect() %>% .[["SYMBOL"]] 
n_gene_grp4 <- gene_grp4 %>% length

run_grp4_high <- df_grp4_high %>% distinct(RUN) %>% collect() %>% .[["RUN"]]
n_run_grp4_high <- run_grp4_high %>% length

```

```{r dfgrp4moderate, dependson="removegrp3", cache=TRUE}

df_grp4_moderate <- df_bigmmaf_filter5 %>% 
  filter(IMPACT != "HIGH",
         SYMBOL %in% gene_grp4) %>% 
  ungroup()

```

```{r vargrp4moderate, cache=TRUE, dependson="dfgrp4moderate"}

n_run_grp4_moderate <- df_grp4_moderate %>% distinct(RUN) %>% nrow
gene_grp4_moderate <- df_grp4_moderate %>% distinct(SYMBOL) %>% collect() %>% .[["SYMBOL"]]
n_gene_grp4_moderate <- gene_grp4_moderate %>% length

```

```{r dfgrp4low, dependson="removegrp3", cache=TRUE}

df_grp4_low <- df_bigmmaf_filter_het5 %>% 
  filter(N_VAR_PER_RUN_PER_GENE > 1,
         SYMBOL %in% gene_grp4) %>% 
  ungroup()

```

```{r vargrp4low, dependson="dfgrp4low", cache=TRUE}

n_run_grp4_low <- df_grp4_low %>% distinct(RUN) %>% nrow
gene_grp4_low <- df_grp4_low %>% distinct(SYMBOL) %>% collect() %>% .[["SYMBOL"]] 

```

```{r dfresumegrp4, dependson=c("dfgrp4hig","dfgrp4moderate","dfgrp4low"), cache=TRUE}

df_resume_grp4 <- bind_rows(df_grp4_high %>% group_by(RUN, SYMBOL) %>% summarise(TRUST = "High"),
                            df_grp4_moderate %>% group_by(RUN, SYMBOL) %>% summarise(TRUST = "Moderate"),
                            df_grp4_low %>% group_by(RUN, SYMBOL) %>% summarise(TRUST = "Low")) %>% 
  group_by(TRUST, SYMBOL) %>%
  summarise(N_RUN = n_distinct(RUN)) %>% 
  select(SYMBOL, N_RUN, TRUST) %>%
  group_by(SYMBOL) %>% 
  mutate(TOT = sum(N_RUN))

```

```{r removegrp4}
# 
# run_found <- c(run_found, run_grp4_reduce)
# 
# df_bigmmaf_filter6 <- df_bigmmaf_filter5 %>% 
#   filter(!(RUN %in% run_found))
#    
# df_bigmmaf_filter_het6 <- df_bigmmaf_filter_het5 %>% 
#   filter(!(RUN %in% run_found))

```

```{r varremovegrp4}
# 
# n_var_after_grp4 <- df_bigmmaf_filter6 %>% ungroup() %>% distinct(CHR, POSITION, REF, ALT) %>% nrow()
# n_gene_after_grp4 <- df_bigmmaf_filter6 %>% ungroup() %>% distinct(SYMBOL) %>% nrow()
# n_run_after_grp4 <- df_bigmmaf_filter6 %>% ungroup() %>% distinct(RUN) %>% nrow()
# 

```

Pour finir nous avons dans cette analyse sélectionné l'ensemble des variants chevauchant des gènes **absents dans la liste cilliome** sur lesquels **un seul** de nos patients présentaient au moins 1 variant tronquant à l'état **homozygote**. Cela nous a permis d'obtenir une liste de `r n_gene_grp4` gènes différents retrouvés mutés chez `r n_run_grp4_high` de nos patients. 

En raison de la grande quantité de gène, nous nous sommes tout d'abord concentré sur ceux retrouvés mutés à l'état homozygote chez au moins deux patients. Ainsi nous avons obtenus une liste de `r n_gene_grp4_moderate` gènes : `r gene_grp4_moderate %>% paste_vector("itallic")`

1. **_CCDC66_** : Le gène *CCDC66* a été retrouvé muté à l'état homozygote chez ... patients parmi lesquels ... portait un variant tronquant entrainant un décalage du cadre de lecture et retrouvé dans aucune des bases de données. Malgré une expression testiculaire faible, l'implication récente de ce gène dans la ciliogénèse [@Conkar2017] fait de ce gène un bon candidat bien que certaines études aient déjà démontré l'implication de celui-ci dans des pathologies rétiniennes à la fois chez le chien [@Dekomien2010] mais aussi chez l'humain [@Gerding2011, @Khan2017]. En effet, ces anomalies rétiniennes.   

\newpage


```{r, fig.height=7.5}

plot_resume_analysis(df_resume_grp4) + 
  coord_flip()

```

\newpage

```{r, fig.height = 7.5}

plot_expression(gene_grp4,"percent",TRUE,"testis")

```

\newpage

```{r tabgrp4high}

tab_high(df_grp4_high,
         caption = paste0("Analyse n°5 : Liste des patients portant au moins un variant homozygote tronquant sur le gène sur l'un des ", n_gene_grp4, " genes identifés dans cette analyse"),
         evidence = FALSE,
         landscape = TRUE)

```

```{r tabgrp4moderate, dependson=c("localfunction","bigmmafgrp4"), cache=TRUE}

tab_modelow(df_grp4_moderate,
            caption = paste0("Analyse n°5 : Liste des patients portant au moins un variant homozygote non tronquant sur le gène sur l'un des ", n_gene_grp4, " genes identifés dans cette analyse"),
            landscape = TRUE)

```

\newpage

```{r resumebigmmaf}
# 
# resume_bigmmaf <- bind_rows(tablrrc43,tabarmc2) %>%
#   bind_rows(tabankrd20a3) %>% 
#   bind_rows(tabwdr52) %>% 
#   bind_rows(tabwdr96) %>% 
#   bind_rows(tabfsip2) %>% 
#   bind_rows(tabccdc146) %>% 
#   bind_rows(tabttc29) %>% 
#   bind_rows(tabefcab6) %>% 
#   bind_rows(tabarmc2) %>%
#   right_join(df_runs_mmaf, by = "RUN") %>% 
#   select(-(Project:PROJECT)) %>% 
#   group_by(RUN) %>%
#   mutate(N_CANDIDAT = n_distinct(SYMBOL),
#          CALL = if_else(is.na(SYMBOL),"None",CALL),
#          SYMBOL = if_else(is.na(SYMBOL), "No gene", SYMBOL)) %>% 
#   group_by(SYMBOL) %>%
#   mutate(N_RUN_PER_SYMBOL = n_distinct(RUN)) %>%
#   ungroup()
# 
# n_run_bigmmaf_found <- resume_bigmmaf %>% filter(SYMBOL != "No gene") %>% distinct(RUN) %>% nrow
# 
# p_run_bigmmaf_found <- (n_run_bigmmaf_found / n_run_bigmmaf) %>% round(2) * 100
# 
# n_run_several_candidat <- resume_bigmmaf %>% filter(N_CANDIDAT > 1) %>% distinct(RUN) %>% nrow
# n_run_2_candidat <- resume_bigmmaf %>% filter(N_CANDIDAT == 2) %>% distinct(RUN) %>% nrow
# n_run_3_candidat <- resume_bigmmaf %>% filter(N_CANDIDAT == 3) %>% distinct(RUN) %>% nrow
# 
# candidat_gene <- resume_bigmmaf %>% 
#   mutate(SYMBOL = if_else(SYMBOL == "WDR96","CFAP43",
#                           if_else(SYMBOL == "WDR52", "CFAP44", SYMBOL))) %>%
#   filter(!(SYMBOL %in% c("DNAH1", "No gene"))) %>% distinct(SYMBOL) %>% collect() %>% .[["SYMBOL"]] 
# 
# n_candidat_gene <- candidat_gene %>% length

```

\newpage

#### Discussion  

```{r dfdiscussion}

df_resume_candidat <- df_dnah1_high %>% 
  bind_rows(df_dnah1_moderate) %>%
  bind_rows(df_dnah1_low) %>% 
  
  bind_rows(df_grp1_high) %>% 
  bind_rows(df_grp1_moderate) %>%
  bind_rows(df_grp1_low) %>% 
  
  bind_rows(df_grp2_high_retained) %>% 
  bind_rows(df_grp2_moderate_retained) %>%
  bind_rows(df_grp2_low_retained) %>%
  
  bind_rows(df_grp3_high) %>% 
  bind_rows(df_grp3_moderate) %>%
  bind_rows(df_grp3_low) %>% 
   filter(CANONICAL == "YES" | SYMBOL %in% c("BAZ1A","C21orf59")) %>%
  mutate(HGVSc = na.replace(HGVSc, "."),
           HGVSp = na.replace(HGVSp, "."),
           `HGVSc, HGVSp` = paste0(HGVSc," ; ", HGVSp)) %>%
  
  select(RUN, `HGVSc, HGVSp`, CALL, Consequence, SYMBOL) %>% 
  
  group_by(RUN) %>%
  
  mutate(N_CANDIDAT = n_distinct(SYMBOL)) %>%
  distinct()  %>%
  ungroup() 

df_resume_2_candidat <- df_resume_candidat %>% 
  filter(N_CANDIDAT > 1) 



```



```{r vardiscussion}

run_dnah1_tot <- c(run_dnah1_high, run_dnah1_moderate, run_dnah1_low) %>% sort %>% unique
n_dnah1_tot <- run_dnah1_tot %>% length
n_dnah1_homo <- c(run_dnah1_high, run_dnah1_moderate) %>% sort %>% unique %>% length

n_gene_new_candidat <- n_gene_grp1_high + n_gene_grp2_retained + n_gene_grp3
gene_new_candidat <- c(gene_grp1_high, gene_grp2_retained, gene_grp3)

run_new_candidat <- c(run_grp1_high, run_grp1_moderate, run_grp1_low, 
                      run_grp2_high_retained, run_grp2_moderate_retained, run_grp2_low_retained, 
                      run_grp3_high, run_grp3_moderate, run_grp3_low) %>% sort %>% unique

run_new_candidat_homo <- c(run_grp1_high, run_grp1_moderate, 
                      run_grp2_high_retained, run_grp2_moderate_retained,  
                      run_grp3_high, run_grp3_moderate) %>% sort %>% unique

run_new_candidat_high <- c(run_grp1_high, run_grp2_high_retained, run_grp3_high) %>% sort %>% unique

n_run_2_candidats <- df_resume_2_candidat %>% distinct(RUN) %>% nrow

n_run_new_candidat <- run_new_candidat %>% length
n_run_new_candidat_homo <- run_new_candidat_homo %>% length
n_run_new_candidat_high <- run_new_candidat_high %>% length

p_run_new_candidat_homo <- (n_run_new_candidat_homo / n_run_bigmmaf) %>% round(3) * 100

n_run_found_tot <- c(run_new_candidat, run_dnah1_tot) %>% sort %>% unique %>% length
p_run_found_tot <- (n_run_found_tot / n_run_bigmmaf) %>% round(3) * 100


```


L'analyse de cette cohorte de `r n_run_bigmmaf` patients MMAF nous dans un premier temps permis de confirmer l'importance de l'implication du gène *DNAH1* dans ce phénotype grâce à `r n_dnah1_tot`  patients présentant des variants sur ce gène dont `r n_dnah1_homo` à l'état homozygote (dont `r n_run_dnah1_high` tronquant). Elle nous a également permis d'identifier `r n_gene_new_candidat` nouveaux gène candidats : `r gene_new_candidat %>% paste_vector("itallic")`. Ainsi, `r n_run_new_candidat_homo` de nos patients soit `r p_run_new_candidat_homo`% de la cohorte présentaient au moins 1 variant homozygote sur l'un de ces gènes, et, chez `r n_run_new_candidat_high` d'entre eux, ce variant induisaient un effet tronquant sur la séquence protéique. Les `r n_run_new_candidat - n_run_new_candidat_homo` autres portaint tous au moins deux variants hétérozygotes, tronquants ou non, sur un de ces gènes (**Figure : **\@ref(fig:plotresumebigmmaf) - **A**).

Parmi cet ensemble de patients, il faut noter que `r n_run_2_candidats` d'entre eux porte des variants sur plusieurs des gènes candidats que nous avons identifiés (**Table :** \@ref(tab:tabtwocandidats), **Figure : **\@ref(fig:plotresumebigmmaf) - **B**).

Cependant, parmi ces différents variants certains semblent plus probables pour expliquer le phénotype :  

1. **Patient _Ghs131_ :** Ce patient porte à la fois un variant homozygote sur le gène *FSIP2* et un autre sur le gène *SPEF2*. Cependant, au vu de l'effet tronquant de celui présent sur le gène *SPEF2*, il est plus probable que ce soit celui-ci qui soit responsable du phénotype de ce patient.  
2. **Patient _Ghs132_ :** Ce patient porte à la fois un variant homozygote causant un décalage du cadre de lecture sur le gène *CCDC129* et deux variants hétérozygotes sur le gène *CFAP43*. Au vu de l'incertitude lié au phasage des variants hétérozygote et de l'impact délétère de celui présent sur le gène *CCDC129*, c'est ce dernier qui sera retenu pour ce patient dans un premier temps.  
3. **Patient _Ghs40_ :** Ce patient est porteur de 3 variants faux-sens hétérozygotes sur le gène *FSIP2* et d'un variant créant un codon stop prématuré homozygote sur *C6orf118*. En tenant compte du génotype et de l'efet délétère du variant, il est plus probable que celui chevauchant le gène *C6orf118* soit responsable du phénotype.  
4. **Patient _Ghs88_ :** Comme le patient*Ghs40*, celui-ci porte à la fois deux variants hétérozygotes dur le gène *DNAH1* et un variant tronquant sur *C21orf59*. Pour les même raison que celles précédement évoquées, ces ce dernier qui sera retenu.  
5. **Patient _Ghs95_ :** Pour les même raison, c'est pour ce patient le faux-sens homozygote présant sur le gène *DNAH1* qui sera ici conservé.    

Ainsi, cette analyse révèle l'efficacité de notre pipeline puisqu'elle a permis d'identifier un gène candidat pour `r n_run_found_tot` des `r n_run_bigmmaf` patients de notre cohorte, soit `r p_run_found_tot`% de nos patients. Pour les `r n_run_bigmmaf - n_run_found_tot` patients pour lesquels aucun candidat n'a été identifié, des analyses individuelles complémentaires sont nécessaires.  

Une partie de ces différents résultats ont déjà été publiés dans deux articles dont je suis co-auteur : 

1. **Whole exome cohort study and analysis of mouse and Trypanosoma models demonstrate the importance of WDR proteins in flagellogenesis and male fertility**, *Nat Genet* (soumis) : Cette article présente nos différents résultats dans la caractérisation des gènes *WDR96* et *WDR52* ainsi que les différentes preuves de leur implication dans le phénotype MMAF.  

2. [**Whole-exome sequencing of familial cases of multiple morphological abnormalities of the sperm flagella (MMAF) reveals new DNAH1 mutations**](#famdnah1) : En plus des résultats évoqués précédemment pour la famille MMAF2, cet article inclus ceux de ... patients de cette cohorte présentant des variants sur le gène *DNAH1* 

Pour les autres, notre équipe travaille actuellement à la caractérisation des différents gènes afin de comprendre les processus moléculaires  

\newpage


```{r dfresumebigmmaf, warning=FALSE, cache=TRUE}

run_high <- c(run_dnah1_high, run_grp1_high, run_grp2_high_retained, run_grp3_high) %>% unique
run_moderate <- c(run_dnah1_moderate, run_grp1_moderate, run_grp2_moderate_retained, run_grp3_moderate) %>% unique
run_low <- c(run_dnah1_low, run_grp1_low, run_grp2_low_retained, run_grp3_low) %>% unique

run_found_all_trust <- c(run_high, run_moderate, run_low) %>% sort %>% unique
n_run_found_all_trust <- run_found_all_trust %>% length


df_resume_bigmmaf <- bind_rows(df_resume_dnah1 %>% mutate(ANALYSE = "Analysis DNAH1"),
                               df_resume_grp1 %>% mutate(ANALYSE = "Analysis n°1"),
                               df_resume_grp2_retained %>% mutate(ANALYSE = "Analysis n°2"),
                               df_resume_grp3 %>% mutate(ANALYSE = "Analysis n°3")) %>%
                               
                               
                               # df_resume_grp4 %>% mutate(ANALYSE = "Analysis n°4")) %>%
  group_by(SYMBOL) %>%
  mutate(N_TOT = sum(N_RUN),
         TRUST = factor(TRUST, levels = c("High", "Moderate", "Low"))) %>% 
  
  bind_rows(data_frame(SYMBOL = "No gene",
                N_RUN = n_run_bigmmaf - n_run_found_all_trust,
                TRUST = "None",
                TOT = n_run_bigmmaf - n_run_found_all_trust,
                ANALYSE = "None",
                N_TOT = n_run_bigmmaf - n_run_found_all_trust))




```

```{r plotresumebigmmaf, fig.cap=fig_info,fig.scap=fig_name, fig.height=7, dependson=c("dfresumebigmmaf","dfdiscussion")}

fig_name <- "Conclusion des analyses WES de notre large cohorte MMAF, liste des gènes candidats"
fig_description_A <- "**A** : Quantification du nombre de patient portant un ou plusieurs variants sur un des gène candidat. La couleur des barres dépend du type et du génotype du ou des variants portés par chaque patient. La barre bleue indique les patients pour lesquels aucun candidat n'a été identifié"
fig_description_B <- "**B** : Nombre de candidat potentiel par patient (parmi ceux pour lesquels au moins un gène candidat a été identifié)"
fig_description <- paste(fig_description_A, fig_description_B, sep = ". ")
fig_info <- paste0(fig_name, " : ", fig_description)

break_max <- df_resume_bigmmaf$N_TOT %>% max

pA <- ggplot(df_resume_bigmmaf, aes(reorder(SYMBOL, N_TOT), N_RUN)) + 
  geom_col(aes(fill = TRUST)) + 
  scale_y_continuous(breaks = c(0:break_max)) +
  scale_fill_manual(name = "Trust", values = c("#4DAF4A","#FF7F00","#E41A1C","#377EB8")) + 
  ylab("Nb of individuals") + 
  xlab("") +
  # theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  coord_flip() + 
  theme(legend.position = c(1, 0),
        legend.justification = c(1,0))

pB <- ggplot(df_resume_candidat %>% select(RUN, N_CANDIDAT) %>% distinct(), aes(N_CANDIDAT)) + 
  geom_bar(fill = "#377EB8") +
  ylab("Nb of individual") +
  xlab("Nb of potential candidat gene") + 
  geom_text(stat='count',aes(label= ..count..), size = 5, vjust = 1) 

plot_grid(pA, pB, labels = c("A","B"), rel_heights = c(.55,.45), ncol = 1)

```


\newpage

```{r tabtwocandidats}

df_resume_2_candidat %>%
  select(Patient = RUN, Gene = SYMBOL, `HGVSc, HGVSp`, Consequence, Genotype = CALL) %>% 
  arrange(Patient, Gene) %>% 
  kable(booktabs = TRUE,
        longtable = TRUE,
        caption = "Liste des patients portant au moins 1 variant sur deux gènes candidats")

```


```{r plotresumebigmmaf2, fig.cap=fig_info,fig.scap=fig_name, fig.height=7, cache=TRUE}
# 
# fig_name <- "Conclusion des analyses WES de notre large cohorte MMAF, liste des gènes candidats"
# 
# fig_description_A <- "**A** : Quantification du nombre de patient portant un ou plusieurs variants sur un des gène candidat. La couleur des barres dépend du génotype des patients, la barre rouge indique les patients pour lesquels aucun candidat n'a été identifié"
# 
# 
# fig_info <- paste0(fig_name, " : ", fig_description)
# 
# # color from Set1 palette : 
# # #4DAF4A = Green
# # #FF7F00 = Orange
# # #E41A1C = Red
# # #377EB8 = Blue
# 
# pA <- ggplot(resume_bigmmaf %>% 
#                distinct(SYMBOL, CALL, RUN, N_RUN_PER_SYMBOL) %>% 
#                group_by(SYMBOL, CALL) %>%
#                summarise(N = n_distinct(RUN),
#                          N_RUN_PER_SYMBOL = mean(N_RUN_PER_SYMBOL)) , aes(reorder(SYMBOL, N_RUN_PER_SYMBOL), N)) + 
#   geom_col(aes(fill = CALL)) + 
#   scale_fill_manual(breaks = c("Homozygous", "Heterozygous", "None"), name = "Genotype", values = c("#FF7F00", "#4DAF4A", "#E41A1C")) + 
#   ylab("Nb of individual") + 
#   xlab("") +
#   coord_flip() +
#   theme(legend.position = "bottom")
# 
# pB <- ggplot(resume_bigmmaf %>% 
#                filter(!is.na(CALL)) %>%
#                group_by(N_CANDIDAT) %>% distinct(RUN) , aes(N_CANDIDAT)) + 


# 

```

\newpage

```{r tabresumebigmmaf, cache=TRUE}

# resume_bigmmaf %>% 
#                filter(!is.na(CALL)) %>% 
#   filter(N_CANDIDAT > 1) %>% 
#   select(RUN:SYMBOL) %>% 
#   arrange(RUN, SYMBOL, desc(CALL)) %>%
#   kable(booktabs = TRUE,
#         longtable = TRUE,
#         col.names = c("Run ID","Variant coordinates", "Genotype", "Consequence", "Gene symbol"),
#         caption = "Liste des patients pour lesquels plusieurs gènes candidats ont été identifiés")


```

\newpage 

## Conclusion  

Au cours de ces différentes études nous avons pu identifier les variants pouvant expliquer les phénotypes de ... des différents patients que nous avons analysé que ce soit au sein d'études familiales ou bien au sein de plus large cohorte composés d'individus non apparentés. Bien que ces résultats soient satisfaisant, il faut noter que pour ... patients, soit ... % d'entre eux aucun candidat n'a pu à ce jour être identifié. Pour ces patients, le WES permets désormais de nouvelles approches permettant d'identifier de larges variants structuraux (insertion ou délétions) pouvant eux aussi être responsable du phénotype qui ne sont pas détectés par les analyses classiques. Néanmoins, il semble clair que des avancés soient encore nécessaires afin d'améliorer l'efficacité de ce genre d'étude notamment en créant de nouveaux filtres permettant ainsi d'épurer les listes de variants facilitant ainsi l'identification des gènes candidats.  




