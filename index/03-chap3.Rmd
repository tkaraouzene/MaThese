---
output:
  word_document: default
  pdf_document: default
  html_document: default
---
# Mise en place d’une stratégie pour l’analyse des données exomiques – application en recherche clinique  

```{r include.packages2, include=FALSE}
# This chunk ensures that the thesisdown package is
# installed and loaded. This thesisdown package includes
# the template files for the thesis.

if(!require(devtools))
  install.packages("devtools", repos = "http://cran.rstudio.com")
if(!require(thesisdown))
  devtools::install_github("ismayc/thesisdown")

library(thesisdown)
library(knitr)
library(tidyr)
library(dplyr)
library(data.table)
library(ggplot2)
library(stringi)
library(scales)
library(cowplot)
theme_set(theme_gray()) # otherwise use cowplot default theme

source("script/manage_variants.R")
source("script/variant_filtering.R")
source("script/resume_data.R")
source("script/plot_vep_results.R")

opts_knit$set(eval.after = c("fig.cap","fig.scap"))

knitr::opts_chunk$set(fig.align='center',echo=FALSE)

knitr::opts_knit$set(kable.force.latex = TRUE)

```

## Intro  

Comme vu précédemment, l'émergence du séquençage haut débit, avec notamment le WGS et le WES, a révolutionné les méthodes de recherche dans le cadre d'étude phénotype-génotype en permettant de manière rapide et à moindre coup le séquençage de la quasi totalité des gènes humains. Les causes de plusieurs centaines de pathologies ont pu être identifiées grâce à ces technique depuis leur premier succès pubilié en 2010 [@Ng].  Dès lors, l'analyse des données issues du séquençage est devenu la clef dans la réussite de ces études. 

Il existe de nombreux logiciels qui à partir des variants appelés effectuent les étapes d'annotation et de filtrage. C'est par exemple le cas d'Exomiser [TODO: insert ref and Exomiser describtion] ou encore de [TODO: insert at least one other soft]. La plupart de ces logiciels fonctionnent très bien, cependant tous prennent pour point de départ des variants appelés en amont. Ils ne contrôlent donc en aucune manière les étapes d'alignement et d'appel des variants. Or, comme il a été dit plus tôt, ces deux étapes constituent la bases de l'analyse [TODO insert ref] et les résultats

<!-- Ce chapitre décrit la constitution et l’utilisation d’un pipeline d’analyse des données de séquençage exomique et son utilisation dans le cadre de la recherche de mutations entrainant différents phénotypes d’infertilité. La difficulté des études génétiques visant à identifier des gènes pathogènes vient de l’abondance de variants rares chez tout un chacun et de la difficulté d’effectuer des tris efficaces et justes pour ne retenir que la ou les mutations causales. Thomas développe un pipeline se basant sur des outils existant mais permettant d’effectuer des tris successifs efficaces et pertinents   -->


Dans ce chapitre, je détaillerai les résultats de 4 articles dont je suis coauteur :  

1. [**Whole-exome sequencing of familial cases of multiple morphological abnormalities of the sperm flagella (MMAF) reveals new DNAH1 mutations**](#famdnah1) : [todo]
2. [**Homozygous mutation of PLCZ1 leads to defective human oocyte activation and infertility that is not rescued by the WW-binding protein PAWP**](#plcz) : Dans cet article j'ai, comme précédemment, effectué l'integralité des analyses bioinformatiques des données d'exomes effectués sur deux frères infertiles présentant des échecs de fécondation.  
3. [**SPINK2 deficiency causes infertility by inducing sperm defects in heterozygotes and azoospermia in homozygotes**](#spink2) : Dans cet article j'ai effectuer non seulement l'intégralité des analyses bioinformatiques des données d'exomes de deux frères infertiles présentant un phénotype d'azoospermie mais aussi séquencer en Sanger les séquences codantes du gène *SPINK2* pour une parie des 611 individus analyser ainsi que contribué à l'extraction de l'ARN testiculaire des souris pour l'analyse fonctionelle du gène *Spink2* sur le modèle murin.  
4. [****](#cohortemmah) : [todo]

## Résultats  

```{r all_coding_variants, cache=TRUE}

df_all_coding_variants <- fread("data/all_coding_variants_vep81.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE)
maf_cutoff <- 0.01

rm_var_count <- function(df, coding, ctrl, maf_cutoff) {
  
  tot_var <- df %>% 
    select(-(CALL:STRAND)) %>%
    group_by(FAM, RUN) %>% 
    mutate(Ntot = n_distinct(CHR, POSITION, REF, ALT))
  
  rm_ctrl <- tot_var %>% 
    variant_join(ctrl, mode = "anti") %>%
    group_by(FAM, RUN) %>% 
    summarise(N_REMOVE = n_distinct(CHR, POSITION, REF, ALT),
              N_TOT = mean(Ntot),
              FILTER = "CTRL") 
  
  rm_nmd <- ungroup(tot_var) %>%
    variant_join(coding, mode = "inner") %>%
    mutate(IS_NMD = grepl("NMD_transcript_variant",Consequence)) %>%
    distinct(RUN, FAM, IS_NMD, CHR, POSITION, REF, ALT, Ntot, Feature) %>% 
    group_by(CHR, POSITION, REF, ALT, RUN) %>%
    mutate(N = n()) %>%
    filter(N == 1,
           IS_NMD == TRUE) %>%
    group_by(RUN, FAM) %>% 
    summarise(N_REMOVE = n_distinct(CHR, POSITION, REF, ALT),
              N_TOT = mean(Ntot),
              FILTER = "NMD")
  
  rm_freq <- tot_var %>%
    variant_join(coding, mode = "inner") %>%
    filter_frequence(cutoff = maf_cutoff) %>%
    group_by(FAM, RUN) %>% 
    summarise(N_REMOVE = n_distinct(CHR, POSITION, REF, ALT),
              N_TOT = mean(Ntot),
              FILTER = "FREQ")
  
  rm_impact <- tot_var %>%
    variant_join(coding, mode = "inner") %>%
    group_by(FAM, RUN) %>%
    filter(Consequence != "synonymous_variant",     # Filter variant considering their impact on transcript
           Consequence != "5_prime_UTR_variant",
           Consequence != "3_prime_UTR_variant",
           !(grepl("tolerated", SIFT) & grepl("benign", PolyPhen))) %>%
    group_by(FAM, RUN) %>% 
    summarise(N_REMOVE = n_distinct(CHR, POSITION, REF, ALT),
              N_TOT = mean(Ntot),
              FILTER = "IMPACT")
  
  rm_genotype <- tot_var %>% 
    filter_genotype(homo = FALSE) %>% # filter homo var to know how many het are filtered
    group_by(FAM, RUN) %>% 
    summarise(N_REMOVE = n_distinct(CHR, POSITION, REF, ALT),
              N_TOT = mean(Ntot),
              FILTER = "GENOTYPE") 
    
  rbind(rm_genotype, rm_ctrl, rm_nmd, rm_impact, rm_freq)
  
}


```

```{r allruns}


df_runs <- fread("data/exome_runs.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE)

resume_pheno <- df_runs %>% 
  ungroup() %>%
  rename(Phenotype = Pathologie) %>%
  filter(Phenotype != "TVPC") %>%
  group_by(Phenotype) %>% 
  summarise(N_per_Patho = n()) %>% 
  spread(Phenotype, N_per_Patho) %>% 
  rename(Azoospermia = Azoo, 
         MMAF = Flag, 
         `Fertilization failure` = Fert_fail, 
         Globozoospermia = Globo, 
         Macrozoospermia = Macro,
         `Oocyte defect` = Ovo,
         Healthy = CTRL) %>% 
  gather(Phenotype,`Nb of individuals`, Azoospermia:`Oocyte defect`)


resume_tot <- resume_pheno %>% 
  ungroup() %>% 
  summarise(N_tot = sum(`Nb of individuals`),
            N_pheno = n_distinct(Phenotype) - 1)

n_tot_runs <- resume_tot %>% collect() %>% .[["N_tot"]]
n_pheno <- resume_tot %>% collect() %>% .[["N_pheno"]]

```


### Description de la pipeline  

Notre pipeline d'analyse effectue l'ensemble des étapes allant de l'alignement des données jusqu'au filtrage des variants  

1. **L'alignement** : L'alignement des *reads* le long du génome de référence est effectué par le logiciel MAGIC [@Su2014]. Celui-ci l'intégralité pour l'ensemble des analyses en aval l'ensemble des *reads* dupliqués et / ou s'alignant à plusieurs zone du génome. Au cours de cette étape, MAGIC va produire également quatre comptages pour chaque position couverte du génome : R+, V+, R- et V- :  
    a. **R+ et R-** : Ces deux comptages correspondent au nombres de *reads* *forward* (+) et *reverse* (-) sur lesquels est observé l'allere de **référence** (R) à une position donnée.  
    b. **V+ et V-** : À l'inverse de R+ et R-, ces comptages correspondent au nombres de *reads* *forward* et *reverse* sur lesquels est observé un allele de **variant** (V) à une position donnée.  
2. **L'appel des variants** : Comme nous l'avons vu plus [tôt](#varcall), il est fortement conseillé d'effectuer l'appel des variants en tenant compte de l'aligneur choisi [@Nielsen2011, @DePristo2011, @Lunter2011]. C'est pourquoi, nous avons conçu notre propre algorithme d'appel des variants spécialement conçu pour l'analyse des données de MAGIC. Ainsi, l'appel des variants sera directement basé sur les quatre comptages vu précédement. Tout d'abord, les positions ayant une couverture < 10 sur l'un des deux *strands* sera considérée comme de faible qualité, celles aynant une couverture < 10 sur les deux *strands* seront exclus. Ensuite pour chaque variant, des appels indépendant seront effectués pour chaque *strand*. L'appel final sera une synthèse de ces deux appels où seul les cas où ces deux appels sont concordants seront considérés comme de bone qualité.    
3. **L'annotation** : Chaque variant retenu sera ensuite annoté tout d'abord par le logiciel *variant effect predictor* (VEP) [@McLaren2016] qui nous indiquera pour chaque variant l'impact que celui-ci aura sur la séquence codante de l'ensemble des transcrits qu'il chevauche. Suite à cela nous ajoutons, lorsque celle-ci est disponible, la fréquence du variant dans les bases de données ExAC [@Lek2016], ESP600 [TODO] et 1000Genomes [TODO] donnant ainsi une estimation de sa fréquence dans la population générale. De même, la particularité de cette pipeline est qu'elle conserve l'ensemble des variants identifiés dans les études effectués précédement permettant d'ajouter aux annotations la fréquences d'un variant chez les individus déjà séquencé et donc la fréquence d'un variant dans chaque phénotype étudié créant ainsi une base de données interne qui pourra servir de contrôle dans les études ulterieur. 
4. **Le filtrage des variants** : L'étape de filtrage est extremement importante si l'on souhaite analyser de manière efficace les données provenant de WES. C'est pourquoi elle occupe une place importante dans notre pipeline. L'intégralité des paramètres de cette étape peuvent être modifier par l'utilisateur de sorte à faire correspondre les critères de filtre aux bsoins de l'étude. Afin de rendre son utilisation le plus efficace possibe, nous avons souhaité définir des paramètres par défauts pertinent dans la plupart des étude de séquençage exomique de sorte que à moins que le contraire ne soit spécifié, seul les variants impactant les transcrits codant pour une protéine sont conservés. De même les variants synonymes ou affectant les séquences UTRs sont filtrés ainsi que les variants ayant une fréquence $\ge$ 1% dans les bases dans l'une des bases données (ExAC, ESP6500 ou 1KH). Aussi, pour un phénotype donné, l'ensemble des variants observés chez les individus étudiés présentant un phénotype différent sont de même enlevés de la liste finale.   

### Utilisation de la pipeline dans des cas familiaux :  

#### Description des familles 

```{r}

df_seq <- data_frame(FAM = c("Az","FF","MMAF1","MMAF2","MMAF3","MMAF4"),
                     NB = c(2,2,2,2,2,3),
                     PHENOTYPE = c("Azoospermia","Fertilization failure","MMAF","MMAF","MMAF","MMAF"),
                     YEAR = c(2012,2014,2014,2014,2014,2014),
                     PLATFORM = c("Illumina HiSeq2000","Illumina HiSeq2000","Illumina HiSeq2000","Illumina HiSeq2000","Illumina HiSeq2000","Illumina HiSeq2000"),
                     PLACE = c("Mount Sinai Institut","Genoscope (Evry)","Genoscope (Evry)","Genoscope (Evry)","Genoscope (Evry)","Genoscope (Evry)"))


nb_fam <- df_seq %>% summarise(N_FAM = n_distinct(FAM)) %>% collect() %>% .[["N_FAM"]] 
nb_pheno <- df_seq %>% summarise(N_PHENO = n_distinct(PHENOTYPE)) %>% collect() %>% .[["N_PHENO"]] 

```

Dans cette partie, je me concentre sur l'analyse bioinformatique des résultats des séquençages exomiques effectués entre `r min(df_seq$YEAR)` et `r max(df_seq$YEAR)` de `r sum(df_seq$NB)` individus infertiles provenant de `r nb_fam` familles différentes. Parmi celles-ci, `r nb_pheno` phénotypes différents ont été observés : 

1. **[L'Azoospermie](#infquant) :** Comme nous avons pu le voir, l'azoospermie est un phénotype d'infertilité masculine caractérisé par l'absence de spermatozoïde dans l'éjaculat.    
2. **Echec de fécondation :**  Ce phénotype d'infertilité se caractérise par l'incapacité des spermatozoïdes à féconder l'ovocyte.  
3. **MMAF** :  Le syndrome MMAF (*multiple morphological abnormalities of the sperm flagella*) caractérise comme son nom l'indique les patients présentant une majorité de spermatozoïdes atteins par une mosaïque d'anomalie morphologique du flagelle.  

Un récapitulatif des familles et de leur phénotype est disponible dans la table \@ref(tab:recapfam).    

```{r recapfam}

tab.name <- "Tableau recapitulatif des familles séquencées et de leur phénotype"

kable(df_seq, 
      col.names = c("Familly","Individuals","Phenotype","Year","Plateform","Place"),
      caption = tab.name, 
      longtable = TRUE, 
      booktabs = TRUE)

```

#### Resultats des exomes  

```{r taballruns}

# 
# tab.name <- "Liste des phénotypes étudiés dans notre équipe ainsi que la taille des effectifs séquencés en WES"
# 
# kable(resume_pheno, 
#       caption = tab.name, 
#       booktabs = TRUE)

```

```{r datafamaz, dependson="all_coding_variants",  cache=TRUE}

maf_cutoff <- 0.01

df_fam_az <- fread("data/genotype_spink2.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE) %>%
  gather(RUN, CALL, starts_with("Ghs")) %>%
  filter(CALL %in% c(2, 3, "b", "c")) %>%
  mutate(TYPE = if_else(stri_length(REF) == stri_length(ALT), "SNV", "Indel"), 
         STRAND = if_else(CALL %in% c(2, 3), "Both_strand", "Single_strand"),
         GENOTYPE = if_else(CALL %in% c(2, "b"), "Heterozygous", "Homozygous"),
         RUN = if_else(RUN == "Ghs44", "Az1", "Az2"),
         FAM = "AZ")

df_ctrl_az <- fread("data/genotype_not_azoo.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE) %>%
  gather(RUN, CALL, starts_with("Ghs")) %>%
  filter(CALL %in% c(3, "c")) %>%
  select(-CALL) 

rm_var_az <- rm_var_count(df_fam_az, df_all_coding_variants, df_ctrl_az, maf_cutoff)

nb_ctrl_az <- df_ctrl_az %>% resume_run(type ="nb")

```

```{r filterfamaz, cache=TRUE, include=FALSE}


df_az1 <- filter(df_fam_az, RUN == "Az1")
df_az2 <- filter(df_fam_az, RUN == "Az2")

df_filter_az <- variant_join(df_az1, df_az2, mode = "inner") %>% # keep 
  filter_genotype(het = FALSE) %>% 
  variant_join(df_ctrl_az, mode = "anti") %>%
  variant_join(df_all_coding_variants, mode = "inner") %>%
  filter(Consequence != "synonymous_variant",     # Filter variant considering their impact on transcript
         Consequence != "5_prime_UTR_variant",
         Consequence != "3_prime_UTR_variant",
         !grepl("NMD_transcript_variant",Consequence),
         !(grepl("tolerated",SIFT) & grepl("benign",PolyPhen))) %>%
  filter_frequence(cutoff = maf_cutoff) %>%
  select(-CADD_RAW)

df_passing_genes_az <- resume_gene(df_filter_az)

rm(df_ctrl_az, df_az1, df_az2)
gc()

```

```{r datafamff, dependson="all_coding_variants", cache=TRUE}

maf_cutoff <- 0.01

df_fam_ff <- fread("data/genotype_plcz.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE) %>%
  gather(RUN, CALL, starts_with("Ghs")) %>%
  filter(CALL %in% c(2, 3, "b", "c")) %>%
  mutate(TYPE = if_else(stri_length(REF) == stri_length(ALT), "SNV", "Indel"), 
         STRAND = if_else(CALL %in% c(2, 3), "Both_strand", "Single_strand"),
         GENOTYPE = if_else(CALL %in% c(2, "b"), "Heterozygous", "Homozygous"),
         RUN = if_else(RUN == "Ghs113", "FF1", "FF2"),
         FAM = "FF")

df_ctrl_ff <- fread("data/genotype_not_fert_fail.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE) %>%
  gather(RUN, CALL, starts_with("Ghs")) %>%
  filter(CALL %in% c(3, "c")) %>%
  select(-CALL)

rm_var_ff <- rm_var_count(df_fam_ff, df_all_coding_variants, df_ctrl_ff, maf_cutoff)

nb_ctrl_ff <- df_ctrl_ff %>% resume_run(type = "nb")

```

```{r filterfamff, cache=TRUE, include=FALSE}


df_ff1 <- filter(df_fam_ff, RUN == "FF1")
df_ff2 <- filter(df_fam_ff, RUN == "FF2")

df_filter_ff <- variant_join(df_ff1, df_ff2, mode = "inner") %>% # keep 
  filter_genotype(het = FALSE) %>%
  variant_join(df_ctrl_ff, mode = "anti") %>%
  variant_join(df_all_coding_variants, mode = "inner") %>%
  filter(Consequence != "synonymous_variant",     # Filter variant considering their impact on transcript
         Consequence != "5_prime_UTR_variant",
         Consequence != "3_prime_UTR_variant",
         !grepl("NMD_transcript_variant",Consequence),
         !(grepl("tolerated", SIFT) & grepl("benign", PolyPhen))) %>%
  filter_frequence(cutoff = maf_cutoff) %>%
  select(-CADD_RAW)

df_passing_genes_ff <- resume_gene(df_filter_ff)

rm(df_ctrl_ff, df_ff1, df_ff2)
gc()

```

```{r datammaf1, dependson="all_coding_variants", cache=TRUE, include=FALSE}

df_fam_mmaf1 <- fread("data/genotype_MMAF_fam1.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE) %>%
  gather(RUN, CALL, starts_with("Ghs")) %>%
  filter(CALL %in% c(2, 3, "b", "c")) %>%
  mutate(TYPE = if_else(stri_length(REF) == stri_length(ALT), "SNV", "Indel"), 
         STRAND = if_else(CALL %in% c(2, 3), "Both_strand", "Single_strand"),
         GENOTYPE = if_else(CALL %in% c(2, "b"), "Heterozygous", "Homozygous"),
         RUN = if_else(RUN == "Ghs56", "MMAF1_1", "MMAF1_2"),
         FAM = "MMAF1")

df_ctrl_mmaf <- fread("data/genotype_not_MMAF.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE) %>%
  gather(RUN, CALL, starts_with("Ghs")) %>%
  filter(CALL %in% c(3, "c")) %>%
  select(-CALL)

rm_var_mmaf1 <- rm_var_count(df_fam_mmaf1, df_all_coding_variants, df_ctrl_mmaf, maf_cutoff)

nb_ctrl_mmaf <- resume_run(df_ctrl_mmaf, type = "nb")

```

```{r filterfammmaf1, cache=TRUE, include=FALSE}

maf_cutoff <- 0.01

df_mmaf1_1 <- filter(df_fam_mmaf1, RUN == "MMAF1_1")
df_mmaf1_2 <- filter(df_fam_mmaf1, RUN == "MMAF1_2")

df_filter_mmaf1 <- variant_join(df_mmaf1_1, df_mmaf1_2, mode = "inner") %>% # keep 
  filter_genotype(het = FALSE) %>%
  

  variant_join(df_ctrl_mmaf, mode = "anti") %>%
  variant_join(df_all_coding_variants, mode = "inner") %>%
  filter(Consequence != "synonymous_variant",     # Filter variant considering their impact on transcript
         Consequence != "5_prime_UTR_variant",
         Consequence != "3_prime_UTR_variant",
         !grepl("NMD_transcript_variant",Consequence),
         !(grepl("tolerated", SIFT) & grepl("benign", PolyPhen))) %>%
  filter_frequence(cutoff = maf_cutoff) %>%
  select(-CADD_RAW)

df_passing_genes_mmaf1 <- resume_gene(df_filter_mmaf1)

```

```{r datammaf2, dependson="all_coding_variants", cache=TRUE, include=FALSE}

df_fam_mmaf2 <- fread("data/genotype_MMAF_fam2.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE) %>%
  gather(RUN, CALL, starts_with("Ghs")) %>%
  filter(CALL %in% c(2, 3, "b", "c")) %>%
  mutate(TYPE = if_else(stri_length(REF) == stri_length(ALT), "SNV", "Indel"), 
         STRAND = if_else(CALL %in% c(2, 3), "Both_strand", "Single_strand"),
         GENOTYPE = if_else(CALL %in% c(2, "b"), "Heterozygous", "Homozygous"),
         RUN = if_else(RUN == "Ghs62", "MMAF2_1", "MMAF2_2"),
         FAM = "MMAF2")

rm_var_mmaf2 <- rm_var_count(df_fam_mmaf2, df_all_coding_variants, df_ctrl_mmaf, maf_cutoff)

```

```{r filterfammmaf2, cache=TRUE, include=FALSE}


df_mmaf2_1 <- filter(df_fam_mmaf2, RUN == "MMAF2_1")
df_mmaf2_2 <- filter(df_fam_mmaf2, RUN == "MMAF2_2")

df_filter_mmaf2 <- variant_join(df_mmaf2_1, df_mmaf2_2, mode = "inner") %>% # keep 
  filter_genotype(het = FALSE) %>%
  variant_join(df_ctrl_mmaf, mode = "anti") %>%
  variant_join(df_all_coding_variants, mode = "inner") %>%
  filter(Consequence != "synonymous_variant",     # Filter variant considering their impact on transcript
         Consequence != "5_prime_UTR_variant",
         Consequence != "3_prime_UTR_variant",
         !grepl("NMD_transcript_variant",Consequence),
         !(grepl("tolerated", SIFT) & grepl("benign", PolyPhen))) %>%
  filter_frequence(cutoff = maf_cutoff) %>%
  select(-CADD_RAW)

df_passing_genes_mmaf2 <- resume_gene(df_filter_mmaf2)


```

```{r datammaf3, dependson="all_coding_variants", cache=TRUE, include=FALSE}

df_fam_mmaf3 <- fread("data/genotype_MMAF_fam3.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE) %>%
  gather(RUN, CALL, starts_with("Ghs")) %>%
  filter(CALL %in% c(2, 3, "b", "c")) %>%
  mutate(TYPE = if_else(stri_length(REF) == stri_length(ALT), "SNV", "Indel"), 
         STRAND = if_else(CALL %in% c(2, 3), "Both_strand", "Single_strand"),
         GENOTYPE = if_else(CALL %in% c(2, "b"), "Heterozygous", "Homozygous"),
         RUN = if_else(RUN == "Ghs63", "MMAF3_1", "MMAF3_2"),
         FAM = "MMAF3")

rm_var_mmaf3 <- rm_var_count(df_fam_mmaf3, df_all_coding_variants, df_ctrl_mmaf, maf_cutoff)

```

```{r filterfammmaf3, cache=TRUE, include=FALSE}

maf_cutoff <- 0.01

df_mmaf3_1 <- filter(df_fam_mmaf3, RUN == "MMAF3_1")
df_mmaf3_2 <- filter(df_fam_mmaf3, RUN == "MMAF3_2")

df_filter_mmaf3 <- variant_join(df_mmaf3_1, df_mmaf3_2, mode = "inner") %>% # keep 
  filter_genotype(het = FALSE) %>%
  variant_join(df_ctrl_mmaf, mode = "anti") %>%
  variant_join(df_all_coding_variants, mode = "inner") %>%
  filter(Consequence != "synonymous_variant",     # Filter variant considering their impact on transcript
         Consequence != "5_prime_UTR_variant",
         Consequence != "3_prime_UTR_variant",
         !grepl("NMD_transcript_variant",Consequence),
         !(grepl("tolerated", SIFT) & grepl("benign", PolyPhen))) %>%
  filter_frequence(cutoff = maf_cutoff) %>%
  select(-CADD_RAW)

df_passing_genes_mmaf3 <- resume_gene(df_filter_mmaf3)


```

```{r datammaf4, dependson="all_coding_variants", cache=TRUE, include=FALSE}

df_fam_mmaf4 <- fread("data/genotype_MMAF_fam4.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE) %>%
  gather(RUN, CALL, starts_with("Ghs")) %>%
  filter(CALL %in% c(2, 3, "b", "c")) %>%
  mutate(TYPE = if_else(stri_length(REF) == stri_length(ALT), "SNV", "Indel"), 
         STRAND = if_else(CALL %in% c(2, 3), "Both_strand", "Single_strand"),
         GENOTYPE = if_else(CALL %in% c(2, "b"), "Heterozygous", "Homozygous"),
         RUN = if_else(RUN == "Ghs59", "MMAF4_1", 
                       if_else(RUN == "Ghs60", "MMAF4_2", "MMAF4_3")),
         FAM = "MMAF4")

rm_var_mmaf4 <- rm_var_count(df_fam_mmaf4, df_all_coding_variants, df_ctrl_mmaf, maf_cutoff)

```

```{r filterfammmaf4, cache=TRUE, include=FALSE}

maf_cutoff <- 0.01

df_mmaf4_1 <- filter(df_fam_mmaf4, RUN == "MMAF4_1")
df_mmaf4_2 <- filter(df_fam_mmaf4, RUN == "MMAF4_2")
df_mmaf4_3 <- filter(df_fam_mmaf4, RUN == "MMAF4_3")

df_filter_mmaf4 <- variant_join(df_mmaf4_1, df_mmaf4_2, mode = "inner") %>% 
  filter_genotype(het = FALSE) %>%
  variant_join(df_ctrl_mmaf, mode = "anti") %>%
  variant_join(df_all_coding_variants, mode = "inner") %>%
  filter(Consequence != "synonymous_variant",     # Filter variant considering their impact on transcript
         Consequence != "5_prime_UTR_variant",
         Consequence != "3_prime_UTR_variant",
         !grepl("NMD_transcript_variant",Consequence),
         !(grepl("tolerated", SIFT) & grepl("benign", PolyPhen))) %>%
  filter_frequence(cutoff = maf_cutoff) %>%
  select(-CADD_RAW)

df_passing_genes_mmaf4 <- resume_gene(df_filter_mmaf4)

rm(df_mmaf4_1, df_mmaf4_2, df_mmaf4_3)
gc()


```

```{r}

rm_var_all <- rbind(rm_var_az, 
                    rm_var_ff, 
                    rm_var_mmaf1, 
                    rm_var_mmaf2, 
                    rm_var_mmaf3, 
                    rm_var_mmaf4) %>%
  group_by(RUN, FILTER) %>%
  mutate(PERCENT = N_REMOVE / N_TOT) 

resume_geno <- rm_var_all %>% 
  ungroup() %>% 
  filter(FILTER == "GENOTYPE") %>% 
  summarise(N_MAX_GENO = max(N_REMOVE),
            N_MIN_GENO = min(N_REMOVE))

min_var_geno <- resume_geno %>% collect() %>% .[["N_MIN_GENO"]] 
max_var_geno <- resume_geno %>% collect() %>% .[["N_MAX_GENO"]] 

```

```{r nmdtr, cache=TRUE}

df_nmd <- rbind(df_fam_az, df_fam_ff, df_fam_mmaf1, df_fam_mmaf2, df_fam_mmaf3, df_fam_mmaf4) %>% 
  variant_join(df_all_coding_variants, mode = "inner") %>%
  ungroup() %>%
  select(CHR, POSITION, REF, ALT, RUN, FAM, Feature, Consequence) %>%
  mutate(Is_NMD = grepl("NMD_transcript_variant", Consequence)) %>% 
  select(-Consequence) %>%
  distinct(RUN, FAM, Is_NMD, CHR, POSITION, REF, ALT, Feature) %>% 
  group_by(CHR, POSITION, REF, ALT, RUN) %>%
  mutate(N = n()) %>%
  filter(N == 1,
         Is_NMD == TRUE) %>%
  group_by(RUN, FAM) %>% 
  summarise(NB_TR = n_distinct(Feature),
            NB_VAR = n_distinct(CHR, POSITION, REF, ALT))

df_nmd_min_max <- ungroup(df_nmd) %>%
  summarise(MIN_TR = min(NB_TR),
         MAX_TR = max(NB_TR),
         MIN_VAR = min(NB_VAR),
         MAX_VAR = max(NB_VAR))


min_tr_nmd <- df_nmd_min_max %>% collect() %>% .[["MIN_TR"]] 
max_tr_nmd <- df_nmd_min_max %>% collect() %>% .[["MAX_TR"]]

min_var_nmd <- df_nmd_min_max %>% collect() %>% .[["MIN_VAR"]]
max_var_nmd <- df_nmd_min_max %>% collect() %>% .[["MAX_VAR"]]

```

Pour l'ensemble des individus de ces quatre familles nous avons appliqué notre pipeline d'analyse de sorte à obtenir pour chaque patient une liste de SNV et d'indel avec leur génotype associé (**Figure : **\@ref(fig:resvarcall)).  

```{r resvarcall, fig.cap=fig.info,fig.scap=fig.name,fig.width=7, cache=TRUE} 

fig.name <- "Comptage des SNVs et indels retrouvés par patients avec leur génotypes associés"
fig.description <- ""
fig.info <- paste(fig.name)

ggplot(rbind(df_fam_az,df_fam_ff,df_fam_mmaf1,df_fam_mmaf2,df_fam_mmaf3,df_fam_mmaf4), aes(RUN, fill = GENOTYPE)) +
  geom_bar(position = position_dodge()) +
  scale_fill_discrete(name = "Genotype") +
  facet_grid(TYPE ~ FAM, scales = "free") + 
  xlab("Patient") +
  ylab("Count") + 
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

```

Ensuite, afin de ne conserver que les variants ayant la plus forte probabilité d'être responsable du phénotype nous avons appliqué succesivement six filtres :  

1. **L'union des variants :** Dans ces différentes études, nos patients ont à chaque fois au moins un frère présentant le même phénotype. Ainsi nous avons pu formuler l'hypothèse d'une cause génétique commune entre les différents frères d'une même famille et donc filtrer l'ensemble des variants qui ne sont pas partagés par l'ensemble des membre de la fraterie.     
2. **Genotype des variants :**  Dans ces études, nous avons emmis l'hypothèse d'une transmission recessive du phénotype. Ainsi, seul les variants homozygotes ont été conservés. Ce filtre est le plus efficace du pipeline en permettant de filtrer entre `r min_var_geno` et `r max_var_geno` variants par individus (**Figure : **\@ref(fig:resvarcall), \@ref(fig:comparefilter)).    
3. **Impact du variant :** Afin de ne conserver que les variants ayant un effet potentiellement tronquant sur la protéine, nous avons filtré les variants intonique et ceux tombant dans les sequences UTRs. De même les variants synonymes ne sont pas conservés car ceux-ci n'ont aucun effet sur séquences protéique. Pour les variants faux sens (changement d'un seul aa de la séquence protéique) il est plus difficile de se décider [TODO insert citation] nous avons donc utilisé les logiciels SIFT et Polyphen et filtré l'ensemble des fauxsens prédit comme *tolerated* par SIFT et *benign* par Polyphen.  
4. **Transcrits NMD :** Le mécanisme NMD (*nonsense-mediated decay*) a pour but de controler la qualité des ARNm cellulaires chez les eucaryotes [@Chang2007] en éliminant les ARNm qui comportent un codon stop prématuré [@Baker2004], pouvant être le résultat d'une erreur de transcription, d'une mutation ou encore d'une erreur d'épissage. Il est donc peu probable que les variants présents sur transcrits annotés NMD soient responsables du phénotype. Nous avons donc filtré l'ensemble des variants chevauchant **uniquement** des transcrits annotés NMD. Cette étape de filtre permet à elle seule de filtrer systematiquement les variants de `r min_tr_nmd` à `r max_tr_nmd` transcrits (**Figure : **\@ref(fig:nmdtranscripts)) en fonction des individus soit, entre `r min_var_nmd` et `r max_var_nmd` variants différents par individus (**Figure : **\@ref(fig:comparefilter)).    

```{r nmdtranscripts, fig.cap=fig.info,fig.scap=fig.name, fig.height=4, cache=TRUE}

fig.name <- "Nombre de transcrits filtrés car ils sont annotés NMD"
fig.description <- "Chaque point représente un individu séquencé, la couleur et la forme du point dépend de la famille d'origine de l'individu"
fig.info <- paste0(fig.name," : ",fig.description)

ggplot(df_nmd, aes("",NB_TR)) +
  geom_boxplot(width = 0.35, alpha = .4, outlier.size = -1) +
  geom_jitter(aes(col = RUN), size = 3, position=position_jitter(0.3)) +
  scale_fill_discrete(guide = "none") +
  scale_color_discrete(name = "Familly") +
  ylab("Nb of transcripts flagged as NMD") + 
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())


```
5. **Frequence des variants :**  La fréquence d'un variant dans la population générale est un moyen rapide d'avoir un avis sur l'effet délétère de celui-ci. En efft, il est peu probable qu'un retrouvé fréquement dans la population générale soit causal d'une pathologie sévère. Ainsi nous avons filtré pour l'ensemble de nos patients l'ensemble des variants ayant une fréquence $\ge$ `r maf_cutoff` dans l'une des trois bases de données que sont ExAC, ESP et 1KG.    
6. **Présence des variants dans la cohorte contrôle :**  Au cours de nos différentes études, nous avons été ammené à séquencé `r n_tot_runs`. L'ensemble de ces individus peuvent être soit sains soit présenter l'un des `r n_pheno` phénotypes étudié au cours de nos différentes études (**Table : **\@tab(fig:TODO)). Ces phénotypes étant très différent, il n'est pas abérant d'emmetre l'hypothèse qu'ils que leurs causes génétiques soient diffrentes. De même, les variants recherché étant rares, il est peu probable qu'un individu porte les variants de deux phénotypes différents. Ainsi, pour chacune des `r nb_fam` familles, nous avons pu constituer une cohorte contrôle composée dans l'ensemble des patients précédemment analysés et ne présentant pas le même phénotype que celui étudié dans la famille (**Figure : **\@ref(fig:plotsamplectrl)). Dès lors, nous avons put filtrer l'ensemble des variants retrouvés à la fois chez nos patients et observés à l'état homozygote dans la cohorte contrôle.  


```{r plotsamplectrl, fig.cap=fig.info,fig.scap=fig.name, fig.height=4, cache=TRUE}

fig.name <- "Nombre d'individus la cohorte contrôle constituée pour chaque famille de l'analyse"
fig.info <- paste0(fig.name)

fam_lab = c("Az", "FF", "MMAF1", "MMAF2", "MMAF3", "MMAF4")
nb_sample <- c(resume_run(df_fam_az, type = "nb"), 
               resume_run(df_fam_ff, type = "nb"), 
               resume_run(df_fam_mmaf1, type = "nb"), 
               resume_run(df_fam_mmaf2, type = "nb"), 
               resume_run(df_fam_mmaf3, type = "nb"), 
               resume_run(df_fam_mmaf4, type = "nb"))

nb_ctrl <- c(nb_ctrl_az, nb_ctrl_ff,nb_ctrl_mmaf,nb_ctrl_mmaf,nb_ctrl_mmaf,nb_ctrl_mmaf)

df_sample_ctrl <- data_frame(FAM = fam_lab,
                             Sample = nb_sample,
                             Ctrl = nb_ctrl) %>% 
  gather(TYPE,NB,Sample:Ctrl) %>%
  filter(TYPE == "Ctrl")

ggplot(df_sample_ctrl, aes(FAM, NB, fill = FAM)) + 
  geom_bar(stat = "identity", position = "dodge") + 
  geom_text(aes(label = NB), position = position_dodge(width = .9), vjust = -.25) +
  ylab("Number of control individuals") + 
  scale_fill_discrete(guide = "none") +
  xlab("Familly")

```

Afin de comparer le pouvoir discriminant de chacun de ces filtres, nous avons compté le nombre de variant filtrés par chacun d'entre eux indépendamments des autres (**Figure : **\@ref(fig:comparefilter)).  

```{r comparefilter, dependson=c("datafamaz","datafamff","datammaf1","datammaf2","datammaf3","datammaf4"), fig.cap=fig.info,fig.scap=fig.name, fig.asp=.6, cache=TRUE}

fig.name <- "Comparaison du pouvoir discriminant de chaque filtre employé."
fig.description <- ""
fig.info <- paste0(fig.name)

ggplot(rm_var_all, aes(FILTER, N_REMOVE)) +
  geom_boxplot(outlier.size = -1, alpha = .3) + 
  geom_jitter(position=position_jitter(0.2), aes(col = RUN)) + 
  scale_fill_discrete(guide = "none") + 
  xlab("Applied filter") + 
  ylab("Nb of removed variants")

```

```{r remaininggense}

df_remaining_gene <- rbind(df_filter_az %>% distinct(SYMBOL,FAM.x) %>% mutate(CAUSAL = "SPINK2"),
                           df_filter_ff %>% distinct(SYMBOL,FAM.x) %>% mutate(CAUSAL = "PLCZ"),
                           df_filter_mmaf1 %>% distinct(SYMBOL,FAM.x) %>% mutate(CAUSAL = "???"),
                           df_filter_mmaf2 %>% distinct(SYMBOL,FAM.x) %>% mutate(CAUSAL = "DNAH1"),
                           df_filter_mmaf3 %>% distinct(SYMBOL,FAM.x) %>% mutate(CAUSAL = "???"),
                           df_filter_mmaf4 %>% distinct(SYMBOL,FAM.x) %>% mutate(CAUSAL = "???")) %>% 
  mutate(FIND_CAUSAL = if_else(CAUSAL == "???","No","Yes")) %>%
  rename(Familly = FAM.x)
  

df_causal <- group_by(df_remaining_gene, Familly, FIND_CAUSAL, CAUSAL) %>%
  summarise(N = n())

```

Après avoir effectuer l'ensemble de ces filtres, seuls quelques variants subsistent nous permettant d'obtenir unle liste de gènes restrainte pour chaque famille (**Table : **\@tab(fig:tablegene)). Ainsi, la cause génétique expliquant le phénotype d'une famille a pu être mis en évidence dans ... familles sur ... [TODO] (**Figure : **\@ref(fig:plotremaininggenes)). Il est a noté que l'ensemble des familles pour lesquelles la cause génétique a été identifiée présente un historique consanguin [figure arbre] ce qui n'était pas le cas pour les ... autres. Cette consanguinité observée dans une partie des famille nous a permi de justifier l'exclusion des variants hétérozygotes. En revanche pour les ... autres fa milles, rien ne justifiait un tel filtre. Ainsi, pour celles-ci il est probable que les variants responsables se soient vu exclus par ce filtre. C'est pourquoi, notre équipe se concentre actuellement sur les variants hétérozygotes de ces familles.     

```{r plotremaininggenes, fig.cap=fig.info,fig.scap=fig.name, cache=TRUE}

fig.name <- "Nombre de gènes passant l'ensemble des filtres par famille"
fig.description <- "Chaque point représente un individu séquencé, la couleur et la forme du point dépend de la famille d'origine de l'individu"
fig.info <- paste(fig.name)

ggplot(df_causal, aes(Familly, N)) + 
  geom_bar(stat = "identity", aes(fill = FIND_CAUSAL)) + 
  scale_y_continuous(limits = c(0,max(df_causal$N) + 1), breaks = seq(0,max(df_causal$N) + 1,2)) + 
  geom_text(aes(label = CAUSAL), position = position_dodge(width = .9), vjust = -.25) +
  ylab("Nb of remaining genes after all filtering") + 
  theme(axis.title.x=element_blank()) + 
  scale_fill_discrete(name = "Is the causal variant found?")

```

```{r tablegene}

tab.name <- "Tableau des gènes ayant passé l'ensemble des filtres pour les fifférentes familles"

kable(df_remaining_gene %>%
        select(Familly, SYMBOL) %>%
        ungroup() %>%
        mutate(ind = row_number()) %>%
        
        spread(Familly, SYMBOL, fill = " ") %>% select(-ind),
      booktabs = TRUE,
      caption = tab.name)

```

```{r cleanfam, include=FALSE}

rm(rm_var_all, rm_var_az, rm_var_ff, rm_var_mmaf1, rm_var_mmaf2, rm_var_mmaf3, rm_var_mmaf4)
rm(resume_pheno, resume_tot, resume_geno)
rm(df_fam_az, df_fam_ff, df_fam_mmaf1, df_fam_mmaf2, df_fam_mmaf3, df_fam_mmaf4)
rm(df_filter_az, df_filter_ff, df_filter_mmaf1, df_filter_mmaf2, df_filter_mmaf3, df_filter_mmaf4)
rm(df_mmaf1_1, df_mmaf1_2, df_mmaf2_1, df_mmaf2_2, df_mmaf3_1, df_mmaf3_2, df_mmaf4_1, df_mmaf4_2, df_mmaf4_3)

gc()

```

### Etude d’une large cohorte de patients MMAF  {#cohortemmah}  

```{r mmafdata, cache=TRUE}

run_mmaf_fam <- c("Ghs56","Ghs58","Ghs62","Ghs130","Ghs63","Ghs119","Ghs59","Ghs60","Ghs61")

df_rvis <- fread("data/RVIS_Unpublished_ExAC_May2015.txt",sep = "\t",header = TRUE,data.table = FALSE) %>%
  dplyr::select(GENE = CCDS_r15,SCORE = `RVIS_ExAC_0.05%(AnyPopn)`) %>%
  mutate(SYMBOL = GENE,
         RVIS_PERCENTILE = percent_rank(SCORE)) %>%
  dplyr::select(-SCORE) %>%
  na.omit()

df_mmaf_all <- fread("data/genotype_MMAF.csv", sep = "\t", header = TRUE, showProgress = FALSE, verbose = FALSE) %>%
  gather(RUN, CALL, starts_with("Ghs")) %>%
  filter(CALL %in% c(2, 3, "b", "c"),
         !(RUN %in% run_mmaf_fam)) %>%
  mutate(TYPE = if_else(stri_length(REF) == stri_length(ALT), "SNV", "Indel"),
         STRAND = if_else(CALL %in% c(2, 3), "Both_strand", "Single_strand"),
         GENOTYPE = if_else(CALL %in% c(2, "b"), "Heterozygous", "Homozygous"))

df_mmaf_annotated <- variant_join(df_mmaf_all, df_all_coding_variants, mode = "inner")

df_filter_mmaf_all <- df_mmaf_all %>%
  filter_genotype(het = FALSE) %>%
  variant_join(df_ctrl_mmaf, mode = "anti") %>%
  variant_join(df_all_coding_variants, mode = "inner") %>%
  filter(Consequence != "synonymous_variant",     # Filter variant considering their impact on transcript
         Consequence != "5_prime_UTR_variant",
         Consequence != "3_prime_UTR_variant",
         !grepl("NMD_transcript_variant",Consequence),
         !(grepl("tolerated",SIFT) & grepl("benign",PolyPhen))) %>%  filter_frequence(cutoff = maf_cutoff) %>%
  select(-CADD_RAW)

df_passing_filter_mmaf_genes <- df_filter_mmaf_all %>% 
  select(RUN, SYMBOL) %>% 
  group_by(SYMBOL) %>%
  summarise(N_RUN = n_distinct(RUN))

distinct(df_filter_mmaf_all, SYMBOL,CHR,POSITION,REF,ALT) %>%
       select(Chromosome = CHR, Position = POSITION,`Reference allele` = REF,`Alterated allele` = ALT,Gene=SYMBOL)

nb_run_per_passing_gene <- ungroup(df_filter_mmaf_all) %>%
  distinct(SYMBOL,RUN) %>%
  mutate(N_TOT = n_distinct(SYMBOL)) %>%
  group_by(RUN) %>%
  summarise(N_TOT = mean(N_TOT),
            N_per_run = n_distinct(SYMBOL)) 

nb_run_mmaf <- df_runs %>% select(`Magic ID`, Pathologie) %>% 
  filter(Pathologie == "Flag",
         !(`Magic ID` %in% run_mmaf_fam)) %>% 
  nrow()

```

Dans cette partie, nous allons détailler les analyses effectuées sur une cohorte de `r nb_run_mmaf` individus présentant le phénotype MMAF pour lesquels nous avons effectués un séquençage WES. Nous avons ainsi pu appliquer notre pipeline d'analyse afin d'appeler et annoter les variants de ces `r nb_run_mmaf` individus (**Figure : **\@ref(fig:largemmafcall)).

```{r largemmafcall, fig.cap=fig.info,fig.scap=fig.name, cache=TRUE}

fig.name <- "Comptage des variants pour chaque individus avec leur génotype et l'impact prédite par VEP"
fig.description <- "VEP possède quatre niveaux d'impact pour ses variants : **HIGH** : variant ayant une forte probabilité de causer des dommages sévères à la protéine, **MODERATE** : Variants non-tronquant pouvant tout de même affecté la protéine, **LOW** : variant ayant peu de chance d'alterer la protéine, **MODIFIER** :  Variants affectant les régions non codantes du transcrits et dont l'impact sur la protéine est difficile à prévoir. Chaque barre représente le comptage pour un individus"

fig.info <- paste(fig.name," : ",fig.description)

ggplot(df_mmaf_annotated, aes(RUN)) +
  geom_bar(aes(fill = IMPACT), position = position_dodge()) +
  scale_fill_discrete(name = "VEP impact prediction", guide=FALSE) +
  xlab("Individuals") +
  ylab("Nb of variant") +
  facet_grid(IMPACT ~ GENOTYPE, scales = "free") + 
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

```

```{r varperrun, cache=TRUE}

df_var_per_run <- df_filter_mmaf_all %>% 
  group_by(TYPE)%>%
  mutate(N_tot = n_distinct(CHR, POSITION, REF, ALT)) %>% 
  distinct(CHR,POSITION,REF,ALT,RUN, N_tot) %>% 
  group_by(TYPE, RUN) %>% 
  summarise(N_per_run = n(),
            N_tot = mean(N_tot))  

nb_snv_tot <- df_var_per_run %>% filter(TYPE == "SNV") %>% collect() %>% .[["N_tot"]] %>% mean()
nb_indel_tot <- df_var_per_run %>% filter(TYPE == "Indel") %>% collect() %>% .[["N_tot"]] %>% mean()

nb_snv_max <- df_var_per_run %>% filter(TYPE == "SNV") %>% collect() %>% .[["N_per_run"]] %>% max()
nb_snv_min <- df_var_per_run %>% filter(TYPE == "SNV") %>% collect() %>% .[["N_per_run"]] %>% min()

nb_indel_max <- df_var_per_run %>% filter(TYPE == "Indel") %>% collect() %>% .[["N_per_run"]] %>% max()
nb_indel_min <- df_var_per_run %>% filter(TYPE == "Indel") %>% collect() %>% .[["N_per_run"]] %>% min()

df_filter_pass_or_not <- df_mmaf_all %>%
  filter(!is.na(REF)) %>%
  distinct(CHR,POSITION,REF,ALT,TYPE,RUN) %>%
  group_by(CHR,POSITION,REF,ALT,TYPE) %>%
  left_join(df_filter_mmaf_all, by = c("CHR", "POSITION", "REF", "ALT", "TYPE")) %>% 
  mutate(STATUS = if_else(is.na(CALL), "FILTERED", "PASS")) %>%
  select(-(CALL:ExAC_AF)) %>% 
  distinct(STATUS) %>%
  ungroup() %>%
  mutate(N_TOT = n()) %>%
  group_by(STATUS, TYPE) %>%
  summarise(N_TYPE_STATUS = n(),
            N_TOT = mean(N_TOT)) %>% group_by(TYPE) %>%
  mutate(N_TYPE = sum(N_TYPE_STATUS)) %>% 
  group_by(STATUS, TYPE) %>% 
  mutate(P_TYPE_STATUS = N_TYPE_STATUS / N_TYPE) 



```

Les filtres utilisés ont été les mêmes que ceux détaillés dans l'études des cas familiaux, c'est à dire que seul les variants homozygotes ayant une fréquence $\le$ `r maf_cutoff` dans la population générales et n'étant pas observés dans la cohorte contrôle de `r nb_ctrl_mmaf` individus furent conservés. De même, les variants synonymes, impactant la séquences UTR ou chevauchant uniquement des transcrits annotés NMD par VEP on été filtrés. Ainsi, ces différents filtres nous ont permis d'obtenir une liste de `r nb_snv_tot` SNVs (entre `r nb_snv_min` et `r nb_snv_max` différents par patients) et de `r nb_indel_tot` indels (entre `r nb_indel_min` et `r nb_indel_max` différents par patients) (**Figure : **\@ref(fig:plotvarperrun)).  

```{r plotvarperrun, fig.cap=fig.info,fig.scap=fig.name, echo=FALSE, cache=TRUE}

fig.name <- "Comptage des variants filtrés"
fig.description <- "**A**: Comptage des SNVs et Indels ayant été filtrés (FILTERED) et ayant passé les filtres (PASS), **B**: Pourcentage des SNVs et indels ayant passé les filtres, **C**: Comptage pour chaque individus du nombre de SNVs et d'indels ayant passé les filtres. Chaque point représente le comptage pour un individus"

fig.info <- paste(fig.name," : ",fig.description)

p1 <- ggplot(df_var_per_run,aes("",N_per_run)) +
  geom_boxplot(outlier.size = -1, aes(fill = TYPE)) +
  facet_wrap(~TYPE,scales = "free") +
  geom_jitter(position=position_jitter(0.2)) +
  scale_fill_discrete(guide = "none") +
  ylab("Nb of variants") + 
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

p2 <- ggplot(df_filter_pass_or_not, aes(TYPE, N_TYPE_STATUS)) + 
  geom_bar(aes(fill = TYPE), stat = "identity") + 
  facet_wrap(~STATUS, scales = "free") + 
  scale_fill_discrete(guide = "none") + 
  ylab("Nb of variants") +
  theme(axis.title.x=element_blank())

p3 <- ggplot(df_filter_pass_or_not %>% filter(STATUS == "PASS"), aes(TYPE, P_TYPE_STATUS)) + 
  geom_bar(aes(fill = TYPE), stat = "identity") + 
  facet_wrap(~STATUS, scales = "free") + 
  scale_y_continuous(labels = percent) + 
  scale_fill_discrete(guide = "none") + 
  ylab("Percent of variants") +
  theme(axis.title.x=element_blank())

top_row <- plot_grid(p2,p3, labels = c("A","B"), align = 'h')
plot_grid(top_row,p1, ncol = 1, labels = c("","C"))

```

```{r plotpassinggenes, fig.cap=fig.info,fig.scap=fig.name, fig.height=6.5, fig.width=6}

fig.name <- "Analyse des gènes passant les filtres"
fig.description <- "**A**: Représentation du nombre de gène ayant passé l'ensemble des filtres pour chaque individus (chaque point correspond à un individu), **B**: Visualisation du nombre de patient portant au moins un sur le même gène"

pA <- ggplot(nb_run_per_passing_gene, aes("", N_per_run)) +
  geom_boxplot(width = .5) + 
  geom_jitter(position=position_jitter(0.2)) + 
  ylab("Nb of passing filter gene") + 
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank())

pB <- ggplot(df_passing_filter_mmaf_genes, aes(N_RUN)) +
  geom_text(aes(label = ..count..),  position = position_dodge(width = .9), vjust = -.25, stat= "count") +
  geom_bar(position = position_dodge()) +
  ylab("Nb of Gene") +
  xlab("Nb of patient carrying a variant on the same gene") +
  scale_x_continuous(breaks = c(1:15)) 

plot_grid(pA,pB, ncol = 1, rel_heights = c(1, 1.8), labels = c("A","B"))

```


```{r aaa, cache=TRUE}

# ggplot(df_nb_view,aes(N)) +
#   geom_bar(aes(fill = TYPE)) +
#   geom_text(aes(label = ..count..), position = position_stack(vjust = 1), stat= "count") +
#   facet_grid(TYPE~.,scales = "free") +
#   scale_fill_discrete(guide = "none") +
#   ylab("Count") +
#   xlab("Nb of patient sharing a same variant")
# 
# ggplot(df_variants_mmaf_nb_view,aes(N)) +
#   geom_bar(aes(fill = TYPE)) +
#   # geom_text(aes(label = ..count..), position = position_stack(vjust = 1), stat= "count") +
#   facet_grid(TYPE~.,scales = "free") +
#   scale_fill_discrete(guide = "none") +
#   ylab("Count") +
#   xlab("Nb of patient sharing a same variant")

```


```{r}

# <!--     b. Liste complète des gènes avec 2 variants tronquants -->
# 
# df_filter_het_mmaf <- df_variants_mmaf %>%
#   inner_join(df_all_coding_variants, by = c("CHR", "POSITION", "REF", "ALT")) %>%
#   filter(GENOTYPE == "Heterozygous",
#          IMPACT == "HIGH",
#          !grepl("NMD_transcript_variant",Consequence),
#          !(grepl("tolerated",SIFT) & grepl("benign",PolyPhen)),
#          is.na(ExAC_AF) | ExAC_AF <= maf_cutoff,
#          is.na(ESP) | ESP <= maf_cutoff,
#          is.na(`1KG`) | `1KG` <= maf_cutoff) %>%
#   anti_join(df_not_mmaf, by = c("CHR", "POSITION", "REF", "ALT")) %>%
#   select(-CADD_RAW) %>%
#   left_join(df_rvis, by = "SYMBOL") %>%
#   filter(is.na(RVIS_PERCENTILE) | RVIS_PERCENTILE <= .9)
# 
# two_var_gene <- df_filter_het_mmaf %>%
#   group_by(Feature,RUN) %>%
#   mutate(NVGP = n()) %>%
#   filter(NVGP >= 2) %>%
#   ungroup() %>%
#   distinct(SYMBOL,Feature,NVGP) %>%
#   group_by(SYMBOL) %>%
#   summarise(NVGP = max(NVGP))

```

<!-- 1. Les nouveaux gènes candidats évidents -->
<!-- 2. L’efficacité diagnostique -->
<!-- 3. L’analyse individuelle -->
<!--     a. Les mutations dans les gènes identifiés -->
<!--     b. Liste complète des gènes avec 2 variants tronquants -->
<!--     c Liste complète des gènes avec deux variants dont un tronquant -->
<!--     d. Liste des  gènes avec 2 variants intronique ou faux-sens/synonymes avec un score élevé UMD-predictor ou HSF. -->
<!--     e. Liste des gènes avec un variant hétérozygote tronquant -->











